<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Naeun Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="temp">
<meta property="og:type" content="website">
<meta property="og:title" content="Naeun Blog">
<meta property="og:url" content="https://ne-choi.github.io/page/2/index.html">
<meta property="og:site_name" content="Naeun Blog">
<meta property="og:description" content="temp">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Naeun Choi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Naeun Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">Naeun Blog</a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives/">Archives</a>
        
          <a class="main-nav-link" href="/about/">about</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ch02_사이킷런으로_시작하는_머신러닝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/ch02_%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9C%BC%EB%A1%9C_%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/">ch02. 사이킷런으로 시작하는 머신러닝</a>
    </h1>
  

        <a href="/2020/11/29/ch02_%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9C%BC%EB%A1%9C_%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/" class="article-date">
  <time datetime="2020-11-28T15:00:00.000Z" itemprop="datePublished">2020-11-29</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>해당 자료는 <a target="_blank" rel="noopener" href="https://book.naver.com/bookdb/book_detail.nhn?bid=16238302">파이썬 머신러닝 완벽가이드</a> 공부를 위한 필사본입니다.</li>
</ul>
<h1 id="Chapter-02-사이킷런으로-시작하는-머신러닝"><a href="#Chapter-02-사이킷런으로-시작하는-머신러닝" class="headerlink" title="Chapter 02. 사이킷런으로 시작하는 머신러닝"></a>Chapter 02. 사이킷런으로 시작하는 머신러닝</h1><h2 id="01-사이킷런-소개와-특징"><a href="#01-사이킷런-소개와-특징" class="headerlink" title="01. 사이킷런 소개와 특징"></a>01. 사이킷런 소개와 특징</h2><ul>
<li><strong>사이킷런(scikit-learn)</strong><ul>
<li>파이썬 머신러닝 라이브러리 중 가장 많이 사용되는 라이브러리</li>
<li>파이썬 기반의 머신러닝을 위한 가장 쉽고 효율적인 개발 라이브러리를 제공</li>
</ul>
</li>
</ul>
<ul>
<li><strong>사이킷런 특징</strong><ul>
<li>쉽고 가장 파이썬스러운 API 제공</li>
<li>머신러닝을 위한 다양한 알고리즘, 개발을 위한 편리한 프레임워크와 API 제공</li>
<li>오랜 기간 실전 환경에서 검증됐으며, 매우 많은 환경에서 사용되는 성숙한 라이브러리</li>
</ul>
</li>
</ul>
<ul>
<li>Anaconda를 설치하면 기본적으로 사이킷런까지 설치가 되기에 설치할 필요는 없음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사이킷런 버전 확인</span></span><br><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">print(sklearn.__version__)</span><br></pre></td></tr></table></figure>

<pre><code>0.23.1</code></pre>
<h2 id="02-첫-번째-머신러닝-붓꽃-품종-예측"><a href="#02-첫-번째-머신러닝-붓꽃-품종-예측" class="headerlink" title="02. 첫 번째 머신러닝 - 붓꽃 품종 예측"></a>02. 첫 번째 머신러닝 - 붓꽃 품종 예측</h2><ul>
<li>붓꽃 데이터 세트로 붓꽃의 품종을 분류(classification)</li>
<li>붓꽃 데이터 세트: 꽃잎 길이, 너비, 꽃받침 길이, 너비 피차(feature)를 기반으로 꽃 품종을 예측하기 위한 데이터 세트</li>
</ul>
<ul>
<li><strong>분류는 대표적인 지도학습(Supervised Learning) 방법의 하나</strong></li>
<li><strong>지도학습</strong><ul>
<li>학습을 위한 다양한 피처와 분류 결정값인 레이블 데이터로 모델을 학습한 뒤, 별도의 테스트 데이터 세트에서 미지의 레이블을 예측<br>→ 지도학습은 명확한 정답이 주어진 데이터를 먼저 학습한 뒤 미지의 정답을 예측하는 방식</li>
<li>학습 데이터 세트: 학습을 위해 주어진 데이터 세트</li>
<li>테스트 데이터 세트: 머신러닝 모델의 예측 성능 평가를 위해 주어진 데이터 세트</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사이킷런에서 자체적으로 제공하는 데이터 세트를 생성하는 모듈의 모임</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn.tree 내 모듈은 트리 기반 ML 알고리즘을 구현한 클래스 모임</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 데이터와 검증 데이터, 예측데이터로 데이터를 분리하거나 최적의 하이퍼 파라미터로 평가하기 위한 다양한 모듈의 모임</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 붓꽃 데이터 세트 로딩</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"></span><br><span class="line"><span class="comment"># iris.data는 Iris 데이터 세트에서 피처만으로 된 데이터를 numpy로 가짐</span></span><br><span class="line">iris_data = iris.data</span><br><span class="line"></span><br><span class="line"><span class="comment"># iris.target은 붓꽃 데이터 세트에서 레이블(결정값) 데이터를 numpy로 가짐</span></span><br><span class="line">iris_label = iris.target</span><br><span class="line">print(<span class="string">&#x27;iris target값:&#x27;</span>, iris_label)</span><br><span class="line">print(<span class="string">&#x27;iris target명:&#x27;</span>, iris.target_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 붓꽃 데이터 세트를 자세히 보기 위해 DataFrame으로 변환</span></span><br><span class="line">iris_df = pd.DataFrame(data=iris_data, columns=iris.feature_names)</span><br><span class="line">iris_df[<span class="string">&#x27;label&#x27;</span>] = iris.target</span><br><span class="line">iris_df.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<pre><code>iris target값: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
iris target명: [&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal length (cm)</th>
      <th>sepal width (cm)</th>
      <th>petal length (cm)</th>
      <th>petal width (cm)</th>
      <th>label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li><p>피처는 총 4개, 레이블은 3개(0: setosa 품종, 1: versicolor 품종, 2: virginica 품종)</p>
</li>
<li><p>학습용 데이터와 테스트용 데이터 분리하기</p>
<ul>
<li>train_test_split() API를 사용하면, 학습 데이터와 테스트 데이터를 test_size 파라미터 입력 값의 비율로 쉽게 분할함</li>
<li>test_size=0.2 ← 전체 데이터 중, 테스트 데이터가 20%, 학습 데이터가 80%로 분할됨</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dt_clf = DecisionTreeClassifier()</span><br><span class="line">iris_data = load_iris()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_data.data, iris_data.target, test_size = <span class="number">0.2</span>, random_state=<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>train_test_split()</strong><ul>
<li>iris_data: 피처 데이터 세트</li>
<li>iris_label: 레이블 데이터 세트</li>
<li>test_size=0.2: 전체 데이터 세트 중 테스트 데이터 세트 비율 = 20%</li>
<li>random_state: 호출 시마다 같은 학습/테스트용 데이터 세트를 생성하기 위해 주어지는 난수 발생 값 (여기서는 값 고정을 위해 임의 숫자를 넣음)</li>
<li>train_test_split(): 호출 시 무작위로 데이터를 분리 → random_state를 지정하지 않으면 수행할 때마다 다른 학습/테스트용 데이터가 생성됨</li>
</ul>
</li>
</ul>
<ul>
<li><strong>train_test_split() 구분</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th align="left">X_train</th>
<th align="left">X_test</th>
<th align="left">y_train</th>
<th align="left">y_test</th>
</tr>
</thead>
<tbody><tr>
<td align="left">학습용 피처 데이터 세트</td>
<td align="left">테스트용 피처 데이터 세트</td>
<td align="left">학습용 레이블 데이터 세트</td>
<td align="left">테스트용 레이블 데이터 세트</td>
</tr>
</tbody></table>
<ul>
<li>의사결정나무로 학습과 예측 수행<ol>
<li>사이킷런 의사결정나무 클래스인 DecisionTreeClassifier를 객체로 생성</li>
<li>생성된 DecisionTreeClassifier 객체의 fit() 메서드에 학습용 피처 데이터 속성과 결정값 데이터 세트를 입력해 호출</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DecisionTreeClassifier 객체 생성</span></span><br><span class="line">dt_clf = DecisionTreeClassifier(random_state=<span class="number">11</span>) <span class="comment"># 같은 학습/예측 결과를 위해 random 값 임의 지정</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 수행</span></span><br><span class="line">dt_clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>




<pre><code>DecisionTreeClassifier(random_state=11)</code></pre>
<ul>
<li>위 코드 실행 결과, DecisionTreeClassifier 객체는 학습 데이터 기반으로 학습 완료</li>
<li>학습된 객체를 이용해 예측 수행<ul>
<li>예측은 반드시 학습 데이터가 아닌 다른 데이터를 이용해야 하며, 일반적으로 테스트 데이터 세트를 이용</li>
<li>DecisionTreeClassifier 객체의 predict() 메서드에 테스트용 피처 데이터 세트를 입력해 호출하면, 학습된 모델 기반에서 테스트 데이터 세트에 대한 예측값을 반환</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 학습 완료된 객체에서 테스트 데이터 세트로 예측 수행</span></span><br><span class="line">pred = dt_clf.predict(X_test)</span><br></pre></td></tr></table></figure>

<ul>
<li>예측 결과 기반으로 DecisionTreeClassifier의 예측 성능 평가하기<ul>
<li>해당 예제에서는 정확도(예측 결과가 실제 레이블값과 얼마나 일치하는지) 평가</li>
<li>사이킷런에서는 정확도 측정을 위해 <strong>accuracy_score()</strong> 함수 제공</li>
<li>accuracy_score: 첫 번째 파라미터로 실제 레이블 데이터 세트, 두 번째 파라미터로 예측 레이블 데이터 세트 입력</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">print(<span class="string">&#x27;예측 정확도: &#123;0: 4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, pred)))</span><br></pre></td></tr></table></figure>

<pre><code>예측 정확도:  0.933333</code></pre>
<ul>
<li>학습한 의사결정나무 알고리즘 예측 정확도가 약 0.9333(93.33%)으로 측정됨<ol>
<li>데이터 세트 분리: 데이터를 학습 데이터와 테스트 데이터로 분리</li>
<li>모델 학습: 학습 데이터를 기반으로 ML 알고리즘을 적용해 모델을 학습시킴</li>
<li>예측 수행: 학습된 ML 모델로 테스트 데이터의 분류(즉, 붓꽃 종류) 예측</li>
<li>평가: 예측된 결괏값과 테스트 데이터의 실제 결괏값을 비교해 ML 모델 성능을 평가</li>
</ol>
</li>
</ul>
<h2 id="03-사이킷런의-기반-프레임워크-익히기"><a href="#03-사이킷런의-기반-프레임워크-익히기" class="headerlink" title="03. 사이킷런의 기반 프레임워크 익히기"></a>03. 사이킷런의 기반 프레임워크 익히기</h2><h3 id="1-Estimator-이해-및-fit-predict-메서드"><a href="#1-Estimator-이해-및-fit-predict-메서드" class="headerlink" title="1. Estimator 이해 및 fit(), predict() 메서드"></a>1. Estimator 이해 및 fit(), predict() 메서드</h3><ul>
<li>사이킷런은 API 일관성과 개발 편의성을 제공하기 위한 패키지<ul>
<li>사이킷런을 ML 모델 학습을 위해 fit()을, 학습된 모델의 예측을 위해 predict() 메서드를 제공</li>
<li>지도학습의 주요 두 축인 분류(classification)와 회귀(regression)의 다양한 예측 결과를 반환</li>
<li>사이킷런에서는 분류 알고리즘을 구현한 클래스를 classifier로, 회귀 알고리즘을 구현한 클래스를 regressor로 지칭</li>
<li>사이킷런은 매우 많은 유형의 classifier와 regressor 클래스를 제공: 이를 합쳐 Estimator 클래스라고 부름</li>
</ul>
</li>
</ul>
<ul>
<li>사이킷런에서 비지도학습인 차원 축소, 피처 추출 등을 구현한 클래스 역시 대부분 fit()과 transform()을 적용<ul>
<li>비지도학습과 피처 추출에서 fit()은 지도학습의 fit() 같이 학습을 의미하는 것이 아니라, 입력 데이터의 형태에 맞춰 데이터를 변환하기 위한 사전 구조를 맞추는 작업</li>
<li>fit()으로 변환을 위한 사전 구조를 맞추면 이후 입력 데이터의 차원 변환, 클러스터링, 피처 추출 등의 실제 작업은 transform()으로 수행</li>
<li>사이킷런은 fit()과 transform()을 하나로 결합한 fit_transform()도 함께 제공</li>
</ul>
</li>
</ul>
<h3 id="2-사이킷런의-주요-모듈"><a href="#2-사이킷런의-주요-모듈" class="headerlink" title="2. 사이킷런의 주요 모듈"></a>2. 사이킷런의 주요 모듈</h3><ul>
<li>교재 참고</li>
</ul>
<h3 id="3-내장된-예제-데이터-세트"><a href="#3-내장된-예제-데이터-세트" class="headerlink" title="3. 내장된 예제 데이터 세트"></a>3. 내장된 예제 데이터 세트</h3><ul>
<li>분류나 회귀 연습용 예제 데이터</li>
</ul>
<table>
<thead>
<tr>
<th align="left">API명</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">datasets.load_boston()</td>
<td align="left">회귀 용도이며, 미국 보스턴의 집 피처들과 가격에 대한 데이터 세트</td>
</tr>
<tr>
<td align="left">datasets.load_breast_cancer</td>
<td align="left">분류 용도이며, 위스콘신 유방암 피처들과 악성/음성 레이블 데이터 세트</td>
</tr>
<tr>
<td align="left">datasets.load_diabetes</td>
<td align="left">회귀 용도이며, 당뇨 데이터 세트</td>
</tr>
<tr>
<td align="left">datasets.load_digits()</td>
<td align="left">분류 용도이며, 0에서 9까지 숫자 이미지 픽셀 데이터 세트</td>
</tr>
<tr>
<td align="left">datasets.load_iris()</td>
<td align="left">분류 용도이며, 붓꽃에 대한 피처를 가진 데이터 세트</td>
</tr>
</tbody></table>
<br> 
- fetch 계열 명령은 데이터 용량이 커서 인터넷에서 내려받는 방식으로 사용
  - fetch_covtype(): 회귀분석용 토지 조사 자료
  - fetch_20newsgroups(): 뉴스 그룹 텍스트 자료
  - fetch_lfw_people(): 얼굴 이미지 자료
  - fetch_lfw_pairs(): 얼굴 이미지 자료
  - fetch_rcv1(): 로이터 뉴스 말뭉치
  - fetch_mldata(): ML 웹사이트에서 다운로드  

<br>
- 분류와 클러스터링을 위한 표본 데이터 생성시

<table>
<thead>
<tr>
<th align="left">API명</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">datasets.make_classifications()</td>
<td align="left">분류를 위한 데이터 세트를 만듦, 높은 상관도, 불필요한 속성 등의 노이즈 효과를 위한 데이터를 무작위로 생성</td>
</tr>
<tr>
<td align="left">datasets.make_blobs()</td>
<td align="left">클러스터링을 위한 데이터 세트를 무작위로 생성, 군집 지정 개수에 따라 여러 클러스터링을 위한 데이터 세트를 쉽게 만듦</td>
</tr>
</tbody></table>
<br>

<ul>
<li><strong>사이킷런에 내장된 데이터 딕셔너리</strong> 엿보기  <ul>
<li>data: 피처 데이터 세트를 가리킴</li>
<li>target: <strong>분류</strong>- 레이블값 데이터 세트, <strong>회귀</strong>- 숫자 결괏값 데이터 세트</li>
<li>target_names: 개별 레이블 이름</li>
<li>feature_names: 피처 이름</li>
<li>DESCR: 데이터 세트에 관한 설명과 각 피처의 설명</li>
</ul>
</li>
</ul>
<ul>
<li>설명<ul>
<li>data, target: 넘파이 배열(ndarray) 타입</li>
<li>target_names, feature_names: 넘파이 배열 또는 파이썬 리스트(list) 타입</li>
<li>DESCR: 스트링타입</li>
<li>피처 데이터값을 반환받기 위해서는 내장 데이터 세트 API를 호출한 뒤, key 값을 지정하면 됨</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 붓꽃 데이터 세트 생성</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris_data = load_iris()</span><br><span class="line">print(<span class="built_in">type</span>(iris_data))</span><br></pre></td></tr></table></figure>

<pre><code>&lt;class &#39;sklearn.utils.Bunch&#39;&gt;</code></pre>
<ul>
<li>load_iris() API 반환 결과는 sklearn.utils.Bunch 클래스 (딕셔너리 자료형과 유사)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = iris_data.keys()</span><br><span class="line">print(<span class="string">&#x27;붓꽃 데이터 세트의 키들:&#x27;</span>, keys)</span><br></pre></td></tr></table></figure>

<pre><code>붓꽃 데이터 세트의 키들: dict_keys([&#39;data&#39;, &#39;target&#39;, &#39;frame&#39;, &#39;target_names&#39;, &#39;DESCR&#39;, &#39;feature_names&#39;, &#39;filename&#39;])</code></pre>
<ul>
<li>데이터 키는 피처들의 데이터값을 가리킴<ul>
<li>데이터 세트는 딕셔너리 형태로, 데이터 세트.data(or 데이터 세트[‘data’])로 추출 가능</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load_iris()가 반환하는 객체의 키가 가리키는 값 출력</span></span><br><span class="line">print(<span class="string">&#x27;\n feature_names의 type:&#x27;</span>, <span class="built_in">type</span>(iris_data.feature_names))</span><br><span class="line">print(<span class="string">&#x27;feature_names의 shape:&#x27;</span>, <span class="built_in">len</span>(iris_data.feature_names))</span><br><span class="line">print(iris_data.feature_names)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;\n target_names의 type:&#x27;</span>, <span class="built_in">type</span>(iris_data.target_names))</span><br><span class="line">print(<span class="string">&#x27;target_names의 shape:&#x27;</span>, <span class="built_in">len</span>(iris_data.target_names))</span><br><span class="line">print(iris_data.target_names)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;\n data의 type:&#x27;</span>, <span class="built_in">type</span>(iris_data.data))</span><br><span class="line">print(<span class="string">&#x27;data의 shape:&#x27;</span>, iris_data.data.shape)</span><br><span class="line">print(iris_data[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;\n target의 type:&#x27;</span>, <span class="built_in">type</span>(iris_data.target))</span><br><span class="line">print(<span class="string">&#x27;target의 shape:&#x27;</span>, iris_data.target.shape)</span><br><span class="line">print(iris_data.target)</span><br></pre></td></tr></table></figure>


<pre><code> feature_names의 type: &lt;class &#39;list&#39;&gt;
feature_names의 shape: 4
[&#39;sepal length (cm)&#39;, &#39;sepal width (cm)&#39;, &#39;petal length (cm)&#39;, &#39;petal width (cm)&#39;]

 target_names의 type: &lt;class &#39;numpy.ndarray&#39;&gt;
target_names의 shape: 3
[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]

 data의 type: &lt;class &#39;numpy.ndarray&#39;&gt;
data의 shape: (150, 4)
[[5.1 3.5 1.4 0.2]
 [4.9 3.  1.4 0.2]
 [4.7 3.2 1.3 0.2]
 [4.6 3.1 1.5 0.2]
 [5.  3.6 1.4 0.2]
 [5.4 3.9 1.7 0.4]
 [4.6 3.4 1.4 0.3]
 [5.  3.4 1.5 0.2]
 [4.4 2.9 1.4 0.2]
 [4.9 3.1 1.5 0.1]
 [5.4 3.7 1.5 0.2]
 [4.8 3.4 1.6 0.2]
 [4.8 3.  1.4 0.1]
 [4.3 3.  1.1 0.1]
 [5.8 4.  1.2 0.2]
 [5.7 4.4 1.5 0.4]
 [5.4 3.9 1.3 0.4]
 [5.1 3.5 1.4 0.3]
 [5.7 3.8 1.7 0.3]
 [5.1 3.8 1.5 0.3]
 [5.4 3.4 1.7 0.2]
 [5.1 3.7 1.5 0.4]
 [4.6 3.6 1.  0.2]
 [5.1 3.3 1.7 0.5]
 [4.8 3.4 1.9 0.2]
 [5.  3.  1.6 0.2]
 [5.  3.4 1.6 0.4]
 [5.2 3.5 1.5 0.2]
 [5.2 3.4 1.4 0.2]
 [4.7 3.2 1.6 0.2]
 [4.8 3.1 1.6 0.2]
 [5.4 3.4 1.5 0.4]
 [5.2 4.1 1.5 0.1]
 [5.5 4.2 1.4 0.2]
 [4.9 3.1 1.5 0.2]
 [5.  3.2 1.2 0.2]
 [5.5 3.5 1.3 0.2]
 [4.9 3.6 1.4 0.1]
 [4.4 3.  1.3 0.2]
 [5.1 3.4 1.5 0.2]
 [5.  3.5 1.3 0.3]
 [4.5 2.3 1.3 0.3]
 [4.4 3.2 1.3 0.2]
 [5.  3.5 1.6 0.6]
 [5.1 3.8 1.9 0.4]
 [4.8 3.  1.4 0.3]
 [5.1 3.8 1.6 0.2]
 [4.6 3.2 1.4 0.2]
 [5.3 3.7 1.5 0.2]
 [5.  3.3 1.4 0.2]
 [7.  3.2 4.7 1.4]
 [6.4 3.2 4.5 1.5]
 [6.9 3.1 4.9 1.5]
 [5.5 2.3 4.  1.3]
 [6.5 2.8 4.6 1.5]
 [5.7 2.8 4.5 1.3]
 [6.3 3.3 4.7 1.6]
 [4.9 2.4 3.3 1. ]
 [6.6 2.9 4.6 1.3]
 [5.2 2.7 3.9 1.4]
 [5.  2.  3.5 1. ]
 [5.9 3.  4.2 1.5]
 [6.  2.2 4.  1. ]
 [6.1 2.9 4.7 1.4]
 [5.6 2.9 3.6 1.3]
 [6.7 3.1 4.4 1.4]
 [5.6 3.  4.5 1.5]
 [5.8 2.7 4.1 1. ]
 [6.2 2.2 4.5 1.5]
 [5.6 2.5 3.9 1.1]
 [5.9 3.2 4.8 1.8]
 [6.1 2.8 4.  1.3]
 [6.3 2.5 4.9 1.5]
 [6.1 2.8 4.7 1.2]
 [6.4 2.9 4.3 1.3]
 [6.6 3.  4.4 1.4]
 [6.8 2.8 4.8 1.4]
 [6.7 3.  5.  1.7]
 [6.  2.9 4.5 1.5]
 [5.7 2.6 3.5 1. ]
 [5.5 2.4 3.8 1.1]
 [5.5 2.4 3.7 1. ]
 [5.8 2.7 3.9 1.2]
 [6.  2.7 5.1 1.6]
 [5.4 3.  4.5 1.5]
 [6.  3.4 4.5 1.6]
 [6.7 3.1 4.7 1.5]
 [6.3 2.3 4.4 1.3]
 [5.6 3.  4.1 1.3]
 [5.5 2.5 4.  1.3]
 [5.5 2.6 4.4 1.2]
 [6.1 3.  4.6 1.4]
 [5.8 2.6 4.  1.2]
 [5.  2.3 3.3 1. ]
 [5.6 2.7 4.2 1.3]
 [5.7 3.  4.2 1.2]
 [5.7 2.9 4.2 1.3]
 [6.2 2.9 4.3 1.3]
 [5.1 2.5 3.  1.1]
 [5.7 2.8 4.1 1.3]
 [6.3 3.3 6.  2.5]
 [5.8 2.7 5.1 1.9]
 [7.1 3.  5.9 2.1]
 [6.3 2.9 5.6 1.8]
 [6.5 3.  5.8 2.2]
 [7.6 3.  6.6 2.1]
 [4.9 2.5 4.5 1.7]
 [7.3 2.9 6.3 1.8]
 [6.7 2.5 5.8 1.8]
 [7.2 3.6 6.1 2.5]
 [6.5 3.2 5.1 2. ]
 [6.4 2.7 5.3 1.9]
 [6.8 3.  5.5 2.1]
 [5.7 2.5 5.  2. ]
 [5.8 2.8 5.1 2.4]
 [6.4 3.2 5.3 2.3]
 [6.5 3.  5.5 1.8]
 [7.7 3.8 6.7 2.2]
 [7.7 2.6 6.9 2.3]
 [6.  2.2 5.  1.5]
 [6.9 3.2 5.7 2.3]
 [5.6 2.8 4.9 2. ]
 [7.7 2.8 6.7 2. ]
 [6.3 2.7 4.9 1.8]
 [6.7 3.3 5.7 2.1]
 [7.2 3.2 6.  1.8]
 [6.2 2.8 4.8 1.8]
 [6.1 3.  4.9 1.8]
 [6.4 2.8 5.6 2.1]
 [7.2 3.  5.8 1.6]
 [7.4 2.8 6.1 1.9]
 [7.9 3.8 6.4 2. ]
 [6.4 2.8 5.6 2.2]
 [6.3 2.8 5.1 1.5]
 [6.1 2.6 5.6 1.4]
 [7.7 3.  6.1 2.3]
 [6.3 3.4 5.6 2.4]
 [6.4 3.1 5.5 1.8]
 [6.  3.  4.8 1.8]
 [6.9 3.1 5.4 2.1]
 [6.7 3.1 5.6 2.4]
 [6.9 3.1 5.1 2.3]
 [5.8 2.7 5.1 1.9]
 [6.8 3.2 5.9 2.3]
 [6.7 3.3 5.7 2.5]
 [6.7 3.  5.2 2.3]
 [6.3 2.5 5.  1.9]
 [6.5 3.  5.2 2. ]
 [6.2 3.4 5.4 2.3]
 [5.9 3.  5.1 1.8]]

 target의 type: &lt;class &#39;numpy.ndarray&#39;&gt;
target의 shape: (150,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]</code></pre>
<h2 id="04-Model-Selection-모듈-소개"><a href="#04-Model-Selection-모듈-소개" class="headerlink" title="04. Model Selection 모듈 소개"></a>04. Model Selection 모듈 소개</h2><ul>
<li>사이킷런의 model_selection 모듈은 학습 데이터와 데이터 세트를 분리하거나, 교차 검증 분할 및 평가, Estimator의 하이퍼 파라미터를 튜닝하기 위한 함수와 클래스 제공</li>
</ul>
<h3 id="1-학습-테스트-데이터-세트-분리-train-test-split"><a href="#1-학습-테스트-데이터-세트-분리-train-test-split" class="headerlink" title="1. 학습/테스트 데이터 세트 분리- train_test_split()"></a>1. 학습/테스트 데이터 세트 분리- train_test_split()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">dt_clf = DecisionTreeClassifier()</span><br><span class="line">train_data = iris.data</span><br><span class="line">train_label = iris.target</span><br><span class="line">dt_clf.fit(train_data, train_label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 데이터 세트로 예측 수행</span></span><br><span class="line">pred = dt_clf.predict(train_data)</span><br><span class="line">print(<span class="string">&#x27;예측 정확도:&#x27;</span>, accuracy_score(train_label, pred))</span><br></pre></td></tr></table></figure>

<pre><code>예측 정확도: 1.0</code></pre>
<ul>
<li>정확도가 100%인 이유: 이미 학습한 학습 데이터 세트를 기반으로 예측했기 때문<ul>
<li>예측을 수행한 데이터 세트는 학습한 학습용 데이터 세트가 아닌, <strong>테스트 데이터 세트</strong>여야 함</li>
<li><strong>train_test_split()</strong> 함수로 학습 데이터/테스트 데이터 세트 분리하기</li>
</ul>
</li>
</ul>
<ul>
<li><p>파라미터 설명</p>
<ul>
<li><dl><dt><strong>test_size</strong></dt><dd>전체 데이터에서 테스트 데이터 세트 크기를 얼마로 샘플링할지 결정 (디폴트는 0.25, 즉 25%)</dd></dl></li>
<li><dl><dt><strong>train_size</strong></dt><dd>전체 데이터에서 학습용 데이터 세트 크기를 얼마로 샘플링할 것인가 결정(통상적으로 test_size를 사용하고, 해당 파라미터는 잘 사용하지 않음)</dd></dl></li>
<li><dl><dt><strong>shuffle</strong></dt><dd>데이터 분리 전, 데이터를 미리 섞을지 결정, 디폴트는 True, 데이터를 분산해서 좀 더 효율적인 학습 및 테스트 데이터 세트를 만드는 데 사용</dd></dl></li>
<li><dl><dt><strong>random_state</strong></dt><dd>random_state는 호출할 때마다 동일한 학습/테스트용 데이터 세트를 생성하기 위해 주어지는 난수 값, train_test_split()는 호출 시 무작위로 데이터를 분리하므로 random_state를 지정하지 않으면 수행할 때마다 다른 학습/테스트용 데이터를 생성 → 연습 시에는 random_state에 일정 숫자값을 주어 변하지 않도록 함</dd></dl></li>
<li><p>train_test_split()의 반환값은 튜플 형태<br>→ 학습용 데이터의 피처 데이터 세트, 테스트용 데이터의 피처 데이터 세트, 학습용 데이터의 레이블 데이터 세트, 테스트용 데이터의 레이블 데이터 세트가 순차적으로 반환</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>붓꽃 데이터 세트를 train_test_split()으로 테스트 데이터 세트를 전체의 30%, 학습 데이터 세트를 70%로 분리</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">dt_clf = DecisionTreeClassifier()</span><br><span class="line">iris_data = load_iris()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_data.data, iris_data.target, test_size=<span class="number">0.3</span>, random_state=<span class="number">121</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dt_clf.fit(X_train, y_train)</span><br><span class="line">pred = dt_clf.predict(X_test)</span><br><span class="line">print(<span class="string">&#x27;예측 정확도: &#123;0:4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, pred)))</span><br></pre></td></tr></table></figure>

<pre><code>예측 정확도: 0.955556</code></pre>
<ul>
<li>테스트 데이터로 예측을 수행한 결과 정확도가 약 95.56%<ul>
<li>붓꽃 데이터는 데이터 양(150개)이 크지 않아 전체 30%인 텟트 데이터로 알고리즘 예측 성능을 판단하기 적절하지 않음</li>
</ul>
</li>
</ul>
<h3 id="3-교차-검증"><a href="#3-교차-검증" class="headerlink" title="3. 교차 검증"></a>3. 교차 검증</h3><ul>
<li>과적합(Overfitting): 모델이 학습 데이터에만 과도하게 최적화되어, 실제 예측을 다른 데이터로 수행할 경우 예측 성능이 과도하게 떨어지는 것</li>
<li>과적합을 방지하기 위해 교차 검증을 이용해 다양한 학습과 평가를 수행</li>
</ul>
<h4 id="K-폴드-교차-검증"><a href="#K-폴드-교차-검증" class="headerlink" title="K 폴드 교차 검증"></a>K 폴드 교차 검증</h4><ul>
<li>K 폴드 교차 검증: 가장 보편적으로 사용되는 교차 검증 기법</li>
<li>K개의 데이터 폴드 세트를 만들어서 K번마늠 각 폴드 세트에 학습과 검증 평가를 반복적으로 수행하는 방법</li>
</ul>
<p><img src="data:image/png;base64,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0fRHoimEECKOksxovv766+bll182b731lhXDN954w0ybNs00adLErF+/3q7jRPPqq6+2GVDWJchgsh6ieeLEidNE08H2derUMX379jUvvPCC6datm82CPvLII+axxx6TaIqcSDT9kWj6I9H0C4mmPxJNIYQQcdSIPppI4dy5c61Arl69uvw1RJPmrx/84AfNhz/8YRv8+93vfrd573vfaz70oQ+V/z+XaJI5RUbJlnbq1MkcPXpUolkD4PurLiSa/lSGaFbnOVEdSDT94kwRzeo87yWaQggh4qgxokm/ycsvv9w2bXWvIZpXXnml2bVrl20mSxw+fNjUr1/fNqklO3no0CHzz3/+8zTRRC7PO+88K5sPPvigHfyH7fbv318ummPGjDF33323RDMHlNPIkSNN48aNbcyaNSu7pCJ8VzSHJvvMej179jT79u3LLi0O9tWnTx/TqFEju6+k+/EhTdHkHKXJNsdC32L3ICUMTcInTZpUXtacm0nZvn27bTLOfsji7927N7uk6khLNGnFsGHDBnssnBOtW7fOLjkdmt3zYIl1ebC0aNGi7JLi2bJlS/l3wTVQHXiJ5pGFZqONBTFRtk542wkLh5iGTRqY+g0vt7Hh8ILT1iHWHZhnrunYpmy9BsmiSbNGpvvAzpH79400RfOuu+4yN9xwgz0frr/+erNnz57sktPp3bt3+bnDA1Ra1CThvvvuMy1btrTnPb9vtPypaiSaQggh4ih50UQsDhw4YH+U27Zta958883y1+P6aPKjj3hGDQYECAri873vfc8OKtSgQQM7QBAVBiea73nPe8z73/9+8453vEOiGQGDMA0aNMhccskl5tJLLzVTp07NLqkI38uSJUtM8+bN7boM4ITcFwv7OXbsmBUz954ILH1uq5K0RJPjodn3NddcY4+nVatWZtmyZfb1MDwYQS7dcQ8bNiy7pDjYN2LGuc++rr32WrN169bs0qojLdHkfoCcUyYcD60eOMaoMmQEao7XrUclPwmMXj1v3jy7HwJZf/zxx7NLq46kojltxUjTqm1zc3mDegVF9wGdzdr9c8u3HzdvkKlT97Ky47/0koxozq+wfxfrMttcdU1Lu44rq2KjXv26ptsdN0Xu3zfSEk3ONbp0uGuK36mdO3dGnoO8RjcNd74yMF0S0WQ/3FN5OMp+EM7XXnstu7TqkGgKIYSI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dg4yKw9MNbsf31yrspvITzA2bNhg/u3f/s2K5ltvvXXacihENPfs2WP38//+3/+LjH/913+1EbXsG9/4hpkzZ052T4Xz6KOP2mxs3PsG49xzzzVbt261nz+faC5cuNBcffXVpnHjxrGxdu1a8+qrr9pt2K9EU+RColnrkGj6ItH0R6LpHxJNPySa/kg006EqRdPF3N1DM/cRpkLZm7kWzuypUFasWGGzfw0aNCiPP//5z1bCvv/975v69euXv96oUSMzcOBAK0uFiCbZxbFjx5oxY8ZUiH79+pk//elP5t///d/Nj370IzN69OjT1pk9e7Z56KGHsnsqnJdfftls3rz5tP3lCo7/qaeeKkg0u3btaj72sY+Zf/mXf8kZiDPNb59//nm7jURTxCHRrHVINH2RaPoj0fQPiaYfEk1/JJrpUB2iSdy5o79Zsm+82XF8o3nu1aeyn+bMY8CAAea9731vhSyfyzSGM47vfOc7zd///veCRRN4PRhst2TJEnP22Web97///ea73/2uWbRokXnppZdOW9eHZ555xkput27dzK5du8r3Sd9LZPmOO+4whw4dMpMmTTKXX365DY7t05/+tLngggvMjh07sns6xQMPPGCmT59uxo0bFxkdOnQwn/jEJ8zEiROt8ALvKdEUuZBo1jokmr5INP2RaPqHRNMPiaY/Es10qC7RdDF311Cz8cg8OxXK6yfLmkOeSTz44IO2TyNy5OKaa66xYkl2b8KECeWvI2U0C4VCRdPx5ptv2mat9In8yU9+Yr71rW+Z66+/3goYWU2a6R49ejQ1EWNgnzZt2phvfvOb5s477yzf7z333GP++Mc/mosuusjKZOvWra1MB7OSuUQzH1OnTjVf+9rXzOrVq+3xgkRTxCHRrHVINH2RaPoj0fQPiaYfEk1/JJrpUN2iSZDdZCqUbcfWmGdePp79ZGcOyI8L+mR27NjRiiZZR5qABpcTUIho8hp9FekD2b9/fytwiNiPf/xjK66I59y5c815551nvvzlL9smq6y3fft22+w2+H7F8vrrr9sBhb70pS9ZWXb7WbdunfnlL39pBwJC/O677z4zefJkK9F9+vSxGdYkosn+Eeff/OY3ttmtez/+lmiKXEg0ax0STV8kmv5INP1DoumHRNMfiWY6lIJoupi9a3DmnjzbHH52l3n1jZeyn/DMguamn//8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KJr9kH98+HZ47LV7w5aGcBpl48nwxBsbcl43Wo2HXl0ZNv9lY+57RmvxzJ8ebpTh47nvGT3Hpjcf8DyuGC+//Wx4+4M/d95dREREtqJo9kM+bfz75NOPG/GJUSkswyrxseVn7PDgGPQ4rBKfEjabFRGRHBRNERERERERqRVFU0RERERERGpF0RQREREREZFaUTRFRERERESkVhRNERERERERqRVFU0RERERERGpF0RQREREREZFaUTRFRERERESkVhRNERERERERqRVFU0RERERERGpF0RQREREREZFaUTRFRERERESkVhRNERERERERqRVFU0RERERERGpF0RQREREREZFaUTRFRERERESkVhRNERERERERqRVFU0RERERERGpF0RQREREREZFaUTT7If/9+N/hr++9Ef72/pvhrff/aJQIyo4yzHvPaC3++t7rHoMVIh2DlmH52FqG+e8bxUG5UYb/+PCtzruLiIjIVhTNfsiLf3sqnLX0gHD+XQPDxFXHGW3GhauODWNX/L8wctmBYfKak4xSMTgeg+c1jsGLG//PX8YoivErjwqjlh3c+Hl07vtGTzE4jLtrQBiz/NeN83pQzvtGTzFp1fGNa+FhYd7DEzrvLiIiIltRNPsdnzZEc1MY3aigTls/NFz36IRGXGi0HBPCvEfGh0mrB4Wxdx4W1r90W9jw0u1Gm7F2y+JwzopDw6wHx4Z7X1iUu4xRFLeFmx6/JErmoiem5rxv9BRrtyyJx99Fq04IS5+e1XjNc7nduPO568Ll604P1z8yMd5bREREsiia/Y4O0Tz3rt+GxZumhwf/sMJoM+575Y4w48Gzw8R7BjVKs+NfRyXLaDU+/uR/YcLKY8Lq5xeG/3z0r9xljO6DfxvfWBemrR8envvzI/H3vOWM/ODfR41jcNXmBVE233hnS3wtb1mj+6D5LA88Fjx+aedrIiIiW1E0+x1Z0bwiV6SM4rj/1TvCzIZoTlrVIZrSPh9/8lGYcE8SzQ87X5V22PjG+jC9UzSlfaJoPt8pmu9u6XxV2uGtDxRNERHpHkWz36FoVo2saFq5KoeiWZ0nFM1KdIjmwjBb0SyNoikiIkUomv0ORbNqKJrVUTSro2hWQ9GsjqIpIiJFKJr9DkWzaiia1VE0q6NoVkPRrI6iKSIiRSia/Q5Fs2oomtVRNKujaFZD0ayOoiki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IlKEotnvUDSrhqJZHUWzOopmNRTN6iiaIiJShKLZ71A0q4aiWR1FszqKZjUUzeoomiIiUoSi2e9QNKuGolkdRbM6imY1FM3qKJoiIlKEotnvUDSrhqJZHUWzOopmNRTN6iiaIiJShKLZ71A0q4aiWR1FszqKZjUUzeoomiIiUoSi2e9QNKuGolkdRbM6GxXNSnSI5oIwS9EsjaIpIiJFKJr9jqxoTs8VKaM47nvljjCjIZoT7xnUKM2Ofx2VLKPVoJI/YWUSzX81Xslfztg+0r+Nb6wL0zpF0/JrL/gXRXNzp2i+syW+lres0X289b6iKSIi3aNo9js6RHPUsoMbldShYd4jE4w2Y+4jF4SJqweFsSsOC+u23GqUiLVbFoezVxzaqOSfE9Y8f3PuMkZx3PjY5DB+5VHh5o2X575vFMe9L9wSZjaOv4tWHR+WPjUzdxmjOFY8Oy9MWTskXP/IxHhvERERyaJo9kNeeuvpMGbZIeGi1cc3KgmnGW3GZWtPDRfcfWQYs/zX4coNI8KV9xFnGu1Eo9xGLzs4Nj++YsPwxmuWYevRccxNXjM4Puy4ZM1Jna/lLWvkx4jGcTciXHjPsWHcXYeHy9cNia/lL2vkx4gwdd3p8WHH/Ecndd5dREREtqJo9kM+/N8H4ZW3nw2vvfN8eP3dLUa78c6W8Ie/b45lmPu+0VK83Cg/ypHyzHvfKA7O31fefs7zuEJw/L3aKMPX33kh932jh2iUG2X4l/de67y7iIiIbEXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRWFE0RERERERGpFUVTREREREREakXRFBERERERkVpRNEVERERERKRGQvj/riUYSEP8Q8QAAAAASUVORK5CYII=" alt="4.PNG"></p>
<ul>
<li>사이킷런에서는 K 폴드 교차 검증 프로세스를 구현하기 위해 KFold와 StratifiedKFold 클래스를 제공</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">features = iris.data</span><br><span class="line">label = iris.target</span><br><span class="line">df_clf = DecisionTreeClassifier(random_state=<span class="number">156</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5개의 폴드 세트로 분리하는 KFold 객체와 폴드 세트별 정확도를 담을 리스트 객체 생성</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">5</span>)</span><br><span class="line">cv_accuracy = []</span><br><span class="line">print(<span class="string">&#x27;붓꽃 데이터 세트 크기:&#x27;</span>, features.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<pre><code>붓꽃 데이터 세트 크기: 150</code></pre>
<ul>
<li>KFold(n_splits=5)로 KFold 객체를 생성했으니 생성된 KFold 객체의 split()을 호출해 전체 붓꽃 데이터를 5개의 폴드 데이터 세트로 분리<ul>
<li>학습용 데이터 세트는 120개</li>
<li>검증 테스트 데이터 세트는 30개</li>
</ul>
</li>
<li>KFold 객체는 split()을 호출하면 학습용/검증용 데이터로 분할할 수 있는 인덱스를 반환</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n_iter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># KFold 객체의 split()를 호출하면 폴드별 학습용, 검증용 테스트의 로우 인덱스를 array로 반환</span></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kfold.split(features):</span><br><span class="line">    <span class="comment"># KFold.split()으로 반환된 인덱스로 학습용, 검증용 테스트 데이터 추출</span></span><br><span class="line">    X_train, X_test = features[train_index], features[test_index]</span><br><span class="line">    y_train, y_test = label[train_index], label[test_index]</span><br><span class="line">    <span class="comment"># 학습 및 예측</span></span><br><span class="line">    dt_clf.fit(X_train, y_train)</span><br><span class="line">    pred = dt_clf.predict(X_test)</span><br><span class="line">    n_iter += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 반복 시마다 정확도 측정</span></span><br><span class="line">    accuracy = np.<span class="built_in">round</span>(accuracy_score(y_test, pred), <span class="number">4</span>)</span><br><span class="line">    train_size = X_train.shape[<span class="number">0</span>]</span><br><span class="line">    test_size = X_test.shape[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">&#x27;\n#&#123;0&#125; 교차 검증 정확도: &#123;1&#125;, 학습 데이터 크기: &#123;2&#125;, 검증 데이터 크기: &#123;3&#125;&#x27;</span></span><br><span class="line">         .<span class="built_in">format</span>(n_iter, accuracy, train_size, test_size))</span><br><span class="line">    print(<span class="string">&#x27;#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)&#x27;</span>)</span><br><span class="line">    cv_accuracy.append(accuracy)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 개별 iteration별 정확도를 합하여 평균 정확도 계산</span></span><br><span class="line">print(<span class="string">&#x27;\n## 평균 검증 정확도:&#x27;</span>, np.mean(cv_accuracy))</span><br></pre></td></tr></table></figure>


<pre><code>#1 교차 검증 정확도: 1.0, 학습 데이터 크기: 120, 검증 데이터 크기: 30
#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)

#2 교차 검증 정확도: 1.0, 학습 데이터 크기: 120, 검증 데이터 크기: 30
#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)

#3 교차 검증 정확도: 0.8333, 학습 데이터 크기: 120, 검증 데이터 크기: 30
#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)

#4 교차 검증 정확도: 0.9333, 학습 데이터 크기: 120, 검증 데이터 크기: 30
#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)

#5 교차 검증 정확도: 0.8333, 학습 데이터 크기: 120, 검증 데이터 크기: 30
#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;.format(n_iter, test_index)

## 평균 검증 정확도: 0.91998</code></pre>
<h4 id="Stratified-K-폴드"><a href="#Stratified-K-폴드" class="headerlink" title="Stratified K 폴드"></a>Stratified K 폴드</h4><ul>
<li>Stratified K 폴드: 불균형한 분포도를 가진 레이블 데이터 집합을 위한 K 폴드 방식</li>
<li>불균형한 분포도: 특정 레이블 값이 특이하게 많거나 매우 적어서 값의 분포가 한쪽으로 치우치는 것</li>
<li>e.g) 대출 사기 데이터처럼 대출 사기 1값이 매우 적고, 대부분 데이터가 정상 대출 0인 경우</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">iris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)</span><br><span class="line">iris_df[<span class="string">&#x27;label&#x27;</span>]=iris.target</span><br><span class="line">iris_df[<span class="string">&#x27;label&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>




<pre><code>2    50
1    50
0    50
Name: label, dtype: int64</code></pre>
<ul>
<li>레이블 값은 0, 1, 2 값 모두 50개로 동일</li>
<li>Setosa, Versicolor, Virginica 품종 모두 50개</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 분할 파라미터 설정 = 3개</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 교차 검증 횟수를 세기 위한 변수</span></span><br><span class="line">n_iter=<span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 반복문을 통해 교차 검증 수행</span></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kfold.split(iris_df):</span><br><span class="line">    n_iter += <span class="number">1</span></span><br><span class="line">    label_train= iris_df[<span class="string">&#x27;label&#x27;</span>].iloc[train_index]</span><br><span class="line">    label_test= iris_df[<span class="string">&#x27;label&#x27;</span>].iloc[test_index]</span><br><span class="line">    print(<span class="string">&#x27;## 교차 검증: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(n_iter))</span><br><span class="line">    print(<span class="string">&#x27;학습 레이블 데이터 분포:\n&#x27;</span>, label_train)</span><br></pre></td></tr></table></figure>

<pre><code>## 교차 검증: 1
학습 레이블 데이터 분포:
 50     1
51     1
52     1
53     1
54     1
      ..
145    2
146    2
147    2
148    2
149    2
Name: label, Length: 100, dtype: int32
## 교차 검증: 2
학습 레이블 데이터 분포:
 0      0
1      0
2      0
3      0
4      0
      ..
145    2
146    2
147    2
148    2
149    2
Name: label, Length: 100, dtype: int32
## 교차 검증: 3
학습 레이블 데이터 분포:
 0     0
1     0
2     0
3     0
4     0
     ..
95    1
96    1
97    1
98    1
99    1
Name: label, Length: 100, dtype: int32</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"></span><br><span class="line">skf = StratifiedKFold(n_splits=<span class="number">3</span>)</span><br><span class="line">n_iter=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skf.split(iris_df, iris_df[<span class="string">&#x27;label&#x27;</span>]):</span><br><span class="line">    n_iter += <span class="number">1</span></span><br><span class="line">    label_train= iris_df[<span class="string">&#x27;label&#x27;</span>].iloc[train_index]</span><br><span class="line">    label_test= iris_df[<span class="string">&#x27;label&#x27;</span>].iloc[test_index]</span><br><span class="line">    print(<span class="string">&#x27;## 교차 검증: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(n_iter))</span><br><span class="line">    print(<span class="string">&#x27;학습 레이블 데이터 분포:\n&#x27;</span>, label_train.value_counts())</span><br><span class="line">    print(<span class="string">&#x27;검증 레이블 데이터 분포:\n&#x27;</span>, label_test.value_counts())</span><br></pre></td></tr></table></figure>

<pre><code>## 교차 검증: 1
학습 레이블 데이터 분포:
 2    34
1    33
0    33
Name: label, dtype: int64
검증 레이블 데이터 분포:
 1    17
0    17
2    16
Name: label, dtype: int64
## 교차 검증: 2
학습 레이블 데이터 분포:
 1    34
2    33
0    33
Name: label, dtype: int64
검증 레이블 데이터 분포:
 2    17
0    17
1    16
Name: label, dtype: int64
## 교차 검증: 3
학습 레이블 데이터 분포:
 0    34
2    33
1    33
Name: label, dtype: int64
검증 레이블 데이터 분포:
 2    17
1    17
0    16
Name: label, dtype: int64</code></pre>
<ul>
<li>출력 결과<ul>
<li>학습 레이블과 검증 레이블 데이터값 분포도가 동일하게 할당</li>
<li>첫 번째 교차 검증: 학습 레이블은 0, 1, 2 값이 각각 33개 → 레이블별로 동일하게 할당</li>
<li>검증 레이블: 0, 1, 2 값이 각각 17개 → 레이블별로 동일하게 할당</li>
<li>→ 위와 같이 분할되어야 레이블값 모두 학습 가능하며, 이에 기반해 검증할 수 있음</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dt_clf = DecisionTreeClassifier(random_state=<span class="number">156</span>)</span><br><span class="line"></span><br><span class="line">skfold = StratifiedKFold(n_splits=<span class="number">3</span>)</span><br><span class="line">n_iter=<span class="number">0</span></span><br><span class="line">cv_accuracy=[]</span><br><span class="line"></span><br><span class="line"><span class="comment"># StratifiedKFold의 split() 호출 시, 반드시 레이블 데이터 세트도 추가 입력 필요</span></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skfold.split(features, label):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># split()으로 반환된 인덱스를 이용해 학습용, 검증용 테스트 데이터 추출</span></span><br><span class="line">    X_train, X_test = features[train_index], features[test_index]</span><br><span class="line">    y_train, y_test = label[train_index], label[test_index]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 학습 및 예측</span></span><br><span class="line">    dt_clf.fit(X_train, y_train)</span><br><span class="line">    pred = dt_clf.predict(X_test)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 반복 시마다 정확도 측정</span></span><br><span class="line">    n_iter += <span class="number">1</span></span><br><span class="line">    accuracy = np.<span class="built_in">round</span>(accuracy_score(y_test, pred), <span class="number">4</span>)</span><br><span class="line">    train_size = X_train.shape[<span class="number">0</span>]</span><br><span class="line">    test_size = X_test.shape[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">&#x27;\n#&#123;0&#125; 교차 검증 정확도 :&#123;1&#125;, 학습 데이터 크기: &#123;2&#125;, 검증 데이터 크기: &#123;3&#125;&#x27;</span></span><br><span class="line">         .<span class="built_in">format</span>(n_iter, accuracy, train_size, test_size))</span><br><span class="line">    print(<span class="string">&#x27;#&#123;0&#125; 검증 세트 인덱스: &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(n_iter, test_index))</span><br><span class="line">    cv_accuracy.append(accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 교차 검증별 정확도 및 평균 정확도 계산</span></span><br><span class="line">print(<span class="string">&#x27;\n## 교차 검증별 정확도:&#x27;</span>, np.<span class="built_in">round</span>(cv_accuracy, <span class="number">4</span>))</span><br><span class="line">print(<span class="string">&#x27;## 평균 검증 정확도:&#x27;</span>, np.mean(cv_accuracy))</span><br></pre></td></tr></table></figure>


<pre><code>#1 교차 검증 정확도 :0.98, 학습 데이터 크기: 100, 검증 데이터 크기: 50
#1 검증 세트 인덱스: [  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  50
  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66 100 101
 102 103 104 105 106 107 108 109 110 111 112 113 114 115]

#2 교차 검증 정확도 :0.94, 학습 데이터 크기: 100, 검증 데이터 크기: 50
#2 검증 세트 인덱스: [ 17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  67
  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82 116 117 118
 119 120 121 122 123 124 125 126 127 128 129 130 131 132]

#3 교차 검증 정확도 :0.98, 학습 데이터 크기: 100, 검증 데이터 크기: 50
#3 검증 세트 인덱스: [ 34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  83  84
  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 133 134 135
 136 137 138 139 140 141 142 143 144 145 146 147 148 149]

## 교차 검증별 정확도: [0.98 0.94 0.98]
## 평균 검증 정확도: 0.9666666666666667</code></pre>
<ul>
<li>3개의 Stratified K 폴드로 교차 검증한 결과: 평균 검증 정확도가 약 96.04%로 측정</li>
<li>Stratified K 폴드의 경우, 원본 데이터의 레이블 분포도 특성을 반영한 학습/검증 데이터 세트를 만들 수 있으므로 왜곡된 레이블 데이터 세트에서는 반드시 Stratified K 폴드를 이용해 교차 검증해야 함<ul>
<li>분류(Classification)의 교차 검증은 K 폴드 대신, Stratified K 폴드로 분할되어야 함</li>
<li>회귀(Regression)에서는 Stratified K 폴드가 지원되지 않음 ← 회귀 결정값은 이산값 형태 레이블이 아니라 연속된 숫자값이므로 결정값별로 분포를 정하는 의미가 없음</li>
</ul>
</li>
</ul>
<h4 id="교차-검증을-보다-간편하게-cross-val-score"><a href="#교차-검증을-보다-간편하게-cross-val-score" class="headerlink" title="교차 검증을 보다 간편하게 - cross_val_score( )"></a>교차 검증을 보다 간편하게 - cross_val_score( )</h4><ul>
<li>사이킷런은 교차 검증을 좀 더 편리하게 수행할 수 있게 해주는 API를 제공<ul>
<li>대표적인 API: cross_val_score()</li>
<li>KFold로 데이터를 학습하고 예측하는 코드를 보면 ① 폴드 세트를 설정하고 ② for 루프에서 반복으로 학습 및 테스트 데이터의 인덱스를 추출한 뒤 ③ 반복적으로 학습과 예측을 수행하고 예측 성능을 반환</li>
</ul>
</li>
</ul>
<ul>
<li><p>cross_val_score( )는 위 과정을 한 번에 수행해주는 API</p>
</li>
<li><p>cross_val_score( ) API의 선언 형태</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cross_val_score(estimator, X, y=<span class="literal">None</span>, scoring=<span class="literal">None</span>, cv=<span class="literal">None</span>, n_jobs=<span class="number">1</span>, verbose=<span class="number">0</span>, fit_params=<span class="literal">None</span>, pre_dispatch=<span class="string">&#x27;2*n_jobs&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>주요 파라미터</p>
<ul>
<li><strong>esmitator</strong> :  사이킷런의 분류 알고리즘 클래스인 Classifier 또는 회귀 알고리즘 클래스인 Regressor를 의미</li>
<li><strong>X</strong> : 피처 데이터 세트</li>
<li><strong>y</strong> : 레이블 데이터 세트</li>
<li><strong>scoring</strong> : 예측 성능 평가 지표를 기술</li>
<li><strong>cv</strong> : 교차 검증 폴드 수</li>
</ul>
</li>
</ul>
<ul>
<li>cross_val_score( ) 수행 후 반환 값은 scoring 파라미터로 지정된 성능 지표 측정값을 배열 형태로 반환</li>
<li>cross_val_score( )는 classifier가 입력되면 Stratified K 폴드 방식으로 레이블값의 분포에 따라 학습/테스트 세트를 분할</li>
<li>cf) 회귀인 경우에는 Stratified K 폴드 방식으로 분할할 수 없으므로 K 폴드 방식으로 분할</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier </span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score , cross_validate </span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris </span><br><span class="line"></span><br><span class="line">iris_data = load_iris() </span><br><span class="line">dt_clf = DecisionTreeClassifier(random_state=<span class="number">156</span>) </span><br><span class="line"></span><br><span class="line">data = iris_data.data </span><br><span class="line">label = iris_data.target </span><br><span class="line"></span><br><span class="line"><span class="comment"># 성능 지표는 정확도(accuracy) , 교차 검증 세트 는 3개 </span></span><br><span class="line">scores = cross_val_score(dt_clf , data , label , scoring=<span class="string">&#x27;accuracy&#x27;</span>,cv=<span class="number">3</span>) </span><br><span class="line">print(<span class="string">&#x27;교차 검증별 정확도:&#x27;</span>,np.<span class="built_in">round</span>(scores, <span class="number">4</span>)) </span><br><span class="line">print(<span class="string">&#x27;평균 검증 정확도:&#x27;</span>, np.<span class="built_in">round</span>(np.mean(scores), <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<pre><code>교차 검증별 정확도: [0.98 0.94 0.98]
평균 검증 정확도: 0.9667</code></pre>
<ul>
<li><p>cross_val_score( )는 cv로 지정된 횟수만큼 scoring 파라미터로 지정된 평가 지표로 평가 결괏값을 배열로 반환, 일반적으로 이를 평균해 평가 수치로 사용</p>
</li>
<li><p>cross_val_score( ) API는 내부에서 Estimator를 학습(fit), 예측(predict), 평가(evaluation)시켜주므로 간단하게 교차 검증을 수행할 수 있음</p>
</li>
<li><p>cross_val_score( )와 앞 예제의 StratifiedKFold의 수행 결과를 비교해 보면 각 교차 검증별 정확도와 평균 검증 정확도가 모두 동일 → cross_val_score( )가 내부적으로 StratifiedKFold를 이용하기 때문</p>
</li>
</ul>
<h3 id="4-GridSearchCV-교차-검증과-최적-하이퍼-파라미터-튜닝을-한-번에"><a href="#4-GridSearchCV-교차-검증과-최적-하이퍼-파라미터-튜닝을-한-번에" class="headerlink" title="4. GridSearchCV - 교차 검증과 최적 하이퍼 파라미터 튜닝을 한 번에"></a>4. GridSearchCV - 교차 검증과 최적 하이퍼 파라미터 튜닝을 한 번에</h3><ul>
<li>사이킷런은 GridSearchCV API를 이용해 Classifier나 Regressor와 같은 알고리즘에 사용되는 하이퍼 파라미터를 순차적으로 입력하면서 편리하게 최적의 파라미터를 도출할 수 있는 방안을 제공(Grid는 격자라는 뜻으로, 촘촘하게 파라미터를 입력하면서 테스트를 하는 방식)</li>
</ul>
<ul>
<li>e.g) 결정 트리 알고리즘의 여러 하이퍼 파라미터를 순차적으로 변경하면서 최고 성능을 가지는 파라미터 조합을 찾고자 한다면 다음과 같이 파라미터의 집합을 만들고 이를 순차적으로 적용하면서 최적화를 수행하면 됨  </li>
</ul>
<ul>
<li>cf) 데이터 핸들링 - 피처 엔지니어링, ML 모형 핸들링 - 하이퍼 파라미터 튜닝</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid_parameters = &#123;<span class="string">&#x27;max_depth&#x27;</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   <span class="string">&#x27;min_samples_split&#x27;</span>:[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>6회에 걸쳐 파라미터를 순차적으로 바꿔 실행하면서 최적의 파라미터와 수행 결과를 도출</li>
</ul>
<table>
<thead>
<tr>
<th>순번</th>
<th>max_depth</th>
<th>min_samples_split</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>3</td>
</tr>
</tbody></table>
<ul>
<li><strong>GridSearchCV</strong>: 사용자가 튜닝하고자 하는 여러 종류의 하이퍼 파라미터를 다양하게 테스트하면서 최적의 파라미터를 편리하게 찾게 해주지만 동시에 순차적으로 파라미터를 테스트하므로 수행시간이 상대적으로 오래 걸림<ul>
<li>이 경우, 순차적으로 6회에 걸쳐 하이퍼 파라미터를 변경하면서 교차 검증 데이터 세트에 수행 성능을 측정</li>
<li>CV가 3회라면 개별 파라미터 조합마다 3개의 폴딩 세트를 3회에 걸쳐 학습/평가해 평균값으로 성능을 측정</li>
<li>6개의 파라미터 조합이라면 총 CV 3회 * 6개 파라미터 조합 = 18회의 학습/평가가 이뤄짐</li>
</ul>
</li>
</ul>
<ul>
<li>GridSearchCV 클래스의 생성자로 들어가는 주요 파라미터<ul>
<li><strong>estimator</strong> : classifier, regressor, pipeline이 사용될 수 있다.  </li>
<li><strong>param_grid</strong> : key + 리스트 값을 가지는 딕셔너리가 주어짐, estimator의 튜닝을 위해 파라미터명과 사용될 여러 파라미터 값을 지정</li>
<li><strong>scoring</strong> : 예측 성능을 측정할 평가 방법을 지정, 보통은 사이킷런의 성능 평가 지표를 지정하는 문자열(예 : 정확도의 경우 ‘accuracy’)로 지정하나 별도의 성능 평가 지표 함수도 지정 가능</li>
<li><strong>cv</strong> : 교차 검증을 위해 분할되는 학습 / 테스트 세트의 갯수를 지정</li>
<li><strong>refit</strong> : 디폴트가 True이며 True로 생성 시 가장 최적의 하이퍼 파라미터를 찾은 뒤 입력된 esitmator 객체를 해당 하이퍼 파라미터로 재학습시킴</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 데이터를 로딩하고 학습 데이터와 테스트 데이터 분리</span></span><br><span class="line">iris_data = load_iris()</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_data.data, iris_data.target,</span><br><span class="line">                                                   test_size=<span class="number">0.2</span>, random_state=<span class="number">121</span>)</span><br><span class="line">dtree = DecisionTreeClassifier()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 파라미터를 딕셔너리 형태로 설정</span></span><br><span class="line">parameters = &#123;<span class="string">&#x27;max_depth&#x27;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">&#x27;min_samples_split&#x27;</span>: [<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>학습 데이터 세트를 GridSearchCV 객체의 fit(학습 데이터 세트) 메서드에 인자로 입력<ul>
<li>GridSearchCV 객체의 fit 메서드를 수행하면 학습 데이터를 cv에 기술된 폴딩 세트로 분할해 param_grid에 기술된 하이퍼 파라미터를 순차적으로 변경하면서 학습/평가를 수행하고 결과를 cv_results_(gridsearchcv의 결과 세트, 딕셔너리 형태로 key값과 리스트 형태의 value값을 가짐) 속성에 기록</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># param_grid의 하이퍼 파라미터를 3개의 train, test set fold로 나누어 테스트 수행 설정</span></span><br><span class="line"><span class="comment">## refit=True가 default, True인 경우 가장 좋은 파라미터 설정으로 재학습시킴</span></span><br><span class="line">grid_dtree = GridSearchCV(dtree, param_grid=parameters, cv=<span class="number">3</span>, refit=<span class="literal">True</span>, return_train_score=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 붓꽃 학습 데이터로 param_grid의 하이퍼 파라미터를 순차적으로 학습/평가</span></span><br><span class="line">grid_dtree.fit(X_train, y_train) </span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV 결과를 추출해 DataFrame으로 변환</span></span><br><span class="line">scores_df = pd.DataFrame(grid_dtree.cv_results_) </span><br><span class="line">scores_df[[<span class="string">&#x27;params&#x27;</span>, <span class="string">&#x27;mean_test_score&#x27;</span>, <span class="string">&#x27;rank_test_score&#x27;</span>, </span><br><span class="line">           <span class="string">&#x27;split0_test_score&#x27;</span>, <span class="string">&#x27;split1_test_score&#x27;</span>, <span class="string">&#x27;split2_test_score&#x27;</span>]]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>params</th>
      <th>mean_test_score</th>
      <th>rank_test_score</th>
      <th>split0_test_score</th>
      <th>split1_test_score</th>
      <th>split2_test_score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>{'max_depth': 1, 'min_samples_split': 2}</td>
      <td>0.700000</td>
      <td>5</td>
      <td>0.700</td>
      <td>0.7</td>
      <td>0.70</td>
    </tr>
    <tr>
      <th>1</th>
      <td>{'max_depth': 1, 'min_samples_split': 3}</td>
      <td>0.700000</td>
      <td>5</td>
      <td>0.700</td>
      <td>0.7</td>
      <td>0.70</td>
    </tr>
    <tr>
      <th>2</th>
      <td>{'max_depth': 2, 'min_samples_split': 2}</td>
      <td>0.958333</td>
      <td>3</td>
      <td>0.925</td>
      <td>1.0</td>
      <td>0.95</td>
    </tr>
    <tr>
      <th>3</th>
      <td>{'max_depth': 2, 'min_samples_split': 3}</td>
      <td>0.958333</td>
      <td>3</td>
      <td>0.925</td>
      <td>1.0</td>
      <td>0.95</td>
    </tr>
    <tr>
      <th>4</th>
      <td>{'max_depth': 3, 'min_samples_split': 2}</td>
      <td>0.975000</td>
      <td>1</td>
      <td>0.975</td>
      <td>1.0</td>
      <td>0.95</td>
    </tr>
    <tr>
      <th>5</th>
      <td>{'max_depth': 3, 'min_samples_split': 3}</td>
      <td>0.975000</td>
      <td>1</td>
      <td>0.975</td>
      <td>1.0</td>
      <td>0.95</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>총 6개의 결과를 볼 수 있으며, 하이퍼 파라미터 max_depth와 min_samples_split을 순차적으로 6번 변경하면서 학습 및 평가를 수행했음을 나타냄<ul>
<li>맨 마지막에서 두 번째 행을 보면, 평가 결과 예측 성능이 1위라는 의미</li>
<li>split0_test_score, split1_test_score, split2_test_score는 CV가 3인 경우, 즉 3개의 폴딩 세트에서 각각 테스트한 성능 수치</li>
<li>mean_test_score는 이 세 개 성능 수치를 평균화한 것</li>
</ul>
</li>
</ul>
<ul>
<li>GridSearchCV 객체의 fit()을 수행하면, 최고 성능을 나타낸 하이퍼 파라미터 값과 그때의 평가 결괏값이 best_params, best_score_ 속성에 기록</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;GridSearchCV 최적 파라미터:&#x27;</span>, grid_dtree.best_params_)</span><br><span class="line">print(<span class="string">&#x27;GridSearchCV 최고 정확도: &#123;0:4f&#125;&#x27;</span>.<span class="built_in">format</span>(grid_dtree.best_score_))</span><br></pre></td></tr></table></figure>

<pre><code>GridSearchCV 최적 파라미터: &#123;&#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 2&#125;
GridSearchCV 최고 정확도: 0.975000</code></pre>
<ul>
<li>GridSearchCV 객체의 생성 파라미터로 refit=True가 default<ul>
<li>refit = True면 GridSearchCV가 최적 성능을 나타내는 하이퍼 파라미터로 Estimator를 학습해 best_estimator_로 저장</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GridSearchCV refit으로 이미 학습된 estimator 반환</span></span><br><span class="line">estimator = grid_dtree.best_estimator_</span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV의 best_estimator_는 이미 최적 하이퍼 파라미터로 학습됨</span></span><br><span class="line">pred = estimator.predict(X_test)</span><br><span class="line">print(<span class="string">&#x27;테스트 데이터 세트 정확도: &#123;0:4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, pred)))</span><br></pre></td></tr></table></figure>

<pre><code>테스트 데이터 세트 정확도: 0.966667</code></pre>
<h2 id="05-데이터-전처리"><a href="#05-데이터-전처리" class="headerlink" title="05. 데이터 전처리"></a>05. 데이터 전처리</h2><ul>
<li>사이킷런 ML 알고리즘 적용 전, 알아야 할 사항<ul>
<li>결손값(NaN, Null 값은 허용되지 않음) → 고정된 다른 값으로 변환해야 함</li>
<li>Null 값이 얼마 되지 않으면 피처의 평균값 등으로 간단히 대체 가능</li>
<li>단, Null 값이 대부분이라면 해당 피처를 드롭하는 편이 좋음</li>
</ul>
</li>
</ul>
<ul>
<li>사이킷런 머신러닝 알고리즘은 문자열 값을 입력 값으로 허용하지 않음<ul>
<li>모든 문자열 값은 인코딩하여 숫자형으로 변환해야 함</li>
<li>문자열 피처: 카테고리형 피처, 텍스트형 피처</li>
</ul>
</li>
</ul>
<h3 id="1-데이터-인코딩"><a href="#1-데이터-인코딩" class="headerlink" title="1. 데이터 인코딩"></a>1. 데이터 인코딩</h3><ul>
<li><strong>레이블 인코딩(Label encoding)</strong><ul>
<li>카테고리 피처를 코드형 숫자 값으로 변환하는 것</li>
<li>01, 02(문자형)이 아닌 1, 2와 같은 숫자형 값으로 변환해야 함  </li>
</ul>
</li>
</ul>
<ul>
<li>사이킷런의 레이블 인코딩은 LabelEncoder 클래스로 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">items=[<span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;냉장고&#x27;</span>, <span class="string">&#x27;전자레인지&#x27;</span>, <span class="string">&#x27;컴퓨터&#x27;</span>, <span class="string">&#x27;선풍기&#x27;</span>, <span class="string">&#x27;선풍기&#x27;</span>, <span class="string">&#x27;믹서&#x27;</span>, <span class="string">&#x27;믹서&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># LabelEncoder를 객체로 생성한 후, fit()과 transform()으로 레이블 인코딩 수행</span></span><br><span class="line">encoder = LabelEncoder() </span><br><span class="line">encoder.fit(items) </span><br><span class="line">labels = encoder.transform(items) </span><br><span class="line">print(<span class="string">&#x27;인코딩 변환값:&#x27;</span>,labels)</span><br></pre></td></tr></table></figure>

<pre><code>인코딩 변환값: [0 1 4 5 3 3 2 2]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 문자열 값이 어떤 숫자 값으로 인코딩됐는지 알고 싶을 경우</span></span><br><span class="line">print(<span class="string">&#x27;인코딩 클래스:&#x27;</span>,encoder.classes_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인코딩된 값을 디코딩하기</span></span><br><span class="line">print(<span class="string">&#x27;디코딩 원본 값:&#x27;</span>,encoder.inverse_transform([<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure>

<pre><code>인코딩 클래스: [&#39;TV&#39; &#39;냉장고&#39; &#39;믹서&#39; &#39;선풍기&#39; &#39;전자레인지&#39; &#39;컴퓨터&#39;]
디코딩 원본 값: [&#39;전자레인지&#39; &#39;컴퓨터&#39; &#39;믹서&#39; &#39;TV&#39; &#39;냉장고&#39; &#39;냉장고&#39; &#39;선풍기&#39; &#39;선풍기&#39;]</code></pre>
<ul>
<li><p>데이터 인코딩 단점</p>
<ul>
<li>숫자 값으로 변환되어 몇몇 ML 알고리즘에서 크고 작음의 특성이 반영될 수 있음</li>
</ul>
</li>
<li><p><strong>원-핫 인코딩(One-Hot Encoding)</strong></p>
<ul>
<li><p>피처 값 유형에 따라 새로운 피처를 추가하여, 고유값에 해당하는 칼럼에만 1을 표시하고 나머지 칼럼에는 0을 표시하는 방식</p>
</li>
<li><p>사이킷런에서 OneHotEncoder 클래스로 쉽게 변환 가능</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>주의할 점<ol>
<li>OneHotEncoder로 변환하기 전에 모든 문자열 값이 숫자형 값으로 변환되어야 함</li>
<li>입력값으로 2차원 데이터가 필요하다는 점</li>
</ol>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://wikidocs.net/22647">참고: 딥 러닝을 이용한 자연어 처리 입문</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">items=[<span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;냉장고&#x27;</span>,<span class="string">&#x27;전자렌지&#x27;</span>,<span class="string">&#x27;컴퓨터&#x27;</span>,<span class="string">&#x27;선풍기&#x27;</span>,<span class="string">&#x27;선풍기&#x27;</span>,<span class="string">&#x27;믹서&#x27;</span>,<span class="string">&#x27;믹서&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 숫자값 변환을 위해 LabelEncoder로 변환</span></span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">encoder.fit(items)</span><br><span class="line">labels = encoder.transform(items)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2차원 데이터로 변환</span></span><br><span class="line">labels = labels.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 원-핫 인코딩 적용</span></span><br><span class="line">oh_encoder = OneHotEncoder()</span><br><span class="line">oh_encoder.fit(labels)</span><br><span class="line">oh_labels = oh_encoder.transform(labels)</span><br><span class="line">print(<span class="string">&#x27;원-핫 인코딩 데이터&#x27;</span>)</span><br><span class="line">print(oh_labels.toarray())</span><br><span class="line">print(<span class="string">&#x27;원-핫 인코딩 데이터 차원&#x27;</span>)</span><br><span class="line">print(oh_labels.shape)</span><br></pre></td></tr></table></figure>

<pre><code>원-핫 인코딩 데이터
[[1. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 1.]
 [0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0. 0.]
 [0. 0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0.]]
원-핫 인코딩 데이터 차원
(8, 6)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_dummies()를 이용하면 바로 변환 가능</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;item&#x27;</span>:[<span class="string">&#x27;TV&#x27;</span>, <span class="string">&#x27;냉장고&#x27;</span>,<span class="string">&#x27;전자렌지&#x27;</span>,<span class="string">&#x27;컴퓨터&#x27;</span>,<span class="string">&#x27;선풍기&#x27;</span>,<span class="string">&#x27;선풍기&#x27;</span>,<span class="string">&#x27;믹서&#x27;</span>,<span class="string">&#x27;믹서&#x27;</span>]&#125;) </span><br><span class="line">pd.get_dummies(df)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>item_TV</th>
      <th>item_냉장고</th>
      <th>item_믹서</th>
      <th>item_선풍기</th>
      <th>item_전자렌지</th>
      <th>item_컴퓨터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="2-피처-스케일링과-정규화"><a href="#2-피처-스케일링과-정규화" class="headerlink" title="2. 피처 스케일링과 정규화"></a>2. 피처 스케일링과 정규화</h3><ul>
<li><p>피처 스케일링(feature scaling)</p>
<ul>
<li>서로 다른 변수값 범위를 일정한 수준으로 맞추는 작업</li>
<li>표준화(Standardization)와 정규화(Normalization)가 있음  </li>
</ul>
</li>
<li><p>표준화</p>
<ul>
<li>데이터 피처 각각 평균이 0이고 분산이 1인 가우시안 정규 분포를 가진 값으로 변환</li>
<li>x<del>i</del>_new = $\frac{x<del>i</del> - mean(x)}{stdev(x)}$</li>
</ul>
</li>
<li><p>정규화</p>
<ul>
<li><p>서로 다른 피처 크기를 통일하기 위해 크기 변환</p>
</li>
<li><p>x<del>i</del>_new = $\frac{x<del>i</del> - min(x)}{max(x) - min(x)}$</p>
</li>
<li><p>사이킷런 전처리에서 제공하는 Normalizer 모듈과 일반적인 정규화는 약간의 차이가 있음</p>
<ul>
<li>선형대수에서의 정규화 개념이 적용, 개별 백터 크기를 맞추기 위해 변환</li>
<li>x<del>i</del>_new = $\frac{x<del>i</del>}{x<del>i</del>^2^ + y<del>i</del>^2^ + z<del>i</del>^2^}$ (분모 루트, 아래 사진 참고)</li>
</ul>
<p><img src="data:image/png;base64,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" alt="10.PNG"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-StandardScaler"><a href="#3-StandardScaler" class="headerlink" title="3. StandardScaler"></a>3. StandardScaler</h3><ul>
<li>표준화를 쉽게 지원하기 위한 클래스</li>
<li>개별 피처를 평균이 0이고 분산이 1인 값으로 변환해줌<ul>
<li>사이킷런에서 구현한 RBF 커널을 이용하는 서포트 백터 머신, 선형 회귀, 로지스틱 회귀는 가우시안 분포를 가지고 있다는 가정 하에 구현됐기 때문에 사전에 표준화를 적용하는 것이 예측 성능 향상에 중요한 요소가 됨</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 붓꽃 데이터 세트를 로딩하고 DataFrame으로 변환</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">iris_data = iris.data</span><br><span class="line">iris_df = pd.DataFrame(data=iris_data, columns=iris.feature_names)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;feature들의 평균값&#x27;</span>)</span><br><span class="line">print(iris_df.mean())</span><br><span class="line">print(<span class="string">&#x27;\nfeature들의 분산값&#x27;</span>)</span><br><span class="line">print(iris_df.var())</span><br></pre></td></tr></table></figure>

<pre><code>feature들의 평균값
sepal length (cm)    5.843333
sepal width (cm)     3.057333
petal length (cm)    3.758000
petal width (cm)     1.199333
dtype: float64

feature들의 분산값
sepal length (cm)    0.685694
sepal width (cm)     0.189979
petal length (cm)    3.116278
petal width (cm)     0.581006
dtype: float64</code></pre>
<ul>
<li>StandardScaler를 이용해 각 피처를 한 번에 표준화해 변환</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># StandardScaler 객체 생성</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># StandardScaler로 데이터 세트 변환, fit()과 transform() 호출</span></span><br><span class="line">scaler.fit(iris_df)</span><br><span class="line">iris_scaled = scaler.transform(iris_df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform() 시, 스케일 변환된 데이터 세트가 Numpy ndarray로 반환되 이를 DataFrame으로 변환</span></span><br><span class="line">iris_df_scaled = pd.DataFrame(data=iris_scaled, columns=iris.feature_names)</span><br><span class="line">print(<span class="string">&#x27;feature들의 평균값&#x27;</span>)</span><br><span class="line">print(iris_df_scaled.mean())</span><br><span class="line">print(<span class="string">&#x27;\nfeature들의 분산값&#x27;</span>)</span><br><span class="line">print(iris_df_scaled.var())</span><br></pre></td></tr></table></figure>

<pre><code>feature들의 평균값
sepal length (cm)   -1.690315e-15
sepal width (cm)    -1.842970e-15
petal length (cm)   -1.698641e-15
petal width (cm)    -1.409243e-15
dtype: float64

feature들의 분산값
sepal length (cm)    1.006711
sepal width (cm)     1.006711
petal length (cm)    1.006711
petal width (cm)     1.006711
dtype: float64</code></pre>
<ul>
<li>모든 칼럼 값 평균이 0에 아주 가까운 값으로, 분산은 1에 아주 가까운 값으로 변환됨을 확인할 수 있음</li>
</ul>
<h3 id="3-MinMaxScaler"><a href="#3-MinMaxScaler" class="headerlink" title="3. MinMaxScaler"></a>3. MinMaxScaler</h3><ul>
<li>MinMaxScaler<ul>
<li>데이터값을 0과 1 사이 범위 값으로 변환</li>
<li>음수 값이 있으면 -1에서 1값으로 변환</li>
<li>데이터 분포가 가우시안 분포가 아닐 경우에는 Min, Max Scale 적용 가능</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="comment"># MinMaxScaler 객체 생성</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># MinMaxScaler로 데이터 세트 변환, fit()과 transform()호출</span></span><br><span class="line">scaler.fit(iris_df)</span><br><span class="line">iris_scaled=scaler.transform(iris_df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform() 시 스케일 변환된 데이터 세트가 NumPy ndarry로 변환돼 이를 DataFrame으로 변환</span></span><br><span class="line">iris_df_scaled=pd.DataFrame(data=iris_scaled, columns=iris.feature_names)</span><br><span class="line">print(<span class="string">&#x27;feature 최솟값&#x27;</span>)</span><br><span class="line">print(iris_df_scaled.<span class="built_in">min</span>())</span><br><span class="line">print(<span class="string">&#x27;\nfeature 최댓값&#x27;</span>)</span><br><span class="line">print(iris_df_scaled.<span class="built_in">max</span>())</span><br></pre></td></tr></table></figure>

<pre><code>feature 최솟값
sepal length (cm)    0.0
sepal width (cm)     0.0
petal length (cm)    0.0
petal width (cm)     0.0
dtype: float64

feature 최댓값
sepal length (cm)    1.0
sepal width (cm)     1.0
petal length (cm)    1.0
petal width (cm)     1.0
dtype: float64</code></pre>
<h3 id="4-학습-데이터와-테스트-데이터의-스케일링-변환-시-유의점"><a href="#4-학습-데이터와-테스트-데이터의-스케일링-변환-시-유의점" class="headerlink" title="4. 학습 데이터와 테스트 데이터의 스케일링 변환 시 유의점"></a>4. 학습 데이터와 테스트 데이터의 스케일링 변환 시 유의점</h3><ul>
<li>StandardScaler나 MinMaxScaler와 같은 Scaler 객체로 데이터 스케일링 변환 시, fit(), transform(), fit_transform() 메소드를 이용<ul>
<li>fit(): 데이터 변환을 위한 기준 정보 설정(최댓값, 최솟값 등)</li>
<li>transform(): 설정된 정보를 이용해 데이터 변환</li>
<li>fir_transform(): fit()과 transform()을 한 번에 적용하는 기능</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 테스트 데이터에 fit()을 적용할 때 발생하는 문제 알아보기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 데이터는 0부터 10까지, 테스트 데이터는 0부터 5까지 값을 가지는 데이터 세트로 생성</span></span><br><span class="line"><span class="comment"># Scaler 클래스의 fit(), transform()은 2차원 이상 데이터만 가능하므로 reshape(-1, 1)로 차원 변경</span></span><br><span class="line">train_array = np.arange(<span class="number">0</span>,<span class="number">11</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">test_array = np.arange(<span class="number">0</span>,<span class="number">6</span>).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 학습 데이터인 train_array부터 MinMaxScaler를 이용해 변환</span></span><br><span class="line"><span class="comment">## MinMaxScaler 객체에 별도 feature_range 파라미터 값을 지정하지 않으면 0~1 값으로 변환</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment">## fit()하면 train_array 데이터의 최솟값이 0, 최댓값이 10으로 설정됨</span></span><br><span class="line">scaler.fit(train_array)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1/10 scale로 train_arrau 데이터 변환, 원본 10 → 1로 변환</span></span><br><span class="line">train_scaled = scaler.transform(train_array)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;원본 train_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(train_array.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&#x27;Scale된 train_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(train_scaled.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트 데이터 세트를 변환: fit()을 호출해 스케일링 기준 정보를 적용한 뒤, transform()을 수행한 결과 확인</span></span><br><span class="line"><span class="comment">## MinMaxScaler에 test_array를 fit()하게 되면 원본 데이터 최솟값이 0, 최댓값이 5로 설정</span></span><br><span class="line">scaler.fit(test_array)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1/5 scale로 test_array 데이터 변환. 원본 5 → 1로 변환</span></span><br><span class="line">test_scaled = scaler.transform(test_array)</span><br><span class="line"></span><br><span class="line"><span class="comment">## test_array의 scale 변환 출력</span></span><br><span class="line">print(<span class="string">&#x27;\n원본 test_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(test_array.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&#x27;Scale된 test_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(test_scaled.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>원본 train_array 데이터: [ 0  1  2  3  4  5  6  7  8  9 10]
Scale된 train_array 데이터: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]

원본 test_array 데이터: [0 1 2 3 4 5]
Scale된 test_array 데이터: [0.  0.2 0.4 0.6 0.8 1. ]</code></pre>
<ul>
<li>출력 결과를 확인하면 학습 데이터와 테스트 데이터 스케일링이 맞지 않음을 알 수 있음<ul>
<li>학습 데이터와 테스트 데이터의 서로 다른 원본값이 동일한 값으로 변환되는 결과 초래  </li>
</ul>
</li>
</ul>
<ul>
<li>머신러닝 모델은 학습 데이터를 기반으로 학습됨<ul>
<li>테스트 데이터는 학습 데이터의 스케일링 기준에 따라야 하며, 테스트 데이터의 1값은 학습 데이터와 동일하게 0.1값으로 변환되어야 함</li>
<li>따라서, 테스트 데이터에 다시 fit()을 적용해서는 안 되며, 학습 데이터로 이미 fit()이 적용된 Scaler 객체를 이용해 transform()으로 변환해야 함</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 재시도: 테스트 데이터에 fit() 호출하지 않음</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">scaler.fit(train_array)</span><br><span class="line">train_scaled = scaler.transform(train_array)</span><br><span class="line">print(<span class="string">&#x27;원본 train_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(train_array.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&#x27;Scale된 train_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(train_scaled.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># test_array에 Scale 변환할 때는 반드시 fit() 호출하지 않고 transform()만으로 변환</span></span><br><span class="line">test_scaled = scaler.transform(test_array)</span><br><span class="line">print(<span class="string">&#x27;\n원본 test_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(test_array.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br><span class="line">print(<span class="string">&#x27;Scale된 test_array 데이터:&#x27;</span>, np.<span class="built_in">round</span>(test_scaled.reshape(<span class="number">-1</span>),<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<pre><code>원본 train_array 데이터: [ 0  1  2  3  4  5  6  7  8  9 10]
Scale된 train_array 데이터: [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]

원본 test_array 데이터: [0 1 2 3 4 5]
Scale된 test_array 데이터: [0.  0.1 0.2 0.3 0.4 0.5]</code></pre>
<h3 id="06-사이킷런으로-타이타닉-생존자-예측하기"><a href="#06-사이킷런으로-타이타닉-생존자-예측하기" class="headerlink" title="06. 사이킷런으로 타이타닉 생존자 예측하기"></a>06. 사이킷런으로 타이타닉 생존자 예측하기</h3><ul>
<li>타이타닉 탑승자 데이터<ul>
<li>Passengerid : 탑승자 번호</li>
<li>survived : 생존 여부 0 : 사망 / 1 : 생존</li>
<li>pclass : 티켓의 선실 등급</li>
<li>sex : 성별</li>
<li>name :이름</li>
<li>Age : 나이</li>
<li>sibsp : 같이 탑승한 형제자매 또는 배우자 인원수</li>
<li>parch : 같이 탑승한 부모님 또는 어린이 인원수</li>
<li>ticket : 티켓 번호</li>
<li>fare : 요금</li>
<li>cabin : 선실 번호</li>
<li>embarked : 중간 정착 항구 C = Cherbourg, Q = Queenstown, S = Southampton</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">titanic_df = pd.read_csv(<span class="string">&#x27;./titanic_train.csv&#x27;</span>)</span><br><span class="line">titanic_df.head(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>NaN</td>
      <td>S</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;\n ### 학습 데이터 정보 ### \n&#x27;</span>)</span><br><span class="line">print(titanic_df.info())</span><br></pre></td></tr></table></figure>


<pre><code> ### 학습 데이터 정보 ### 

&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 891 entries, 0 to 890
Data columns (total 12 columns):
 #   Column       Non-Null Count  Dtype  
---  ------       --------------  -----  
 0   PassengerId  891 non-null    int64  
 1   Survived     891 non-null    int64  
 2   Pclass       891 non-null    int64  
 3   Name         891 non-null    object 
 4   Sex          891 non-null    object 
 5   Age          714 non-null    float64
 6   SibSp        891 non-null    int64  
 7   Parch        891 non-null    int64  
 8   Ticket       891 non-null    object 
 9   Fare         891 non-null    float64
 10  Cabin        204 non-null    object 
 11  Embarked     889 non-null    object 
dtypes: float64(2), int64(5), object(5)
memory usage: 83.7+ KB
None</code></pre>
<ul>
<li>데이터 확인<ul>
<li>Range Index: DataFrame 인덱스의 범위, 891개의 로우로 구성</li>
<li>Column: 열 12개(object는 string 타입으로 보아도 무방)</li>
</ul>
</li>
</ul>
<ul>
<li>사이킷런 머신러닝 알고리즘은 Null 값을 허용하지 않으므로, Null값 처리가 필요<ul>
<li>DataFrame의 fillna() 함수로 Null 값을 평균 또는 고정값으로 변경</li>
<li>Age는 평균 나이, 나머지 칼럼은 ‘N’값으로 변경</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">titanic_df[<span class="string">&#x27;Age&#x27;</span>].fillna(titanic_df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">titanic_df[<span class="string">&#x27;Cabin&#x27;</span>].fillna(<span class="string">&#x27;N&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">titanic_df[<span class="string">&#x27;Embarked&#x27;</span>].fillna(<span class="string">&#x27;N&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">&#x27;데이터 세트 Null 값 개수:&#x27;</span>, titanic_df.isnull().<span class="built_in">sum</span>().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<pre><code>데이터 세트 Null 값 개수: 0</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 남은 문자열 피처 값 분류 살펴보기</span></span><br><span class="line">print(<span class="string">&#x27;Sex 값 분포:\n&#x27;</span>, titanic_df[<span class="string">&#x27;Sex&#x27;</span>].value_counts())</span><br><span class="line">print(<span class="string">&#x27;\nCabin 값 분포 :\n&#x27;</span>, titanic_df[<span class="string">&#x27;Cabin&#x27;</span>].value_counts())</span><br><span class="line">print(<span class="string">&#x27;\nEmbarked 값 분포 :\n&#x27;</span>, titanic_df[<span class="string">&#x27;Embarked&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure>

<pre><code>Sex 값 분포:
 male      577
female    314
Name: Sex, dtype: int64

Cabin 값 분포 :
 G6             4
B96 B98        4
C23 C25 C27    4
E101           3
F2             3
              ..
C32            1
C90            1
D49            1
B73            1
C46            1
Name: Cabin, Length: 147, dtype: int64

Embarked 값 분포 :
 S    644
C    168
Q     77
Name: Embarked, dtype: int64</code></pre>
<ul>
<li>결과 해석<ul>
<li>Cabin(선실): Ndl 687건으로 가장 많은 것과 속성값이 정리되지 않은 것으로 확인<ul>
<li>e.g) 여러 Cabin이 한 번에 표기된 값이 4건이나 됨</li>
<li>Cabin의 경우 선실 번호 중, 선실 등급을 나타내는 첫 번째 알파벳이 중요해 보임</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cabin 속성 앞 문자만 추출하기</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Cabin&#x27;</span>] = titanic_df[<span class="string">&#x27;Cabin&#x27;</span>].<span class="built_in">str</span>[:<span class="number">1</span>]</span><br><span class="line">print(titanic_df[<span class="string">&#x27;Cabin&#x27;</span>].head(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<pre><code>0    N
1    C
2    N
Name: Cabin, dtype: object</code></pre>
<ol>
<li>Women and Children First 시절로 성별에 따른 생존 비율 비교</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic_df.groupby([<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>])[<span class="string">&#x27;Survived&#x27;</span>].count()</span><br></pre></td></tr></table></figure>




<pre><code>Sex     Survived
female  0            81
        1           233
male    0           468
        1           109
Name: Survived, dtype: int64</code></pre>
<ul>
<li>Survived 칼럼: 레이블로서 결정 클래스 값(0: 사망, 1: 생존)<ul>
<li>여성 314명 중, 233명(약 74.2%) 생존</li>
<li>남성 577명 중, 109명(약 18.8%) 생존</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Seaborn 패키지를 이용하여 성별 생존 비율 비교하기</span></span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Sex&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, data=titanic_df)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x188fdd03610&gt;</code></pre>
<p><img src="../images/machine_learning/ch02/output_84_1.png" alt="png"></p>
<ol start="2">
<li>부자와 가난한 사람 생존 확률 확인<ul>
<li>객실 등급으로 부를 추출해보기</li>
<li>성별도 추가</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 객실 등급별 생존 확률 확인하기</span></span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Pclass&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>, hue=<span class="string">&#x27;Sex&#x27;</span>, data=titanic_df)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x188fe470130&gt;</code></pre>
<p><img src="../images/machine_learning/ch02/output_86_1.png" alt="png"></p>
<ul>
<li>결과 해석<ul>
<li>여성의 경우, 일/이등실에 따른 생존 확률 차이는 적으나, 삼등실의 경우 생존 확률이 상대적으로 많이 떨어짐</li>
<li>남성의 경우, 일등실 생존 확률이 이/삼등실 생존 확률보다 월등히 높음</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Age에 따른 생존 확률 알아보기<ul>
<li>0 - 5: Baby</li>
<li>6 - 12: Child</li>
<li>13 - 18: Teenager</li>
<li>19 - 25: Student</li>
<li>26 - 35: Young Adult</li>
<li>36 - 60: Adult</li>
<li>61 - : Elderly</li>
<li>~ -1: Unknown (오류값)</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 입력 age에 따라 구분값을 반환하는 함수 설정</span></span><br><span class="line"><span class="comment"># DataFrame의 apply lambda 식에 사용</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_category</span>(<span class="params">age</span>):</span></span><br><span class="line">    cat = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> age &lt;= <span class="number">-1</span>: cat = <span class="string">&#x27;Unknown&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">5</span>: cat = <span class="string">&#x27;Baby&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">12</span>: cat = <span class="string">&#x27;Child&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">18</span>: cat = <span class="string">&#x27;Teenager&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">25</span>: cat = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">35</span>: cat = <span class="string">&#x27;Young Adult&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt;= <span class="number">60</span>: cat = <span class="string">&#x27;Adult&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>: cat = <span class="string">&#x27;Elderly&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 막대그래프 크기 figure를 더 크게 설정</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># X축의 값을 순차적으로 표시하기 위한 설정</span></span><br><span class="line">group_names= [<span class="string">&#x27;Unknown&#x27;</span>, <span class="string">&#x27;Baby&#x27;</span>, <span class="string">&#x27;Child&#x27;</span>, <span class="string">&#x27;Teenager&#x27;</span>, <span class="string">&#x27;Student&#x27;</span>, <span class="string">&#x27;Young Adult&#x27;</span>, <span class="string">&#x27;Adult&#x27;</span>, <span class="string">&#x27;Elderly&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda 식에 위에서 생성한 get_category() 함수를 반환값으로 지정</span></span><br><span class="line">titanic_df[<span class="string">&#x27;Age_cat&#x27;</span>] =titanic_df[<span class="string">&#x27;Age&#x27;</span>].apply(<span class="keyword">lambda</span> x : get_category(x))</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Age_cat&#x27;</span>, y=<span class="string">&#x27;Survived&#x27;</span>,hue =<span class="string">&#x27;Sex&#x27;</span>, data=titanic_df,order=group_names)</span><br><span class="line">titanic_df.drop(<span class="string">&#x27;Age_cat&#x27;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<p><img src="../images/machine_learning/ch02/output_89_0.png" alt="png"></p>
<ul>
<li><p>결과 해석</p>
<ul>
<li>여자 baby의 경우 비교적 생존 확률 높음</li>
<li>여자 child는 다른 연령대에 비해 생존 확률 낮음</li>
<li>여자 elderly의 경우 생존 확률이 매우 높음</li>
</ul>
</li>
<li><p>남은 문자열 카테고리 피처를 숫자형 카테고리 피처로 변환</p>
<ul>
<li>인코딩: 사이킷런의 LabelEncoder 클래스를 이용하여 레이블 인코딩 적용</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 여러 칼럼을 encode_features() 함수를 생성해 한 번에 변환하기</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_features</span>(<span class="params">dataDF</span>):</span></span><br><span class="line">    features = [<span class="string">&#x27;Cabin&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Embarked&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">        le = preprocessing.LabelEncoder()</span><br><span class="line">        le = le.fit(dataDF[feature])</span><br><span class="line">        dataDF[feature] = le.transform(dataDF[feature])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dataDF</span><br><span class="line"></span><br><span class="line">titanic_df = encode_features(titanic_df)</span><br><span class="line">titanic_df.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>PassengerId</th>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>1</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.2500</td>
      <td>7</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
      <td>0</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>0</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.9250</td>
      <td>7</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
      <td>0</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>113803</td>
      <td>53.1000</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>0</td>
      <td>3</td>
      <td>Allen, Mr. William Henry</td>
      <td>1</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>373450</td>
      <td>8.0500</td>
      <td>7</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>Sex, Cabin, Embarked 속성이 숫자형으로 바뀜</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Null 처리 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillna</span>(<span class="params">df</span>):</span></span><br><span class="line">    df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(),inplace = <span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&#x27;Cabin&#x27;</span>].fillna(<span class="string">&#x27;N&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&#x27;Embarked&#x27;</span>].fillna(<span class="string">&#x27;N&#x27;</span>, inplace = <span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&#x27;Fare&#x27;</span>].fillna(<span class="number">0</span>,inplace = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment">#머신러닝 알고리즘에 불필요한 속성 제거</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_features</span>(<span class="params">df</span>):</span></span><br><span class="line">    df.drop([<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Ticket&#x27;</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment">#레이블 인코딩 수행</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_features</span>(<span class="params">df</span>):</span></span><br><span class="line">    df[<span class="string">&#x27;Cabin&#x27;</span>] = df[<span class="string">&#x27;Cabin&#x27;</span>].<span class="built_in">str</span>[:<span class="number">1</span>]</span><br><span class="line">    features = [<span class="string">&#x27;Cabin&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> features:</span><br><span class="line">        le = LabelEncoder()</span><br><span class="line">        le = le.fit(df[feature])</span><br><span class="line">        df[feature] = le.transform(df[feature])</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 앞에서 설정한 데이터 전처리 함수 호출</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform_features</span>(<span class="params">df</span>):</span></span><br><span class="line">    df = fillna(df)</span><br><span class="line">    df = drop_features(df)</span><br><span class="line">    df= format_features(df)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure>

<ul>
<li>원본 데이터 가공 위해 원본 csv 파일 재로딩<ul>
<li>Survived 속성만 별로도 분리해 클래스 결정값 데이터 세트로 만들기</li>
<li>Survived 속성을 드롭해 피처 데이터 세트 만들기</li>
<li>생성된 데이터 세트에 transform_features()를 적용해 데이터 가공</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#원본 데이터 재로딩하고, 피처 데이터 세트와 레이블 데이터 세트 추출.</span></span><br><span class="line">titanic_df = pd.read_csv(<span class="string">&quot;./titanic_train.csv&quot;</span>)</span><br><span class="line">y_titanic_df=titanic_df[<span class="string">&#x27;Survived&#x27;</span>]</span><br><span class="line">X_titanic_df=titanic_df.drop(<span class="string">&#x27;Survived&#x27;</span>,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X_titanic_df = transform_features(X_titanic_df)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># train_test_split() API를 이용해 별도의 테스트 데이터 세트 추출, 세트 크기는 전체의 20% 설정</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test=train_test_split(X_titanic_df, y_titanic_df,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>, random_state=<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ML 알고리즘 결정 트리, 랜덤 포레스트, 로지스틱 회귀로 타이타닉 생존자 예측하기</p>
<ul>
<li>결정 트리: DecisionTreeClassifier 클래스</li>
<li>랜덤 포레스트: RandomForestClassifier 클래스</li>
<li>로지스틱 회귀: LogisticRegression 클래스 제공</li>
</ul>
</li>
<li><p>사이킷런 클래스를 이용해 train_test_split()으로 분리한 학습 데이터와 테스트 데이터를 기반으로 머신러닝 모델을 학습하고(fit) 예측할 것(predict)</p>
<ul>
<li>예측 성능 평가 기준: 정확도 → accuracy_score() API 사용</li>
<li>random_state=11의 숫자는 예제 수행 시마다 같은 결과를 출력하기 위한 용도</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment">#결정트리, Random Forest, 로지스틱 회귀를 위한 사이킷런 Classifier 클래스 생성</span></span><br><span class="line">dt_clf = DecisionTreeClassifier(random_state=<span class="number">11</span>)</span><br><span class="line">rf_clf = RandomForestClassifier(random_state=<span class="number">11</span>)</span><br><span class="line">lr_clf = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment">#DecisionTreeClassifier 학습/예측/평가</span></span><br><span class="line">dt_clf.fit(X_train, y_train)</span><br><span class="line">dt_pred = dt_clf.predict(X_test)</span><br><span class="line">print(<span class="string">&#x27;DecisionTreeClassifier 정확도: &#123;0:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, dt_pred)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#RandomForestClassifier 학습/예측/평가</span></span><br><span class="line">rf_clf.fit(X_train, y_train)</span><br><span class="line">rf_pred = rf_clf.predict(X_test)</span><br><span class="line">print(<span class="string">&#x27;RandomForestClassifier 정확도:&#123;0:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, rf_pred)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># LogisticRegression 학습/예측/평가</span></span><br><span class="line">lr_clf.fit(X_train, y_train)</span><br><span class="line">lr_pred = lr_clf.predict(X_test)</span><br><span class="line">print(<span class="string">&#x27;LogisticRegression 정확도: &#123;0:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy_score(y_test, lr_pred)))</span><br></pre></td></tr></table></figure>

<pre><code>DecisionTreeClassifier 정확도: 0.7877
RandomForestClassifier 정확도:0.8547
LogisticRegression 정확도: 0.8492</code></pre>
<ul>
<li>최적화 작업을 수행하지 않았고, 데이터 양도 충분하지 않아 어떤 알고리즘이 가장 성능이 좋은지 평가할 수 없음<ul>
<li>교차 검증을 위해 KFold 클래스(폴드 개수 5개로 설정), cross_val_score, GridSearchCV 클래스 모두 사용</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_kfold</span>(<span class="params">clf, folds=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="comment"># 폴드 세트를 5개인 KFold객체를 생성, 폴드 수만큼 예측결과 저장을 위한  리스트 객체 생성.</span></span><br><span class="line">    kfold = KFold(n_splits=folds)</span><br><span class="line">    scores = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># KFold 교차 검증 수행. </span></span><br><span class="line">    <span class="keyword">for</span> iter_count , (train_index, test_index) <span class="keyword">in</span> <span class="built_in">enumerate</span>(kfold.split(X_titanic_df)):</span><br><span class="line">        <span class="comment"># X_titanic_df 데이터에서 교차 검증별로 학습과 검증 데이터를 가리키는 index 생성</span></span><br><span class="line">        X_train, X_test = X_titanic_df.values[train_index], X_titanic_df.values[test_index]</span><br><span class="line">        y_train, y_test = y_titanic_df.values[train_index], y_titanic_df.values[test_index]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Classifier 학습, 예측, 정확도 계산 </span></span><br><span class="line">        clf.fit(X_train, y_train) </span><br><span class="line">        predictions = clf.predict(X_test)</span><br><span class="line">        accuracy = accuracy_score(y_test, predictions)</span><br><span class="line">        scores.append(accuracy)</span><br><span class="line">        print(<span class="string">&quot;교차 검증 &#123;0&#125; 정확도: &#123;1:.4f&#125;&quot;</span>.<span class="built_in">format</span>(iter_count, accuracy))     </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5개 fold에서의 평균 정확도 계산. </span></span><br><span class="line">    mean_score = np.mean(scores)</span><br><span class="line">    print(<span class="string">&quot;평균 정확도: &#123;0:.4f&#125;&quot;</span>.<span class="built_in">format</span>(mean_score)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># exec_kfold 호출</span></span><br><span class="line">exec_kfold(dt_clf , folds=<span class="number">5</span>) </span><br></pre></td></tr></table></figure>

<pre><code>교차 검증 0 정확도: 0.7542
교차 검증 1 정확도: 0.7809
교차 검증 2 정확도: 0.7865
교차 검증 3 정확도: 0.7697
교차 검증 4 정확도: 0.8202
평균 정확도: 0.7823</code></pre>
<ul>
<li><p>평균 정확도: 약 78.23%  </p>
</li>
<li><p>cross_val_score() API로 교차 검증 수행</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">scores = cross_val_score(dt_clf, X_titanic_df , y_titanic_df , cv=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> iter_count,accuracy <span class="keyword">in</span> <span class="built_in">enumerate</span>(scores):</span><br><span class="line">    print(<span class="string">&quot;교차 검증 &#123;0&#125; 정확도: &#123;1:.4f&#125;&quot;</span>.<span class="built_in">format</span>(iter_count, accuracy))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;평균 정확도: &#123;0:.4f&#125;&quot;</span>.<span class="built_in">format</span>(np.mean(scores)))</span><br></pre></td></tr></table></figure>

<pre><code>교차 검증 0 정확도: 0.7430
교차 검증 1 정확도: 0.7753
교차 검증 2 정확도: 0.7921
교차 검증 3 정확도: 0.7865
교차 검증 4 정확도: 0.8427
평균 정확도: 0.7879</code></pre>
<ul>
<li>KFold와 평균 정확도가 다른 이유: cross_val_score가 stratifiedKFold를 이용해 폴드 세트를 분할하기 때문  </li>
</ul>
<p><strong>-</strong> GridSearchCV를 이용해 DecisionTreeClassifier의 최적 하이퍼 파라미터를 찾고 예측 성능 측정하기</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">parameters = &#123;<span class="string">&#x27;max_depth&#x27;</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>],</span><br><span class="line">             <span class="string">&#x27;min_samples_split&#x27;</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="string">&#x27;min_samples_leaf&#x27;</span>:[<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>]&#125;</span><br><span class="line"></span><br><span class="line">grid_dclf = GridSearchCV(dt_clf , param_grid=parameters , scoring=<span class="string">&#x27;accuracy&#x27;</span> , cv=<span class="number">5</span>)</span><br><span class="line">grid_dclf.fit(X_train , y_train)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;GridSearchCV 최적 하이퍼 파라미터 :&#x27;</span>,grid_dclf.best_params_)</span><br><span class="line">print(<span class="string">&#x27;GridSearchCV 최고 정확도: &#123;0:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(grid_dclf.best_score_))</span><br><span class="line">best_dclf = grid_dclf.best_estimator_</span><br><span class="line"></span><br><span class="line"><span class="comment"># GridSearchCV의 최적 하이퍼 파라미터로 학습된 Estimator로 예측 및 평가 수행. </span></span><br><span class="line">dpredictions = best_dclf.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test , dpredictions)</span><br><span class="line">print(<span class="string">&#x27;테스트 세트에서의 DecisionTreeClassifier 정확도 : &#123;0:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(accuracy))</span><br></pre></td></tr></table></figure>

<pre><code>GridSearchCV 최적 하이퍼 파라미터 : &#123;&#39;max_depth&#39;: 3, &#39;min_samples_leaf&#39;: 5, &#39;min_samples_split&#39;: 2&#125;
GridSearchCV 최고 정확도: 0.7992
테스트 세트에서의 DecisionTreeClassifier 정확도 : 0.8715</code></pre>
<ul>
<li>하이퍼 파라미터인 max_depth=3, min_samples_leaf=1, min_samples_split=2로 DecisionTreeClassifier를 학습시킨 뒤 예측 정확도가 약 87.15%로 향상<br>→ 테스트용 데이터 세트가 작기 때문에 수치상으로 예측 성능이 많이 증가한 것으로 보임</li>
</ul>
<h3 id="07-정리"><a href="#07-정리" class="headerlink" title="07. 정리"></a>07. 정리</h3><ul>
<li><strong>사이킷런</strong><ul>
<li>많은 머신러닝 알고리즘 제공</li>
<li>쉽고 직관적인 API 프레임워크</li>
<li>편리하고 다양한 모듈 지원</li>
</ul>
</li>
</ul>
<ul>
<li><strong>머신러닝 애플리케이션</strong><ul>
<li>데이터의 가공 및 변환 과정의 처리</li>
<li>데이터를 학습 대이타와 테스트 데이터로 분리하는 데이터 시트 분리 작업</li>
<li>학습 데이터를 기반으로 머신러닝 알고리즘을 적용해 모델 학습</li>
<li>학습된 모델을 기반으로 테스트 데이터에 대한 예측 수행</li>
<li>예측된 결과값을 실제 결과값과 비교해 머신러닝 모델에 대한 평가 수행</li>
</ul>
</li>
</ul>
<ul>
<li><strong>데이터 전처리 작업</strong><ul>
<li>오류 데이터의 보정이나 결손(Null) 처리 등의 다양한 데이터 클렌징 작업</li>
<li>레이블 인코딩이나 원-핫 인코딩 같은 인코딩 작업</li>
<li>데이터의 스케일링/정규화 작업 등으로 머신러닝 알고리즘이 최적으로 수행되도록 사전에 데이터 처리</li>
</ul>
</li>
</ul>
<ul>
<li><strong>추가</strong><ul>
<li>머신러닝 모델은 학습 데이터 세트로 학습한 뒤 반드시 별도의 테스트 데이터 세트로 평가해야 함</li>
<li>테스트 데이터의 건수 부족이나 고정된 테스트 데이터 세트를 이용한 반복적인 모델의 학습과 평가는 해당 테스트 데이터 세트에만 치우치는 빈약한 머신러닝 모델을 만들 가능성이 높음</li>
<li>해결 방안<ul>
<li>학습 데이터 세트를 학습 데이터와 검증 데이터로 구성된 여러 개의 폴드 세트로 분리해 교차검증 수행 (교차검증은 데이터셋이 적을 때, 많으면 시간이 너무 오래 걸림)</li>
<li>사이킷런은 교차 검증을 지원하기 위해 KFord, StratifiedKFold, cross_val_score 등의 다양한 클레스 함수를 제공</li>
<li>머신러닝 모델의 최적의 하이퍼 파라미터를 교차 검증을 통해 추출하기 위해 GridSearchCV를 제공</li>
</ul>
</li>
</ul>
</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/29/ch02_%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0%EC%9C%BC%EB%A1%9C_%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94_%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/" data-id="ckjqkgbb4003twkue2q0cc7vq" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kaggle-titanic/" rel="tag">Kaggle titanic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Titanic/" rel="tag">Titanic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0/" rel="tag">사이킷런</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/" rel="tag">파이썬머신러닝</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/" rel="tag">파이썬머신러닝완벽가이드</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ADsP/Part03_데이터_분석_2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/17/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_2/">ADsP 자격증: Part03. 데이터 분석_2</a>
    </h1>
  

        <a href="/2020/11/17/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_2/" class="article-date">
  <time datetime="2020-11-16T15:00:00.000Z" itemprop="datePublished">2020-11-17</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>해당 자료는 <a target="_blank" rel="noopener" href="http://www.dataedu.kr/product/adsp-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D-%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80-2020-%EC%99%84%EC%A0%84%EA%B0%9C%EC%A0%95%ED%8C%90/">ADsP 데이터분석 준전문가 2020 완전 개정판</a> 요약본으로 저작권은 DATA EDU에 있습니다.</li>
</ul>
<h1 id="4장-통계-분석"><a href="#4장-통계-분석" class="headerlink" title="4장. 통계 분석"></a>4장. 통계 분석</h1><h2 id="1절-통계분석의-이해"><a href="#1절-통계분석의-이해" class="headerlink" title="1절. 통계분석의 이해"></a>1절. 통계분석의 이해</h2><h3 id="1-통계"><a href="#1-통계" class="headerlink" title="1. 통계"></a>1. 통계</h3><ul>
<li>특정집단을 대상으로 수행한 조사 / 실험 결과의 요약된 형태</li>
<li>조사 대상에 따라 총조사(census)와 표본조사로 구분</li>
</ul>
<h3 id="2-통계자료의-획득-방법"><a href="#2-통계자료의-획득-방법" class="headerlink" title="2. 통계자료의 획득 방법"></a>2. 통계자료의 획득 방법</h3><ul>
<li><p><strong>총 조사(전수 조사, census)</strong></p>
<ul>
<li>대상 집단 모두를 조사하면 많은 비용과 시간이 소요되므로 특별한 경우를 제외하고는 사용되지 않음</li>
</ul>
</li>
<li><p><strong>표본조사</strong></p>
<ul>
<li>모집단에서 샘플을 추출하여 진행하는 조사</li>
<li><strong>모집단(population)</strong>: 조사하고자 하는 대상 집단 전체</li>
<li><strong>원소(element)</strong>: 모집단을 구성하는 개체</li>
<li><strong>표본(sample)</strong>: 조사하기 위해 추출한 모집단의 일부 원소</li>
<li><strong>모수(parameter)</strong>: 표본 관측에 의해 구하고자 하는 모집단에 대한 정보</li>
<li>모집단의 정의, 표본 크기, 조사 방법, 조사 기간, 표본 추출 방법을 정확히 명시해야 함</li>
</ul>
</li>
<li><p>표본 추출 방법</p>
<ol>
<li><p><strong>단순 랜덤 추출법(simple random sampling)</strong></p>
<ul>
<li>각 샘플에 번호를 부여해 임의의 n개를 추출하는 방법</li>
<li>각 샘플이 선택될 확률은 동일(비복원, 복원(추출 element를 다시 집어넣음) 추출)</li>
</ul>
</li>
<li><p><strong>계통추출법(systematic sampling)</strong></p>
<ul>
<li>단순랜덤추출법의 변형된 방식</li>
<li>임의 위치에서 매 k번째 행목을 추출하는 방법</li>
<li>번호를 부여한 샘플을 나열하여 K개씩 (K = N/n) n개의 구간으로 나누고 첫 구간(1, 2, …, K)에서 하나를 임의로 선택한 후 K개씩 띄어서 n개의 표본을 선택</li>
</ul>
</li>
<li><p><strong>집락추출법(cluster random sampling)</strong></p>
<ul>
<li>군집을 구분하고 군집별로 단순랜덤 추출법을 수행한 후, 모든 자료를 활용하거나 샘플링 하는 방법</li>
<li>지역 표본 추출, 다단계 표본 추출</li>
</ul>
</li>
<li><p><strong>층화추출법(stratified random sampling)</strong></p>
<ul>
<li>이질적인 원소들로 구성된 모집단에서 각 계층을 대표할 수 있도록 표본을 추출하는 방법</li>
<li>유사한 원소끼리 몇 개의 층(stratum)으로 나누어 각 층에서 랜덤 추출하는 방법</li>
<li>비례층화추출법, 불비례층화추출법</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>측정(measurement)</strong></p>
<ul>
<li><p>측정</p>
<ul>
<li>표본조사나 실험 과정에서 추출된 원소들이나 실험 단위로부터 주어진 목적에 적합하도록 관측하여 자료를 얻는 것</li>
</ul>
</li>
<li><p>측정 방법</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>명목척도</td>
<td>측정 대상이 어느 집단에 속하는지 분류할 때 사용 (성별, 출생지 구분)</td>
</tr>
<tr>
<td>순서척도</td>
<td>측정 대상의 서열관계를 관측하는 척도 (만족도, 선호도, 학년, 신용등급)</td>
</tr>
<tr>
<td>구간척도(등간척도)</td>
<td>측정 대상이 갖는 속성의 양을 측정, 구간이나 구간 사이 간격에 의미 있는 자료 (온도, 지수) +,- 가능 *,/ 불가능</td>
</tr>
<tr>
<td>비율척도</td>
<td>간격(차이) 비율이 의미를 가지는 자료, 절대적 기준인 0이 존재하고 사칙연산 가능, 제일 많은 정보를 가지는 척도 (무게, 나이, 시간, 거리)</td>
</tr>
</tbody></table>
<ul>
<li>질적 척도: 명목척도, 순서척도 → 범주형 자료, 숫자 크기 차이가 계산되지 않는 척도</li>
<li>양적 척도: 구간척도, 비율척도 → 수치형 자료, 숫자 크기 차이를 계산할 수 있는 척도</li>
</ul>
</li>
</ul>
<h3 id="3-통계분석"><a href="#3-통계분석" class="headerlink" title="3. 통계분석"></a>3. 통계분석</h3><ul>
<li><p>통계분석</p>
<ul>
<li>특정한 집단이나 불확실한 현상을 대상으로, 자료를 수집해 대상 집단 정보를 구하고 통계분석 방법을 이용하여 의사결정 하는 과정</li>
</ul>
</li>
<li><p><strong>기술통계(descriptive statistic)</strong></p>
<ul>
<li>주어진 자료로부터 어떠한 판단이나 예측과 같은 주관이 섞일 수 있는 과정을 배제하여 통계집단의 특성을 수량화하여 객관적인 데이터로 나타내는 통계분석 방법론</li>
<li>sample에 대한 특성인 평균, 표준편차, 중위수, 최빈값, 그래프, 왜도, 첨도 등을 구하는 것</li>
</ul>
</li>
<li><p><strong>통계적 추론(추측통계, inference statistics)</strong></p>
<ul>
<li>수집된 자료를 이용해 대상 집단(모집단)에 관한 의사결정을 하는 것</li>
<li>sample을 통해 모집단을 추정</li>
</ul>
<ol>
<li><p><strong>모수추정</strong></p>
<ul>
<li>표본집단으로부터 모집단의 특성인 모수(평균, 분산 등)를 분석하여 모집단 추론</li>
</ul>
</li>
<li><p><strong>가설검정</strong></p>
<ul>
<li>대상집단에 관해 특정한 가설을 설정한 후에 가설 채택 여부를 결정하는 방법론</li>
</ul>
</li>
<li><p><strong>예측</strong></p>
<ul>
<li>미래의 불확실성을 해결해 효율적인 의사결정을 하기 위해 활용</li>
<li>예. 회귀분석, 시계열분석 등</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4-확률-및-확률분포"><a href="#4-확률-및-확률분포" class="headerlink" title="4. 확률 및 확률분포"></a>4. 확률 및 확률분포</h3><ul>
<li><p>확률</p>
<ul>
<li>표본공간 S에 부분집합인 각 사상에 대해 실수값을 가지는 함수의 확률값이 0과 1 사이에 있고 전체 확률의 합이 1인 것을 의미</li>
<li>표본공간 Ω의 부분집합인 사건 E의 확률은 표본공간의 원소 개수에 대한 사건 E 개수의 비율로 확률을 P(E)라고 할 때, 다음과 같의 정의</li>
<li>P(E) = $\frac[n(E)][N(Ω)]$</li>
</ul>
<ol>
<li><p><strong>표본공간(sample space, Ω)</strong></p>
<ul>
<li>어떤 실험을 실시할 때 나타날 수 있는 모든 결과 집합</li>
</ul>
</li>
<li><p><strong>사건(event)</strong></p>
<ul>
<li>관찰자가 관심 있는 사건, 표본공간의 부분집합</li>
</ul>
</li>
<li><p><strong>원소(element)</strong></p>
<ul>
<li>나타날 수 있는 개별 결과</li>
</ul>
</li>
<li><p><strong>확률변수(random variable)</strong></p>
<ul>
<li><p>특정값이 나타날 가능성이 확률적으로 주어지는 변수</p>
</li>
<li><p>정의역(domain)이 표본공간, 치역(range)이 실수값 (0 &lt; y &lt; 1)인 함수</p>
</li>
<li><p>0이 아닌 확률을 갖는 실수값이 형태에 따라, 이산형 확률변수(discrete random variable)와 연속형 확률변수(continuous random variable)로 구분</p>
</li>
<li><p><strong>덧셈정리(배반 X)</strong></p>
<ul>
<li>사건 A와 사건 B가 동시에 일어날 수 있을 때(교집합 성립)</li>
<li>일어날 확률 P(A 또는 B): P(A∪B) = P(A) + P(B) - P(A∩B)</li>
<li>사건 B가 주어졌을 때, 사건 A의 조건부확률: <strong>P(A|B) = P(A∩B)/P(B)</strong></li>
</ul>
</li>
<li><p><strong>덧셈정리(배반 O)</strong></p>
<ul>
<li>사건 A와 사건 B가 동시에 일어나지 않을 때</li>
<li>사건 A or 사건 B 중, 한 쪽만 일어날 확률: <strong>P(A∪B) = P(A) + P(B)</strong></li>
</ul>
</li>
<li><p><strong>곱셈정리</strong></p>
<ul>
<li>사건 A와 B가 서로 무관계하게 나타날 때(독립사건)</li>
<li>사건 B가 주어졌을 때, 사건 A의 조건부확률: <strong>P(A|B) = P(A)</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>확률분포</p>
<ul>
<li><p><strong>이산형 확률 변수</strong></p>
<ol>
<li><p><strong>베르누이 확률분포</strong>(Bernoulli distribution)</p>
<ul>
<li>결과가 2개만 나오는 경우</li>
<li>동전 던지기, 시험의 합격/불합격, 안타를 칠 확률</li>
</ul>
</li>
<li><p><strong>이항분포</strong>(Binomial distribution)</p>
<ul>
<li>베르누이 시행을 n번 반복했을 때, k번 성공할 확률</li>
<li>5번 타석에 들어와서 3번 안타를 칠 확률 → n=5, k=3, 안타를 칠 확률 P(x)=타율</li>
<li>성공할 확률 P가 0이나 1에 가깝지 않고 n이 충분히 크면 정규분포에 가까워짐, 1/2에 가까우면 종 모양</li>
</ul>
</li>
<li><p><strong>기하분포</strong>(Geometric distribution)</p>
<ul>
<li>성공확률이 p인 베르누이 시행에서 첫 번째 성공이 있기까지 x번 실패할 확률</li>
<li>5번 타석에 들어와서 3번째 타석에서 안타를 칠 확률</li>
</ul>
</li>
<li><p><strong>다항분포</strong>(Multinomial distribution)</p>
<ul>
<li>세 가지 이상의 결과를 가지는 반복 시행에서 발생하는 확률 분포 (이항분포 확장한 것)</li>
</ul>
</li>
<li><p><strong>포아송분포</strong>(Poisson distribution)</p>
<ul>
<li>시간과 공간 내에서 발생하는 사건의 발생횟수에 대한 확률분포</li>
<li>책에 오타가 5p당 10개 나온다고 할 때, 한 페이지에 오타가 3개 나올 확률</li>
<li>최근 5경기에서 10개의 홈런을 쳤다고 할 때, 오늘 경기에서 홈런을 치지 못할 확률</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>연속형 확률 변수</strong></p>
<ol>
<li><p><strong>균일분포</strong>(일양분포, Uniform distribution)</p>
<ul>
<li>모든 확률변수 X가 균일한 확률을 가지는 확률분포 (다트의 확률분포)</li>
</ul>
</li>
<li><p><strong>정규분포</strong>(Normal distribution)</p>
<ul>
<li>평균이 μ이고 표준편차가 σ인 X의 확률밀도함수</li>
<li>표준편차가 클 경우 그래프가 퍼져보임</li>
<li>표준정규분포: 평균 0, 표준편차 1 → 정규분포를 표준정규분포로 만드는 공식: z = $\frac{X-μ}{σ}$</li>
</ul>
</li>
<li><p><strong>지수분포</strong>(Exponential distribution)</p>
<ul>
<li>어떤 사건이 발생할 때까지 경과 시간에 대한 연속확률분포</li>
<li>전자레인지 수명 시간, 콜센터에 전화가 걸려올 때까지의 시간, 은행 고객 내방에 걸리는 시간, 버스가 올 때까지 시간</li>
</ul>
</li>
<li><p><strong>t-분포</strong>(t-distribution)</p>
<ul>
<li>데이터가 연속형일 때, 두 집단 평균이 동일한지 알고 싶을 때 사용</li>
<li>평균이 0을 중심으로 좌우가 동일한 분포</li>
<li>정규분포보다 퍼져 있고 자유도가 커질수록 정규분포에 가까워짐</li>
</ul>
</li>
<li><p><strong>X^2^-분포</strong>(chi-square distribution)</p>
<ul>
<li>두 집단 간의 동질성 검정에 활용</li>
<li>범주형 자료에 얻어진 관측값과 기대값 차이를 보는 적합성 검정에 활용</li>
<li>모평균과 모분산이 알려지지 않은 모집단의 모분산에 대한 가설 검정에 사용되는 분포</li>
</ul>
</li>
</ol>
<p>6 <strong>F-분포</strong>(F-distribution)</p>
<ul>
<li>두 집단 간 분산의 동일성 검정에 사용</li>
<li>확률변수는 항상 양의 값만 갖고 x^2^-분포와 달리 자유도를 2개 가지며 자유도가 커질수록 정규분포에 가까워짐</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-추정과-가설-검정"><a href="#5-추정과-가설-검정" class="headerlink" title="5. 추정과 가설 검정"></a>5. 추정과 가설 검정</h3><ul>
<li><p>추정의 개요</p>
<ul>
<li><p><strong>확률표본</strong>(random sample)</p>
<ul>
<li>확률분포는 분포를 결정하는 평균, 분산 등 모수(parameter)를 가지고 있음</li>
<li>특정한 확률분포로부터 독립적으로 반복해 표본을 추출하는 것</li>
<li>각 관찰값들은 서로 독립적이며 동일한 분포를 가짐</li>
</ul>
</li>
<li><p><strong>추정</strong></p>
<ul>
<li>표본으로부터 미지의 모수를 추측하는 것</li>
</ul>
<ol>
<li><p><strong>점추정</strong>(point estimation)</p>
<ul>
<li><strong>‘모수가 특정한 값일 것</strong>‘이라고 추정하는 것</li>
<li>표본의 평균, 중위수, 최빈값 등을 사용</li>
<li>점추정량의 조건, 표본평균, 분산<ul>
<li>불편성: 가능한 표본에서 얻은 추정량의 기대값은 모집단의 모수와 편의(차이)가 없음</li>
<li>효율성: 추정량의 분산이 작을수록 좋음</li>
<li>일치성: 표본 크기가 아주 커지면, 추정량이 모수와 거의 같아짐</li>
<li>충족성: 추정량은 모수에 대해 모든 정보를 제공</li>
<li>표본평균: 모집단 평균(모평균)을 추정하기 위한 추정량, 확률표본의 평균값</li>
<li>표본분산: 모집단의 분산(모분산)을 추정하기 위한 추정량</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>구간추정</strong>(interval estimation)</p>
<ul>
<li>점추정의 정확성을 보완하기 위해, 확률로 표현된 믿음의 정도 하에서 <strong>모수가 특정한 구간에 있을 것</strong>이라고 선언하는 것</li>
<li>항상 추정량 분포에 대한 전제와, 구해진 구간 안에 모수가 있을 가능성의 크기(신뢰수준(confidence interval))가 주어져야 함</li>
<li>참고: 모분산을 알 때는 분자에 σ, 모를 때는 S를 넣음</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>가설검정</p>
<ul>
<li>모집단에 대한 가설을 설정하고, 표본관찰을 통해 가설의 채택여부를 결정하는 분석 방법</li>
<li>표본 관찰 또는 실험을 통해 귀무가설과 대립가설 중 하나를 선택</li>
<li>귀무가설이 옳다는 전제 하에 검정통계량 값을 구하고, 이 값이 나타날 가능성의 크기에 의해 귀무가설 채택 여부를 결정</li>
</ul>
<ol>
<li><p><strong>귀무가설(null hypothesis, H<del>0</del>)</strong></p>
<ul>
<li>‘비교하는 값과 차이가 없다, 동일하다’를 기본개념으로 하는 가설</li>
</ul>
</li>
<li><p><strong>대립가설(alternative hypothesis, H<del>1</del>)</strong></p>
<ul>
<li>뚜렷한 증거가 있을 때 주장하는 가설</li>
</ul>
</li>
<li><p><strong>검정통계량(test statistic)</strong></p>
<ul>
<li>관찰된 표본으로부터 구하는 통계량, 검정 시 가설 진위를 판단하는 기준</li>
</ul>
</li>
<li><p><strong>유의수준(significance level, α)</strong></p>
<ul>
<li>귀무가설이 옳은데도 기각하는 확률 크기</li>
</ul>
</li>
<li><p><strong>기각역(critical regoin, C)</strong></p>
<ul>
<li>귀무가설이 옳다는 전제 하에서 구한 검정통계량 분포에서, 확률이 유의수준 α인 부분</li>
<li>반대는 채택역(acceptance region)</li>
</ul>
</li>
</ol>
<ul>
<li>제1종 오류와 제2종 오류</li>
</ul>
<table>
<thead>
<tr>
<th>사실 \ 가설검정 결과</th>
<th>H<del>0</del>가 사실이라고 판정</th>
<th>H<del>0</del>가 사실 아니라고 판정</th>
</tr>
</thead>
<tbody><tr>
<td>H<del>0</del>가 사실</td>
<td>옳은 결정</td>
<td>제1종 오류(α)</td>
</tr>
<tr>
<td>H<del>0</del>가 사실 아님</td>
<td>제2종 오류(β)</td>
<td>옳은 결정</td>
</tr>
</tbody></table>
<ul>
<li>두 가지 오류는 상충관계라, 가설검정에서는 제1종 오류 크기를 0.1, 0.05, 0.01 등으로 고정한 뒤, 제2종 오류가 최소가 되도록 기각역을 설정함</li>
</ul>
</li>
</ul>
<h3 id="6-비모수-검정"><a href="#6-비모수-검정" class="headerlink" title="6. 비모수 검정"></a>6. 비모수 검정</h3><ul>
<li><p><strong>모수적 방법</strong></p>
<ul>
<li>검정하고자 하는 모집단의 분포에 대해 가정하고, 가정 하에서 검정통계량과 검정통계량 분포를 유도해 검정 실시</li>
</ul>
</li>
<li><p><strong>비모수적 방법</strong></p>
<ul>
<li>자료가 추출된 모집단의 분포에 대한 아무 제약을 가하지 않고 검정 실시</li>
<li>관측된 자료가 특정분포를 따른다고 가정할 수 없는 경우에 이용</li>
<li>관측된 자료 수가 많지 않거나(30개 미만) 자료가 개체 간의 서열관계를 나타내는 경우에 이용</li>
</ul>
</li>
<li><p><strong>모수적 검정 vs 비모수적 검정</strong></p>
<ol>
<li><p>가설의 설정</p>
<ul>
<li>모수적 검정: 가정된 분포의 모수에 대해 가설 설정</li>
<li>비모수적 검정: 가정된 분포 x → 가설은 단지 분포의 형태가 동일하다/동일하지 않다’처럼 분포 형태를 설명</li>
</ul>
</li>
<li><p>검정 방법</p>
<ul>
<li><strong>모수적 검정</strong>: 관측된 자료로 구한 <strong>표본평균, 표본분산</strong> 등 이용해 검정</li>
<li><strong>비모수적 검정</strong>: <strong>관측값의 절대적 크기에 의존하지 않는 관측값의 순위나 두 관측값 차이의 부호</strong> 등 이용해 검정</li>
</ul>
</li>
</ol>
</li>
<li><p>비모수적 검정의 예</p>
<ul>
<li>부호 검정, 윌콕슨의 순위합검정, 윌콕슨의 부호순위합검정, 만-위트니의 U검정, 런검정, 스피어만의 순위상관계수</li>
</ul>
</li>
</ul>
<h2 id="2절-기초-통계분석"><a href="#2절-기초-통계분석" class="headerlink" title="2절. 기초 통계분석"></a>2절. 기초 통계분석</h2><h3 id="1-기술통계"><a href="#1-기술통계" class="headerlink" title="1. 기술통계"></a>1. 기술통계</h3><ul>
<li><p><strong>기술통계(Descriptive Statistics)</strong></p>
<ul>
<li>자료 특성을 그림, 통계량을 사용해 쉽게 파악할 수 있도록 정리하는 것</li>
<li>자료를 요약하는 기초적 통계를 의미</li>
<li>데이터 분석에 앞서 대략적 통계적 수치를 계산 → 통찰력 얻기에 유리</li>
</ul>
</li>
<li><p>통계량에 이한 자료 정리</p>
<ol>
<li>중심위치의 측도</li>
<li>산포의 측도: 분산, 표준편차, 범위, 사분위수 범위 등</li>
</ol>
</li>
<li><p>분포 형태에 관한 측도</p>
<ul>
<li>왜도: 분포의 비대칭 정도를 나타내는 측도<ul>
<li>m<del>3</del> &gt; 0: 오른쪽으로 긴 꼬리를 갖는 분포 (최빈값 &lt; 중앙값 &lt; 평균)</li>
<li>m<del>3</del> = 0: 좌우가 대칭인 분포</li>
<li>m<del>3</del> &lt; 0: 왼쪽으로 긴 꼬리를 갖는 분포 (평균 &lt; 중앙값 &lt; 최빈값)</li>
</ul>
</li>
</ul>
</li>
<li><p>그래프를 이용한 자료 정리</p>
<ul>
<li><p>히스토그램</p>
<ul>
<li>표로 된 도수분포를 그림으로 나타낸 것</li>
</ul>
</li>
<li><p><strong>막대그래프 vs 히스토그램</strong></p>
<ul>
<li><p>막대그래프</p>
<ul>
<li>범주(category)형으로 구분된 데이터를 표현 → 의도에 따라 범주의 순서를 바꿀 수 있음</li>
<li>직업, 종교, 음식</li>
</ul>
</li>
<li><p>히스토그램</p>
<ul>
<li>연속(continuous)형으로 표시된 데이터 → 임의로 순서를 바꿀 수 없고 막대의 간격이 없음</li>
<li>몸무게, 성적, 연봉</li>
</ul>
</li>
</ul>
</li>
<li><p>히스토그램의 생성</p>
<ul>
<li>계급의 수는 2^k^ ≥ n을 만족하는 최소의 정수 log<del>2</del>n = k에서 최소의 정수</li>
<li>계급 간격은 $\frac{(최대값 - 최소값)}{계급수}$로 파악 가능</li>
<li>계급 수와 간격이 변하면 히스토그램 모양도 변함</li>
</ul>
</li>
<li><p>줄기-잎 그림(stem-and leaf plot)</p>
</li>
<li><p>상자그림(Box plot)</p>
<ul>
<li>다섯 숫자 요약을 통해 그림으로 표현(최소값, Q1, Q2, Q3, 최대값)</li>
<li>사분위수 범위(IQR): Q3 - Q1</li>
<li>안울타리(inner fence): Q1 - 1.5 X IQR 또는 Q3 + 1.5 X IQR</li>
<li>바깥울타리(outer fence): Q1 - 3 X IQR 또는 Q3 + 3 X IQR</li>
<li>보통이상점(mild outlier): 안쪽울타리와 바깥울타리 사이 자료</li>
<li>극단이상점(extreme outlier): 바깥울타리 밖 자료</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-인과관계의-이해"><a href="#2-인과관계의-이해" class="headerlink" title="2. 인과관계의 이해"></a>2. 인과관계의 이해</h3><ul>
<li><p>용어</p>
<ul>
<li><p>종속변수(반응변수, y)</p>
<ul>
<li>다른 변수의 영향을 받는 변수</li>
</ul>
</li>
<li><p>독립변수(설명변수, x)</p>
<ul>
<li>영향을 주는 변수</li>
</ul>
</li>
<li><p>산점도(sxatter plot)</p>
<ul>
<li>좌표평면 위에 점들로 표현한 그래프</li>
</ul>
</li>
</ul>
</li>
<li><p>공분산(covariance)</p>
<ul>
<li>두 확률변수 X, Y 방향의 조합(선형성)</li>
<li>공분산 부호로 두 변수의 방향성 확인 가능<ul>
<li><strong>공분산 부호가 +: 두 변수는 양의 방향성, 공분산 부호가 -: 두 변수는 음의 방향성</strong>을 가짐</li>
<li>X, Y가 서로 독립이면, cov(X,Y) = 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-상관분석"><a href="#3-상관분석" class="headerlink" title="3. 상관분석"></a>3. 상관분석</h3><ul>
<li><p>상관분석(Correlation Analysis)</p>
<ul>
<li>두 변수 간 관계의 정도를 알아보기 위한 분석 방법</li>
<li>상관계수(Correlation coefficient)이용</li>
</ul>
</li>
<li><p>상관관계 특성</p>
<table>
<thead>
<tr>
<th>상관계수 범위</th>
<th>해석</th>
</tr>
</thead>
<tbody><tr>
<td>0.7 &lt; r ≤ 1</td>
<td>강한 양(+)의 상관이 있다</td>
</tr>
<tr>
<td>0.3 &lt; r ≤ 0.7</td>
<td>약한 양(+)의 상관이 있다</td>
</tr>
<tr>
<td>0 &lt; r ≤ 0.3</td>
<td>거의 상관이 없다</td>
</tr>
<tr>
<td>r = 0</td>
<td>상관관계(선형, 직선)가 존재하지 않는다</td>
</tr>
<tr>
<td>-0.3 ≤ r &lt; 0</td>
<td>거의 상관이 없다</td>
</tr>
<tr>
<td>-0.7 ≤ r &lt; -0.3</td>
<td>약한 음(-)의 상관이 있다</td>
</tr>
<tr>
<td>-1 ≤ r &lt; -0.7</td>
<td>강한 음(-)의 상관이 있다</td>
</tr>
</tbody></table>
</li>
<li><p>상관분석 유형</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>피어슨</th>
<th>스피어만</th>
</tr>
</thead>
<tbody><tr>
<td>개념</td>
<td>등간척도 이상으로 측정된 두 변수의 상관관계 측정 방식</td>
<td>서열척도인 두 변수 상관관계 측정 방식</td>
</tr>
<tr>
<td>특징</td>
<td>연속형 변수, 정규성 가정, 대부분 많이 사용</td>
<td>순서형 변수, 비모수적 방법, 순위 기준 상관관계 측정</td>
</tr>
<tr>
<td>상관계수</td>
<td>피어슨 r(적률상관계수)</td>
<td>순위상관계수(p, 로우)</td>
</tr>
</tbody></table>
</li>
<li><p>상관분석을 위한 R</p>
<ul>
<li>분산: var(x,y=NULL, na.rm=FALSE)</li>
<li>공분산: cov(x,y=NULL, use=”everything”, method=c(“pearson”, “kendall”, “spearman”))</li>
<li>상관관계: cor(x,y=NULL, use=”everything”, method=c(“pearson”, “kendall”, “spearman”))</li>
<li>상관관계(Hmisc 패키지): rcorr(matrix(data명), type=c(“pearson”, “kendall”, “spearman”))</li>
</ul>
</li>
<li><p><strong>상관분석의 가설 검정</strong></p>
<ul>
<li>상관계수 r이 0이면 입력변수 x와 출력변수 y사이에는 아무런 관계가 없음 (귀무가설: r=0, 대립가설: r≠0)</li>
<li>t 검정통계량을 통해 얻은 p-value값이 0.05 이하인 경우, 대립가설을 채택하게 되어 데이터에서 구한 상관계수를 활용할 수 있게 됨</li>
</ul>
</li>
<li><p><strong>상관분석 예제</strong></p>
<ul>
<li>cov: 공분산</li>
<li>cor: 상관계수</li>
<li><strong>p-value</strong>: <strong>유의수준 0.05보다 작게 나타나면 상관계수</strong>가 있음</li>
</ul>
</li>
</ul>
<h2 id="3절-회귀분석"><a href="#3절-회귀분석" class="headerlink" title="3절. 회귀분석"></a>3절. 회귀분석</h2><h3 id="1-회귀분석"><a href="#1-회귀분석" class="headerlink" title="1. 회귀분석"></a>1. 회귀분석</h3><ul>
<li><p>회귀분석</p>
<ul>
<li>하나나 그 이상의 독립변수들이 종속변수에 미치는 영향을 추정할 수 있는 통계기법</li>
<li>변수 사이의 인과관계를 밝히고 모형을 적합하여 관심 있는 변수를 예측하거나 추론하기 위한 분석 방법</li>
<li>독립변수의 개수가 하나면 단순선형회귀분석, 독립변수 개수가 두 개 이상이면 다중선형회귀분석</li>
</ul>
</li>
<li><p>회귀분석의 변수</p>
<ul>
<li>영향 받는 변수(y): 반응변수(response variable), 종속변수(dependent variable), 결과변수(outcome variable)</li>
<li>영향 주는 변수(x): 설명변수(explanatory variable), 독립변수(independent variable), 예측변수(predictor variable)</li>
</ul>
</li>
<li><p>선형회귀분석의 가정</p>
<ol>
<li><p><strong>선형성</strong></p>
<ul>
<li>입력변수와 출력변수의 관계가 <strong>선형</strong> (가장 중요한 가정)</li>
</ul>
</li>
<li><p><strong>등분산성</strong></p>
<ul>
<li>오차 분산이 입력변수와 무관하게 일정</li>
<li>잔차플롯(산점도)를 활용해 잔차와 입력변수 간 아무런 관련성이 없게 무작위적으로 고루 분포돼야 등분산성 가정 만족</li>
</ul>
</li>
<li><p><strong>독립성</strong></p>
<ul>
<li>입력변수와 오차는 관련 없음</li>
<li>자기상관(독립성)을 알아보기 위해 Durbin-Waston 통계량 사용</li>
<li>시계열 데이터에서 많이 활용</li>
</ul>
</li>
<li><p><strong>비상관성</strong></p>
<ul>
<li>오차들끼리 상관이 없음</li>
</ul>
</li>
<li><p><strong>정상성(정규성)</strong></p>
<ul>
<li>오차 분포가 정규분포를 따름</li>
<li>Q-Q plot, Kolmogolov-Sirnov 검정, Shaprio-Wilk 검정 등 활용</li>
</ul>
</li>
</ol>
</li>
<li><p>가정에 대한 검증</p>
<ul>
<li><p>단순선형회귀분석</p>
<ul>
<li>입력변수와 출력변수 간 선형성을 점검하기 위해 산점도 확인</li>
</ul>
</li>
<li><p>다중선형회귀분석</p>
<ul>
<li>선형회귀분석 가정인 선형성, 등분산성, 독립성, 정상성이 모두 만족하는지 확인</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-단순선형회귀분석"><a href="#2-단순선형회귀분석" class="headerlink" title="2. 단순선형회귀분석"></a>2. 단순선형회귀분석</h3><ul>
<li><p>하나의 독립변수가 종속변수에 미치는 영향을 추정할 수 있는 통계기법</p>
</li>
<li><p>회귀분석 검토사항</p>
<ol>
<li><p><strong>회귀계수가 유의미</strong>한가?</p>
<ul>
<li><strong>해당 계수 t 통계량의 p-값이 0.05보다 작으면</strong> 해당 회귀계수가 통계적으로 유의하다고 볼 수 있음</li>
</ul>
</li>
<li><p><strong>모형이 설명력</strong>을 갖는가?</p>
<ul>
<li>**결정계수(R^2^)**를 확인</li>
<li>결정계수는 0~1값을 가지며, <strong>높을수록 추정된 회귀식의 설명력이 높아짐</strong></li>
</ul>
</li>
<li><p>모형이 <strong>데이터를 잘 적합</strong>하는가?</p>
<ul>
<li><strong>잔차</strong>를 그래프로 그리고 회귀진단</li>
</ul>
</li>
</ol>
</li>
<li><p>회귀계수의 추정</p>
<ul>
<li><strong>최소제곱법</strong>, 최소자승법</li>
<li>측정값을 기초로 적당한 제곱합을 만들고 이를 최소로 하는 값을 구해 측정결과를 처리</li>
<li>잔차제곱이 가장 작은 선을 구하는 것</li>
</ul>
</li>
<li><p>회귀분석의 검정</p>
<ul>
<li>회귀계수의 검정<ul>
<li>회귀계수 β<del>1</del>이 0이면 입력변수 X와 출력변수 y 사이에는 아무런 인과관계가 없음</li>
<li>회귀계수 β<del>1</del>이 0이면 적합된 추정식은 아무 의미가 없음 (귀무가설 β<del>1</del>=0, 대립가설 <del>1</del>≠0)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-다중선형회귀분석"><a href="#3-다중선형회귀분석" class="headerlink" title="3. 다중선형회귀분석"></a>3. 다중선형회귀분석</h3><ul>
<li><p>다중선형회귀분석(다변량회귀분석)</p>
<ul>
<li><p>다중회귀식</p>
<ul>
<li>Y = β<del>0</del> + β<del>1</del>X<del>1</del> + β<del>2</del>X<del>2</del> + … + β<del>k</del>X<del>k</del> + ε  </li>
</ul>
</li>
<li><p>모형의 통계적 유의성</p>
<ul>
<li>모형의 통계적 유의성은 F통계량으로 확인</li>
<li>유의수준 5% 하에서 F통계량의 p-값이 0.05보다 작으면 추정된 회귀식은 통계적으로 유의하다 볼 수 있음</li>
<li><strong>F통계량이 크면 p-value가 0.05보다 작아지고 귀무가설을 기각</strong>함 → <strong>모형이 유의하다</strong>고 결론 내릴 수 있음  </li>
</ul>
</li>
<li><p>회귀계수의 유의성</p>
<ul>
<li>단변량 회귀분석의 회귀계수 유의성 검토와 같이 t통계량을 통해 확인</li>
<li>모든 회귀계수의 유의성이 통계적으로 검증되어야 선택된 변수 조합으로 모형 확인 가능  </li>
</ul>
</li>
<li><p>모형의 설명력</p>
<ul>
<li>결정계수(R^2^)나 수정된 결정계수(R^2^<del>α</del>) 확인  </li>
</ul>
</li>
<li><p>모형의 적합성</p>
<ul>
<li>잔차와 종속변수의 산점도로 모형이 데이터를 잘 적합하고 있는지 확인</li>
</ul>
</li>
<li><p>데이터가 전제하는 가정을 만족하는가?</p>
<ul>
<li><strong>선형성, 독립성, 등분산성, 비상관성, 정상성</strong></li>
</ul>
</li>
<li><p>다중공선성(multicollinearity)</p>
<ul>
<li>다중회귀분석에서 설명변수 사이에 선형관계가 존재하면 회귀계수의 정확한 추정이 곤란함</li>
<li>다중공선성 검사 방법<ul>
<li>분산팽창요인(VIF): 4보다 크면 다중공산성 존재한다고 볼 수 있고, 10보다 크면 심각한 문제가 있다고 해석</li>
<li>상태지수: 10 이상이면 문제 있다고 보고, 30보다 크면 심각한 문제가 있다고 해석<ul>
<li>다중선형회귀분석에서 다중공선성 문제 발생 시, 문제 있는 변수를 제거하거나 주성분회귀, 능형회귀 모형을 적용하여 문제 해결</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-회귀분석의-종류"><a href="#4-회귀분석의-종류" class="headerlink" title="4. 회귀분석의 종류"></a>4. 회귀분석의 종류</h3><table>
<thead>
<tr>
<th>종류</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>단순회귀</td>
<td>독립변수가 1개이며 종속변수와의 관계가 직선</td>
</tr>
<tr>
<td>다중회귀</td>
<td>독립변수가 k개이며 종속변수와의 관계가 선형(1차 함수)</td>
</tr>
<tr>
<td>로지스틱 회귀</td>
<td>종속변수가 범주형(2진변수)인 경우에 적용, 단순 로지스틱 회귀 및 다중, 다항 로지스틱 회귀로 확장할 수 있음</td>
</tr>
<tr>
<td>다항회귀</td>
<td>독립변수와 종속변수와의 관계가 1차 함수 이상인 관계(단, k=1이면 2차 함수 이상)</td>
</tr>
<tr>
<td>곡선회귀</td>
<td>독립변수가 1개이며 종속변수와의 관계가 곡선</td>
</tr>
<tr>
<td>비선형회귀</td>
<td>회귀식 모양이 미지의 모수들의 선형관계로 이뤄져 있지 않은 모형</td>
</tr>
</tbody></table>
<h3 id="5-회귀분석-사례"><a href="#5-회귀분석-사례" class="headerlink" title="5. 회귀분석 사례"></a>5. 회귀분석 사례</h3><ul>
<li>그래프 보고 푸는 문제<ul>
<li><strong>F-statistic</strong>: F-통계량</li>
<li><strong>p-value</strong>: 유의수준 5% 하에서 추정되어야 해당 회귀 모형이 통계적으로 유의하다고 할 수 있음</li>
<li><strong>Multiple R-squared</strong>: 결정계수, Adjusted R-squared: 수정된 결정계수 (0~1값을 가지며, 높을수록 회귀식의 설명력 높아짐)</li>
<li><strong>Pr</strong>: 회귀계수들의 p-값</li>
</ul>
</li>
</ul>
<h3 id="6-최적회귀방정식"><a href="#6-최적회귀방정식" class="headerlink" title="6. 최적회귀방정식"></a>6. 최적회귀방정식</h3><ul>
<li><p>설명변수 선택</p>
<ul>
<li>상황에 따라 필요한 변수만 선택</li>
<li>y에 영향을 미칠 수 있는 모든 설명변수 x가 y값 예측에 참여</li>
<li>데이터에 설명변수 x 수가 많아지면 관리가 어려워, 가능한 범위 내에서 적은 수의 설명변수만 포함</li>
</ul>
</li>
<li><p>모형선택(exploratiry analysis)</p>
<ul>
<li>분석 데이터에 가장 잘 맞는 모형을 찾는 방법</li>
<li>가능한 모든 조합의 회귀분석(All possible regression): 가능한 모든 독립변수 조합에 대한 회귀모형을 생성한 뒤, 가장 적합한 회귀모형 선택</li>
</ul>
</li>
<li><p>단계적 변수 선택(Stepwise Variable Selection)</p>
<ul>
<li><p><strong>전진선택법</strong>(forward selection)</p>
<ul>
<li>절편만 있는 상수모형으로 시작해 중요하다고 생각되는 설명변수부터 모형에 추가</li>
</ul>
</li>
<li><p><strong>후진제거법</strong>(backward selection)</p>
<ul>
<li>독립변수 후보 모두를 포함한 모형에서 출발해 가장 적은 영향을 주는 변수부터 제거</li>
<li>더 제거할 변수가 없을 때의 모형을 선택</li>
</ul>
</li>
<li><p><strong>단계선택법</strong>(stepwise selection)</p>
<ul>
<li>전진선택법에 이해 변수를 추가하며, 새롭게 추가된 변수에 기인해 기존 변수 중요도가 약화되면 해당변수를 제거</li>
<li>단계별로 추가 또는 제거되는 변수 여부를 검토하고 더 이상 없을 때 중단</li>
</ul>
</li>
</ul>
</li>
<li><p>벌점화된 선택기준</p>
<ul>
<li><p>모형 복잡도에 벌점을 주는 방법</p>
<ul>
<li><strong>AIC</strong>(Akaike information criterion)</li>
<li><strong>BIC</strong>(Bayesian information criterion)</li>
</ul>
</li>
<li><p>모든 후보 모형에 대해 AIC 또는 BIC를 계산하고 값이 최소가 되는 모형을 선택</p>
</li>
<li><p>모형 선택의 일치성(consistency inselection)</p>
<ul>
<li>자료 수가 늘어날 때 참인 모형이 주어진 모형 선택 기준의 최소값을 갖게 되는 성질</li>
<li>이론적으로 AIC에 대해 일치성이 성립하지 않지만, BIC는 주요 분포에서 이러한 성질이 성립</li>
</ul>
</li>
<li><p>AIC 활용이 보편화된 방식</p>
</li>
<li><p>추가: RIC(Risk inflation criterion), CIC(Covariance inflation criterion), DIC(Deviation information criterion)</p>
</li>
</ul>
</li>
<li><p>최적회귀방정식 사례: 교재 참고</p>
<ol>
<li>변수 선택법 예제(유의확률 기반)</li>
<li>변수 선택법 예제(벌점화 전진선택법)</li>
<li>변수 선택법 예제(벌점화 후진제거법)</li>
</ol>
</li>
</ul>
<h2 id="4절-시계열-분석"><a href="#4절-시계열-분석" class="headerlink" title="4절. 시계열 분석"></a>4절. 시계열 분석</h2><h3 id="1-시계열-자료"><a href="#1-시계열-자료" class="headerlink" title="1. 시계열 자료"></a>1. 시계열 자료</h3><ul>
<li><p>시계열 자료</p>
<ul>
<li>시간의 흐름에 따라 관찰된 값</li>
<li>시계열 데이터 분석을 통해 미래의 값을 예측하고 경향, 주기, 계절성 등을 파악하여 활용</li>
</ul>
</li>
<li><p>시계열 자료의 종류</p>
<ol>
<li><p>비정상성 시계열 자료</p>
<ul>
<li>시계열 분석을 실시할 때, 다루기 어려운 자료</li>
</ul>
</li>
<li><p>정상성 시계열 자료</p>
<ul>
<li>비정상 시계열을 핸들링해 다루기 쉬운 시계열 자료로 변환한 자료</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-정상성"><a href="#2-정상성" class="headerlink" title="2. 정상성"></a>2. 정상성</h3><ul>
<li><p>평균이 일정할 경우</p>
<ul>
<li>모든 시점에 대해 일정한 평균을 가짐</li>
<li><strong>평균이 일정하지 않은 시계열은 차분(difference)을 통해 정상화</strong>할 수 있음</li>
<li>차분?<ul>
<li>현 시점 자료에서 전 시점 자료를 빼는 것</li>
<li>일반차분: 바로 전 시점 자료를 빼는 방법, 계절차분: 여러 시점 전의 자료를 빼는 방법</li>
</ul>
</li>
</ul>
</li>
<li><p>분산이 일정</p>
<ul>
<li>분산도 시점에 의존하지 않고 일정해야 함</li>
<li><strong>분산이 일정하지 않을 경우 변환(transformation)을 통해 정상화</strong>할 수 있음</li>
</ul>
</li>
<li><p>공분산도 단지 시차에만 의존, 실제 특정 시점 t, s에는 의존하지 않음</p>
</li>
<li><p>정상 시계열</p>
<ul>
<li>어떤 시점에서 평균과 분산, 특정한 시차의 길이를 갖는 자기공분산을 측정하더라도 동일한 값을 가짐</li>
<li>정상 시계열은 항상 그 평균값으로 회귀하려는 경향이 있으며, 그 평균값 주변에서의 변동은 대체로 일정한 폭을 가짐</li>
<li>정상 시계열이 아닌 경우 특정 기간의 시계열 자료로부터 얻은 정보를 다른 시기로 일반화할 수 없음</li>
</ul>
</li>
</ul>
<h3 id="3-시계열자료-분석방법"><a href="#3-시계열자료-분석방법" class="headerlink" title="3. 시계열자료 분석방법"></a>3. 시계열자료 분석방법</h3><ul>
<li><p>분석방법</p>
<ul>
<li>회귀분석(계량경제) 방법, Box-Jenkins 방법, 지수평활법, 시계열 분해법 등</li>
</ul>
</li>
<li><p>자료 형태에 따른 분석방법</p>
<ul>
<li><p>일변량 시계열분석</p>
<ul>
<li>Box-Jenkins(ARMA), 지수평활법, 시계열 분해법</li>
<li>시간(t)을 설명변수로 한 회귀모형주가, 소매물가지수 등 하나의 변수에 관심 갖는 경우의 시계열분석</li>
</ul>
</li>
<li><p>다중 시계열분석</p>
<ul>
<li>계량경제모형, 전이함수모형, 개입분석, 상태공간분석, 다변량 ARIMA 등</li>
<li>여러 개의 시간(t)에 따른 변수들을 활용하는 시계열 분석</li>
</ul>
</li>
</ul>
</li>
<li><p>이동평균법</p>
</li>
<li><p>지수평활법</p>
</li>
</ul>
<h3 id="4-시계열모형"><a href="#4-시계열모형" class="headerlink" title="4. 시계열모형"></a>4. 시계열모형</h3><p>교재 참고</p>
<h2 id="5절-다차원척도법"><a href="#5절-다차원척도법" class="headerlink" title="5절. 다차원척도법"></a>5절. 다차원척도법</h2><h3 id="1-다차원척도법-Multidimensional-Scaling"><a href="#1-다차원척도법-Multidimensional-Scaling" class="headerlink" title="1. 다차원척도법(Multidimensional Scaling)"></a>1. 다차원척도법(Multidimensional Scaling)</h3><ul>
<li>객체간 근접성을 시각화하는 통계기법</li>
<li>군집분석과 같이 개체를 대상으로 변수들을 측정한 후, 개체 사이의 유사성/비유사성을 측정하여 개체들을 2차원 공간상에 점으로 표현하는 분석 방법</li>
<li>개체들을 2차원 또는 3차원 공간상에 점으로 표현하여 개체들 사이의 집단화를 시각적으로 표현하는 분석 방법</li>
</ul>
<h3 id="2-다차원척도법-목적"><a href="#2-다차원척도법-목적" class="headerlink" title="2. 다차원척도법 목적"></a>2. 다차원척도법 목적</h3><ul>
<li>데이터 속에 잠재해 있는 패턴, 구조를 찾아냄</li>
<li>찾아낸 구조를 소수 차원의 공간에 기하학적으로 표현</li>
<li>데이터 축소 목적으로 다차원척도법을 이용 → 데이터에 포함되는 정보를 끄집어내기 위한 탐색수단</li>
<li>다차원척도법에 의해 얻은 결과를, 데이터가 만들어진 현상이나 과정에 고유의 구조로서 의미 부여</li>
</ul>
<h3 id="3-다차원척도법-방법"><a href="#3-다차원척도법-방법" class="headerlink" title="3. 다차원척도법 방법"></a>3. 다차원척도법 방법</h3><ul>
<li><p>객체들의 거리 계산: 유클리드 거리행렬 활용</p>
</li>
<li><p>관측대상의 상대적 거리 정확도를 높이기 위해 적합 정도를 스트레스값으로 나타냄</p>
</li>
<li><p>각 개체를 공간상에 표현하기 위한 방법: 부적합도 기준으로 STRESS나 S-STRESS 사용</p>
</li>
<li><p>최적모형의 적합은 부적합도를 최소로 하는 반복알고리즘을 이용하며, 이 값이 일정 수준 이하가 될 때 최종적으로 적합된 모형으로 제시</p>
</li>
<li><p>STRESS와 적합도 수준 M은 개체들을 공간상에 표현하기 위한 방법으로 STRESS나 S-STRESS를 부적합도 기준으로 사용</p>
<table>
<thead>
<tr>
<th>STRESS</th>
<th>적합도 수준</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>완벽(perfect)</td>
</tr>
<tr>
<td>0.05 이내</td>
<td>매우 좋은(excellent)</td>
</tr>
<tr>
<td>0.05 ~ 0.10</td>
<td>만족(satisfactory)</td>
</tr>
<tr>
<td>0.10 ~ 0.15</td>
<td>보통(acceptable, but doubt)</td>
</tr>
<tr>
<td>0.15 이상</td>
<td>나쁨(poor)</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4-다차원척도법-종류"><a href="#4-다차원척도법-종류" class="headerlink" title="4. 다차원척도법 종류"></a>4. 다차원척도법 종류</h3><ul>
<li><p>계량적 MDS(Metric MDS)</p>
<ul>
<li>데이터가 구간척도나 비율척도인 경우 활용</li>
<li>N개의 케이스에 대해 P개의 특성변수가 있는 경우, 각 개체들 간 유클리드 거리행렬을 계산하고 개체들 간 비유사성 S(거리제곱 행렬의 선형함수)를 공간상에 표현</li>
</ul>
</li>
<li><p>비계량적 MDS(nonmetric MDS)</p>
<ul>
<li>데이터가 순서척도인 경우 활용</li>
<li>개체들 간 거리가 순서로 주어진 경우에는 순서척도를 거리의 속성과 같도록 변환하여 거리를 생성한 후 적용</li>
</ul>
</li>
</ul>
<h2 id="6절-주성분분석"><a href="#6절-주성분분석" class="headerlink" title="6절. 주성분분석"></a>6절. 주성분분석</h2><h3 id="1-주성분분석-Principal-Component-Analysis"><a href="#1-주성분분석-Principal-Component-Analysis" class="headerlink" title="1. 주성분분석(Principal Component Analysis)"></a>1. 주성분분석(Principal Component Analysis)</h3><ul>
<li>여러 변수들이 변량을 주성분이라는 서로 상관성이 높은 변수의 선형 결합으로 만들어 기존 상관성이 높은 변수들을 요약, 축소하는 기법</li>
<li>첫 번째 주성분으로 전체 변동을 가장 많이 설명할 수 있도록 하고, 두 번째 주성분으로는 첫 번째 주성분과는 상관성이 없어서(낮아서) 첫 번째 주성분이 설명하지 못하는 나머지 변동을 정보의 손실 없이 가장 많이 설명할 수 있도록 변수들의 선형조합을 만듦</li>
</ul>
<h3 id="2-주성분분석의-목적"><a href="#2-주성분분석의-목적" class="headerlink" title="2. 주성분분석의 목적"></a>2. 주성분분석의 목적</h3><ul>
<li>여러 변수들 간 내재하는 상관관계, 연관성을 이용해 소수의 주성분으로 차원을 축소함으로써 데이터를 이해하기 쉽고 관리하기 쉽게 함</li>
<li>다중공선성이 존재하는 경우, 상관성 없는(적은) 주성분으로 변수들을 축소하여 모형 개발에 활용</li>
<li>회귀분석이나 의사결정나무 등 모형 개발 시, 입력변수들 간 상관관계가 높은 다중공선성이 존재할 경우 모형이 잘못 만들어져 문제 발생</li>
<li>연관성 높은 변수를 주성분분석을 통해 차원을 축소한 후, 군집분석을 수행하면 군집화 결과와 연산속도 개선 가능</li>
<li>기계에서 나오는 센서데이터를 주성분분석으로 차원 축소 후, 시계열로 분포나 추세 변화를 분석하면 기계의 고장 징후를 사전에 파악하는 데 활용할 수 있음</li>
</ul>
<h3 id="3-주성분분석-vs-요인분석"><a href="#3-주성분분석-vs-요인분석" class="headerlink" title="3. 주성분분석 vs 요인분석"></a>3. 주성분분석 vs 요인분석</h3><ul>
<li><p><strong>요인분석</strong>(Factor Analysis)</p>
<ul>
<li>등간척도(혹은 비율척도)로 측정한 두 개 이상 변수에 잠재된 공통인자를 찾아내는 기법</li>
</ul>
</li>
<li><p>공통점</p>
<ul>
<li>모두 데이터를 축소하는 데 활용</li>
<li>원래 데이터를 활용하여 몇 개의 새로운 변수 생성 가능</li>
</ul>
</li>
<li><p>차이점</p>
<ul>
<li><p>생성된 변수의 수</p>
<ul>
<li>요인분석은 몇 개라고 지정 없이(2 or 3, 4, 5 …) 만들 수 있음</li>
<li>주성분분석은 제1주성분, 제2주성분, 제3주성분 정도로 활용(대략 4개 이상은 넘지 않음)</li>
</ul>
</li>
<li><p>생성된 변수 이름</p>
<ul>
<li>요인분석은 분석자가 요인 이름을 명명</li>
<li>주성분분석은 주로 제1주성분, 제2주성분 등으로 표현</li>
</ul>
</li>
<li><p>생성된 변수 간 관계</p>
<ul>
<li>요인분석은 새 변수들은 기본적으로 대등한 관계를 가짐</li>
<li>요인분석은 어떤 것이 더 중요하다는 의미가 없음(분류/예측의 다음 단계로 사용되면 중요성 부여)</li>
<li>주성분분석은 제1주성분이 가장 중요, 그 다음 제2주성분이 중요</li>
</ul>
</li>
<li><p>분석 방법의 의미</p>
<ul>
<li>요인분석은 목표변수를 고려하지 않고 데이터가 주어지면 변수를 비슷한 성격으로 묶어서 새로운 (잠재)변수를 만듦</li>
<li>주성분분석은 목표변수를 고려하여 목표변수를 예측/분류하기 위해 원래 변수의 선형 결합으로 이뤄진 몇 개의 주성분(변수)를 찾게 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-주성분의-선택법"><a href="#4-주성분의-선택법" class="headerlink" title="4. 주성분의 선택법"></a>4. 주성분의 선택법</h3><ul>
<li>주성분분석 결과에서 누적기여율(cumulative proportion)이 85% 이상이면 주성분 수로 결정할 수 있음</li>
<li>scree plot을 활용하여 고유값(eigenvalue)이 수평을 유지하기 전 단계로 주성분의 수 선택</li>
</ul>
<h3 id="5-주성분-분석-사례"><a href="#5-주성분-분석-사례" class="headerlink" title="5. 주성분 분석 사례"></a>5. 주성분 분석 사례</h3><ul>
<li>교재 참고</li>
</ul>
<h1 id="5장-정형-데이터-마이닝"><a href="#5장-정형-데이터-마이닝" class="headerlink" title="5장. 정형 데이터 마이닝"></a>5장. 정형 데이터 마이닝</h1><h2 id="1절-데이터마이닝의-개요"><a href="#1절-데이터마이닝의-개요" class="headerlink" title="1절. 데이터마이닝의 개요"></a>1절. 데이터마이닝의 개요</h2><h3 id="1-데이터마이닝"><a href="#1-데이터마이닝" class="headerlink" title="1. 데이터마이닝"></a>1. 데이터마이닝</h3><ul>
<li><p>데이터마이닝</p>
<ul>
<li>대용량 데이터에서 의미 있는 패턴을 파악하거나 예측하여 의사결정에 활용하는 방법</li>
</ul>
</li>
<li><p>통계분석과의 차이점</p>
<ul>
<li>통계분석은 가설이나 가정에 따른 분석이나 검증을 함</li>
<li>데이터마이닝은 다양한 수리 알고리즘을 이용해 데이터베이스의 데이터로부터 의미 있는 정보를 찾아내는 방법을 통칭</li>
</ul>
</li>
<li><p>종류</p>
<table>
<thead>
<tr>
<th>정보를 찾는 방법론에 따라</th>
<th>분석대상, 활용목적, 표현방법에 따라</th>
</tr>
</thead>
<tbody><tr>
<td>인공지능, 의사결정나무, K-평균군집화, 연관분석, 회귀분석, 로짓분석, 최근접이웃</td>
<td>시각화분석, 분류, 군집화, 포케스팅</td>
</tr>
</tbody></table>
</li>
<li><p>사용분야</p>
<ul>
<li>병원: 환자 데이터를 이용하여 해당 환자에게 발생 가능성 높은 병 예측</li>
<li>병원: 기존 환자가 응급실에 왔을 때, 어떤 조치를 먼저 해야 하는지 결정</li>
<li>은행: 고객 데이터를 이용해 해당 고객의 우량/불량을 예측하여 대출 여부 판단</li>
<li>공항: 세관 검사에서 입국자 이력과 데이터를 이용해 관세품 반입 여부 예측</li>
</ul>
</li>
</ul>
<h3 id="2-데이터마이닝의-분석-방법"><a href="#2-데이터마이닝의-분석-방법" class="headerlink" title="2. 데이터마이닝의 분석 방법"></a>2. 데이터마이닝의 분석 방법</h3><table>
<thead>
<tr>
<th>Supervised Data Prediction(지도학습)</th>
<th>Unsupervised Data Prediction(비지도학습)</th>
</tr>
</thead>
<tbody><tr>
<td>의사결정나무, 인공신경망, 일반화 선형 모형, 회귀분석, 로지스틱 회귀분석, 사례기반 추론, 최근접 이웃법</td>
<td>OLAP, 연관성 규칙발견, 군집분석, SOM</td>
</tr>
</tbody></table>
<h3 id="3-분석-목적에-따른-작업-유형과-기법"><a href="#3-분석-목적에-따른-작업-유형과-기법" class="headerlink" title="3. 분석 목적에 따른 작업 유형과 기법"></a>3. 분석 목적에 따른 작업 유형과 기법</h3><ul>
<li>예측(Predictive Modeling): 분류 규칙</li>
<li>설명(Descriptive Modeling): 연관 규칙, 연속 규칙, 데이터 군집화</li>
</ul>
<table>
<thead>
<tr>
<th>작업유형</th>
<th>설명</th>
<th>사용기법</th>
</tr>
</thead>
<tbody><tr>
<td>분류 규칙(Classification)</td>
<td>가장 많이 사용되는 작업으로 과거 데이터로부터 고객특성을 찾아 분륨형을 만들어 이를 토대로 새로운 레코드의 결과값을 예측하는 것, 목표 마케팅 및 고객 신용평가 모형에 활용</td>
<td>회귀분석, 판별분석, 신경망, 의사결정나무</td>
</tr>
<tr>
<td>연관규칙(Association)</td>
<td>데이터 안에 존재하는 항목간의 종속관계를 찾아내는 작업, 제품이나 서비스 교차판매, 매장진열, 첨부우편, 사기적발 등 분야에 활용</td>
<td>동시발생 매트릭스</td>
</tr>
<tr>
<td>연속규칙(Sequence)</td>
<td>연관 규칙에 시간 관련 정보가 포함된 형태, 고객 구매이력 속성이 반드시 필요, 목표 마케팅이나 일대일 마케팅에 활용</td>
<td>동시발생 매트릭스</td>
</tr>
<tr>
<td>데이터 군집화(Clustering)</td>
<td>고객 레코드를 유사한 특성을 지닌 몇 개의 소그룹으로 분할, 작업 특성이 분류규칙과 유사하나 분석대상 데이터에 결과값이 없음, 판촉활동이나 이벤트 대상 선정에 활용</td>
<td>K-Means Clustering</td>
</tr>
</tbody></table>
<h3 id="4-데이터마이닝-추진단계"><a href="#4-데이터마이닝-추진단계" class="headerlink" title="4. 데이터마이닝 추진단계"></a>4. 데이터마이닝 추진단계</h3><ol>
<li>목적 설정</li>
<li>데이터 준비</li>
<li>가공</li>
<li>기법 적용</li>
<li>검증</li>
</ol>
<h3 id="5-데이터마이닝을-위한-데이터-분할"><a href="#5-데이터마이닝을-위한-데이터-분할" class="headerlink" title="5. 데이터마이닝을 위한 데이터 분할"></a>5. 데이터마이닝을 위한 데이터 분할</h3><ul>
<li><p>개요</p>
<ul>
<li>모델 평가용 테스트 데이터와 구축용 데이터로 분할</li>
<li>구축용 데이터로 모형을 생성하고 테스트 데이터로 모형이 얼마나 적합한지를 판단</li>
</ul>
</li>
<li><p>데이터 분할</p>
<ol>
<li><p>구축용(training data, 50%)</p>
<ul>
<li>추정용, 훈련용 데이터라고도 불리며 데이터마이닝 모델을 만드는 데 활용</li>
</ul>
</li>
<li><p>검정용(validation data, 30%)</p>
<ul>
<li>구축된 모형의 과대추정 또는 과소추정을 미세 조정하는 데 활용</li>
</ul>
</li>
<li><p>시험용(tast data, 20%)</p>
<ul>
<li>테스트 데이터나 과거 데이터를 활용하여 모델의 성능을 검증하는 데 활용</li>
</ul>
</li>
<li><p>데이터 양이 충분하지 않거나 입력 변수에 대한 설명이 충분한 경우</p>
<ul>
<li><p><strong>홀드아웃 방법</strong></p>
<ul>
<li>주어진 데이터를 랜덤하게 두 개의 데이터로 구분하여 사용</li>
<li>주로 학습용과 시험용으로 분리하여 사용</li>
</ul>
</li>
<li><p><strong>교차확인 방법</strong></p>
<ul>
<li>주어진 데이터를 k개의 하부집단으로 구분</li>
<li>k-1개의 집단을 학습용으로 나머지는 하부집단으로 검증용으로 설정하여 학습</li>
<li>k번 반복 측정한 결과를 평균낸 값을 최종값으로 사용</li>
<li>주로 <strong>10-fold</strong> 교차분석을 많이 사용</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="6-성과분석"><a href="#6-성과분석" class="headerlink" title="6. 성과분석"></a>6. 성과분석</h3><ul>
<li><p>오분류에 대한 추정치</p>
<ol>
<li><p><strong>정분류율</strong>(Accuracy)</p>
<ul>
<li>Accuracy = $\frac{TN + TP}{TN + TP + FN + FP}$</li>
</ul>
</li>
<li><p><strong>오분류율</strong>(Error Rate)</p>
<ul>
<li>1 - Accuracy = $\frac{FN + FP}{TN + TP + FN + FP}$</li>
</ul>
</li>
<li><p><strong>특이도</strong>(Specificity)</p>
<ul>
<li>Specificity = $\frac{TN}{TN + FP}$ (TNR: True Negative Rate)</li>
</ul>
</li>
<li><p><strong>민감도</strong>(Sensitivity)</p>
<ul>
<li>Sensitivity = $\frac{TP}{TP + FN}$ (TPR: True Positive Rate)</li>
</ul>
</li>
<li><p><strong>정확도</strong>(Precision)</p>
<ul>
<li>Precision = $\frac{TP}{TP + FP}$</li>
</ul>
</li>
<li><p><strong>재현율</strong>(Recall): 민감도와 같음</p>
<ul>
<li>Recall = $\frac{TP}{TP + FN}$</li>
</ul>
</li>
<li><p><strong>F1 Score</strong></p>
<ul>
<li>F1 = 2 x $\frac{Precision x Recall}{Precision + Recall}$</li>
</ul>
</li>
</ol>
</li>
<li><p>ROCR 패키지로 성과분석</p>
<ul>
<li><p><strong>ROC Curve</strong>(Receiver Operation Characteristic Curve)</p>
<ul>
<li><p>가로축을 FPR(False Positive Rate = 1 - 특이도)값, 세로축을 TPR(Ture Positive Rate, 민감도)값으로 두어 시각화한 그래프</p>
</li>
<li><p>2진 분류(binary classfication)에서 모형 성능을 평가하기 위해 사용되는 척도</p>
</li>
<li><p>그래프가 왼쪽 상단에 가깝게 그려질수록 올바르게 예측한 비율은 높고 잘못 예측한 비율은 낮음을 의미</p>
</li>
<li><p><strong>ROC 곡선 아래 면적을 의미하는 AUROC(Area Under ROC) 값이 클수록(1에 가까울 수록) 모형 성능이 좋다고 평가</strong></p>
</li>
<li><p>TPR: 1인 케이스에 대한 1로 예측한 비율</p>
</li>
<li><p>FPR: 0인 케이스에 대한 1로 잘못 예측한 비율</p>
</li>
<li><p>AUROC를 이용한 정확도의 판단 기준</p>
<table>
<thead>
<tr>
<th>기준</th>
<th>구분</th>
</tr>
</thead>
<tbody><tr>
<td>0.9 - 1.0</td>
<td>excellent (A)</td>
</tr>
<tr>
<td>0.8 - 0.9</td>
<td>good</td>
</tr>
<tr>
<td>0.7 - 0.8</td>
<td>fair</td>
</tr>
<tr>
<td>0.6 - 0.7</td>
<td>poor</td>
</tr>
<tr>
<td>0.5 - 0.6</td>
<td>fail</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>이익도표(Lift chart)*</p>
<ul>
<li>분류모형 성능을 평가하기 위한 척도 (분류된 관측치에 대해 예측이 얼마나 잘 이루어졌는지)</li>
<li>임의로 나눈 등급별로 반응검출율, 반응률, 리프트 등 정보를 산출해 나타내는 도표</li>
<li>기본 향상도에 비해 반응률이 몇 배나 높은지 계산: <strong>향상도(Lift)</strong></li>
<li>각 등급은 예측확률에 따라 매겨진 순위이므로, 상위 등급에서는 더 높은 반응률을 보이는 것이 좋은 모형</li>
</ul>
</li>
</ul>
<h2 id="2절-분류분석"><a href="#2절-분류분석" class="headerlink" title="2절. 분류분석"></a>2절. 분류분석</h2><h3 id="1-분류분석과-예측분석"><a href="#1-분류분석과-예측분석" class="headerlink" title="1. 분류분석과 예측분석"></a>1. 분류분석과 예측분석</h3><ul>
<li><p>분류분석의 정의</p>
<ul>
<li>데이터가 어떤 그룹에 속하는지 예측할 때 사용하는 기법</li>
<li>클러스터링과 유사하나, 분류분석은 각 그룹이 정의되어 있음</li>
<li>교사학습(supervised learning)에 해당하는 예측기법</li>
</ul>
</li>
<li><p>예측분석의 정의</p>
<ul>
<li>시계열분석처럼 시간에 따른 값 두 개만을 이용해 앞으로의 매출 또는 온도 등을 예측하는 것</li>
<li>모델링을 하는 입력 데이터가 어떤 것인지에 따라 특성이 다름</li>
<li>여러 개의 다양한 설명변수(독립변수)가 아닌 한 개의 설명변수로 생각하면 됨</li>
</ul>
</li>
<li><p>분류분석 vs 예측분석</p>
<ul>
<li><p>공통점</p>
<ul>
<li>레코드 특정 속성의 값을 미리 알아맞힐 수 있음</li>
</ul>
</li>
<li><p>차이점</p>
<ul>
<li><strong>분류</strong>: 레코드(튜플)의 <strong>범주형 속성</strong>의 값을 맞힘(국/영/수 점수로 내신 등급 맞히기)</li>
<li><strong>예측</strong>: 레코드(튜플)의 <strong>연속형 속성</strong>의 값을 맞힘(카드 회원 가입정보로 연 매출액 알아맞히기)</li>
</ul>
</li>
</ul>
</li>
<li><p>분류 모델링</p>
<ul>
<li>신용평가모형(우량, 불량)</li>
<li>사기방지모형(사기, 정상)</li>
<li>이탈모형(이탈, 유지)</li>
<li>고객세분화(VVIP, VIP, GOLD, SILVER, BRONZE)</li>
</ul>
</li>
<li><p>분류 기법</p>
<ul>
<li>회귀분석, 로지스틱 회귀분석</li>
<li>의사결정나무, CART, C5.0</li>
<li>베이지안 분류</li>
<li>인공신경망</li>
<li>지지도벡터기계</li>
<li>k 최근접 이웃</li>
<li>규칙기반의 분류와 사례기반추록</li>
</ul>
</li>
</ul>
<h3 id="2-로지스틱-회귀분석-Logistic-Regression"><a href="#2-로지스틱-회귀분석-Logistic-Regression" class="headerlink" title="2. 로지스틱 회귀분석(Logistic Regression)"></a>2. 로지스틱 회귀분석(Logistic Regression)</h3><ul>
<li><p><strong>반응변수가 범주형인 경우</strong>에 적용되는 회귀분석모형</p>
</li>
<li><p>새로운 설명변수(또는 예측변수)가 주어질 때, 반응변수의 각 범주(또는 집단)에 속할 확률이 얼마인지 추정(예측모형)하여, 추정 확률을 기준치에 따라 분류하는 목적(분류모형)</p>
</li>
<li><p><strong>사후확률</strong>(Posterior Probability): 모형의 적합을 통해 추정된 확률</p>
</li>
<li><p>exp(β<del>1</del>): 나머지 변수가 주어질 때, x<del>1</del>이 한 단위 증가할 때마다 성공(Y=1)의 오즈가 몇 배 증가하는지 나타내는 값</p>
</li>
<li><p>표준 로지스틱 분포의 누적함수로 성공 확률을 추정</p>
</li>
<li><p>선형회귀분석 vs 로지스틱 회귀분석</p>
<table>
<thead>
<tr>
<th>목적</th>
<th>선형회귀분석</th>
<th>로지스틱 회귀분석</th>
</tr>
</thead>
<tbody><tr>
<td>종속변수</td>
<td>연속형 변수</td>
<td>(0, 1)</td>
</tr>
<tr>
<td>계수 추정법</td>
<td>최소제곱법</td>
<td>최대우도추정법</td>
</tr>
<tr>
<td>모형 검정</td>
<td>F-검정, T-검정</td>
<td>카이제곱 검정(x^2^-test)</td>
</tr>
</tbody></table>
</li>
<li><p><strong>glm() 함수</strong>를 활용하여 로지스틱 회귀분석을 실행</p>
</li>
</ul>
<h3 id="3-의사결정나무"><a href="#3-의사결정나무" class="headerlink" title="3. 의사결정나무"></a>3. 의사결정나무</h3><ul>
<li><p>정의</p>
<ul>
<li>분류함수를 의사결정 규칙으로 이뤄진 나무 모양으로 그리는 방법</li>
<li>연속적으로 발생하는 의사결정 문제를 시각화</li>
<li>계산결과가 의사결정나무에 직접적으로 나타나서 해석이 간편함</li>
<li>주어진 입력값에 대해 출력값을 예측하는 모형 → 분류나무와 회귀나무 모형</li>
</ul>
</li>
<li><p>예측력과 해석력</p>
</li>
<li><p>의사결정나무의 활용</p>
<ol>
<li><p>세분화</p>
<ul>
<li>데이터를 비슷한 특성을 갖는 몇 개 그룹으로 분할해 그룹별 특성을 발견하는 것</li>
</ul>
</li>
<li><p>분류</p>
<ul>
<li>여러 예측변수에 근거해 관측개체의 목표변수 범주를 몇 개 등급으로 분류하고자 하는 경우에 사용</li>
</ul>
</li>
<li><p>예측</p>
<ul>
<li>자료에서 규칙을 찾고 이를 이용해 미래 사건을 예측하고자 하는 경우에 사용</li>
</ul>
</li>
<li><p>차원축소 및 변수선택</p>
<ul>
<li>많은 예측변수 중 목표변수에 큰 영향을 미치는 변수를 골라내고자 하는 경우에 사용</li>
</ul>
</li>
<li><p>교호작용효과의 파악</p>
<ul>
<li>여러 개 예측변수를 결합해 목표변수에 작용하는 규칙을 파악하고자 하는 경우</li>
<li>범주의 병합 또는 연속형 변수의 이산화: 범주형 목표변수의 범주를 소수 몇 개로 병합하거나, 연속형 목표변수를 몇 개의 등급으로 이산화하고자 하는 경우</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>의사결정나무 특징</strong></p>
<ul>
<li><p>장점</p>
<ul>
<li>결과 설명 용이</li>
<li>모형 만들기가 계산적으로 복잡하지 않음</li>
<li>대용량 데이터에서도 빠르게 만들 수 있음</li>
<li>비정상 잡음 데이터도 민감함 없이 분류 가능</li>
<li>한 변수와 상관성 높은, 다른 불필요한 변수가 있어도 크게 영향 받지 않음</li>
<li>설명변수나 목표변수에 수치형변수와 범주형변수 모두 사용 가능</li>
<li>모형 분류 정확도가 높음</li>
</ul>
</li>
<li><p>단점</p>
<ul>
<li>새로운 자료에 대한 과대적합이 발생할 가능성이 높음</li>
<li>분류 경계선 부근 자료값에 대해 오차가 큼</li>
<li>설명변수 간 중요도 판단이 어려움</li>
</ul>
</li>
</ul>
</li>
<li><p>의사결정나무 분석 과정</p>
<ul>
<li>성장: 적절한 정지규칙을 만족하면 중단</li>
<li><strong>가지치기</strong></li>
<li>타당성 평가</li>
<li>해석 및 예측</li>
</ul>
</li>
<li><p>나무의 성장</p>
<ul>
<li><p>분리규칙(splitting rule)</p>
</li>
<li><p>분리기준(splitting criterion)</p>
<ul>
<li><p>이산형 목표변수</p>
<table>
<thead>
<tr>
<th>기준값</th>
<th>분리기준</th>
</tr>
</thead>
<tbody><tr>
<td>카이제곱 통계량 p값</td>
<td>P값이 가장 작은 예측변수와 그때의 최적분리에 의해 자식마디 형성</td>
</tr>
<tr>
<td>지니지수</td>
<td>지니지수를 감소시키는 예측변수와 그때의 최적분리에 의해 자식마디 선택</td>
</tr>
<tr>
<td>엔트로피 지수</td>
<td>엔트로피 지수가 가장 작은 예측변수와 그때의 최적분리에 의해 자식마디 형성</td>
</tr>
</tbody></table>
</li>
<li><p>연속형 목표변수</p>
<table>
<thead>
<tr>
<th>기준값</th>
<th>분리기준</th>
</tr>
</thead>
<tbody><tr>
<td>분산분석에서 F통계량</td>
<td>P값이 가장 작은 예측변수와 그때의 최적분리에 의해 자식마디 형성</td>
</tr>
<tr>
<td>분산의 감소량</td>
<td>분산 감소량을 최대화하는 기준의 최적분리에 의해 자식마디 형성</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>정지규칙</p>
<ul>
<li>더이상 분리가 일어나지 않고 현재 마디가 끝마디가 되도록 하는 규칙</li>
<li>정지기준: 의사결정나무 깊이를 지정, 끝마디의 레코드 수의 최소 개수를 지정</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>나무의 가지치기</strong>(Pruning)</p>
<ul>
<li>너무 큰 나무모형은 자료를 과대적합, 너무 작은 나무모형은 과소적합할 위험</li>
<li>나무 크기를 모형 복잡도로 볼 수 있으며, 최적 나무 크기는 자료로부터 추정하게 됨</li>
<li>일반적으로 사용되는 방법은 마디에 속하는 자료가 일정 수(가령 5) 이하일 때 분할을 정지</li>
<li>비용 - 복잡도 가지치기를 이용하여 성장시킨 나무를 가지치기하게 됨</li>
</ul>
</li>
</ul>
<h3 id="4-불순도의-여러-가지-측도"><a href="#4-불순도의-여러-가지-측도" class="headerlink" title="4. 불순도의 여러 가지 측도"></a>4. 불순도의 여러 가지 측도</h3><ul>
<li><p>목표변수가 범주형 변수인 의사결정나무 분류규칙을 선택</p>
<ol>
<li><p>카이제곱 통계량</p>
<ul>
<li>각 셀에 대한 ((실제도수 - 기대도수)의 제곱 / 기대도수) 합으로 구할 수 있음</li>
<li>기대도수 = 열의 합계 x 합의 합계 / 전체합계</li>
</ul>
</li>
<li><p><strong>지니지수</strong></p>
<ul>
<li>노드의 불순도를 나타내는 값</li>
<li>지니지수 값이 클수록 이질적이며 순수도가 낮다고 볼 수 있음</li>
</ul>
</li>
<li><p><strong>엔트로피 지수</strong></p>
<ul>
<li>열역학에서 쓰는 개념으로 무질서 정도에 대한 측도</li>
<li>엔트로피 지수 값이 클수록 순수도가 낮다고 볼 수 있음</li>
<li>엔트로피 지수가 가장 작은 예측변수와 이때의 최적분리 규칙에 의해 자식마디 형성</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5-의사결정나무-알고리즘"><a href="#5-의사결정나무-알고리즘" class="headerlink" title="5. 의사결정나무 알고리즘"></a>5. 의사결정나무 알고리즘</h3><ul>
<li><p>CART</p>
<ul>
<li>불순도의 측도로 출력변수가 범주형일 경우 지니지수를 이용, 연속형인 경우 분산을 이용한 이진분리 사용</li>
<li>개별 입력변수뿐 아니라 입력변수의 선형결합 중에서 최적의 분리를 찾을 수 있음</li>
</ul>
</li>
<li><p>C4.5와 C5.0</p>
<ul>
<li>CART와는 다르게 각 마디에서 다지분리가 가능</li>
<li>범주형 입력변수에 대하여는 범주 수만큼 분리가 일어남</li>
<li>불순도의 측도로는 엔트로피지수 사용</li>
</ul>
</li>
<li><p>CHAID</p>
<ul>
<li>가지치기 하지 않고 적당한 크기에서 나무모형의 성장을 중지</li>
<li><strong>입력변수가 반드시 범주형 변수여야 함</strong></li>
<li>불순도 측도로는 카이제곱 통계량 사용</li>
</ul>
</li>
</ul>
<h2 id="3절-앙상블-분석"><a href="#3절-앙상블-분석" class="headerlink" title="3절. 앙상블 분석"></a>3절. 앙상블 분석</h2><ul>
<li><p>앙상블</p>
<ul>
<li>주어진 자료로부터 여러 개 예측모형을 만든 후, 조합하여 하나의 최종 예측 모형을 만드는 방법</li>
<li>다중 모델 조합, 분류기 조합</li>
</ul>
</li>
<li><p>학습방법의 불안정성</p>
<ul>
<li>학습자료의 작은 변화에 의해 예측모형이 크게 변하는 경우, 그 학습방법은 불안정함</li>
<li>가장 안정적인 방법<ul>
<li>1-nearest neighbor: 가장 가까운 자료만 변하지 않으면 예측모형 변하지 않음</li>
<li>선형회귀모형: 최소제곱법으로 추정해 모형 결정</li>
</ul>
</li>
<li>가장 불안정한 방법: 의사결정나무</li>
</ul>
</li>
<li><p>앙상블 기법의 종류</p>
<ol>
<li><p><strong>배깅</strong></p>
<ul>
<li>주어진 자료에서 여러 개의 붓스트랩 자료를 생성하고 각 붓스트랩 자료에 예측모형을 만든 후 결합하여 최종 예측모형을 만드는 방법</li>
<li>붓스트랩(bootstrap): 주어진 자료에서 동일한 크기 표본을 랜덤 복원추출로 뽑은 자료</li>
<li>보팅(voting): 여러 개 모형으로부터 산출된 결과를 다수결에 의해 최종 결과를 선정하는 과정</li>
<li>배깅에서는 가지치기를 하지 않고 최대로 성장한 의사결정나무를 활용</li>
<li>훈련자료 모집단의 분포를 모르기 때문에 실제 문제에서는 평균예측모형을 구할 수 없음 → 훈련자료를 모집단으로 생각하고 평균예측모형을 구하여 분산을 줄이고 예측력을 향상시킬 수 있음</li>
</ul>
</li>
<li><p><strong>부스팅</strong></p>
<ul>
<li>예측력 약한 모형을 결합하여 강한 예측모형을 만드는 방법</li>
<li>훈련오차를 빠르고 쉽게 줄일 수 있음</li>
<li>배깅에 비해 많은 경우의 예측오차가 향상</li>
<li>Adaboost: 이진분류 문제에서 랜덤 분류기보다 조금 더 좋은 분류기 n개에 가중치를 설정하고 n개 분류기를 결합하여 최종 분류기 만드는 방법(단, 가중치 합은 1)</li>
</ul>
</li>
<li><p><strong>랜덤 포레스트</strong>(random forest)</p>
<ul>
<li>분산이 크다는 의사결정나무 특징을 고려하여 배깅과 부스팅보다 더 많은 무작위성을 줌</li>
<li>약한 학습기를 생성한 후, 이를 선형 결합하여 최종 학습기를 만드는 방법</li>
<li>랜덤한 forest에는 많은 트리가 생성됨</li>
<li>정확도 측면에서 좋은 성과</li>
<li>이론적 설명이나 최종 결과 해석이 어렵지만, 예측력이 매우 높음</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4절-인공신경망-분석"><a href="#4절-인공신경망-분석" class="headerlink" title="4절. 인공신경망 분석"></a>4절. 인공신경망 분석</h2><h3 id="1-인공신경망-분석-ANN"><a href="#1-인공신경망-분석-ANN" class="headerlink" title="1. 인공신경망 분석(ANN)"></a>1. 인공신경망 분석(ANN)</h3><ul>
<li><p>인공신경망이란?</p>
<ul>
<li>인간 뇌를 기반으로 한 추론 모델</li>
<li>뉴런: 기본적인 정보처리 단위</li>
</ul>
</li>
<li><p>인간의 뇌를 형상화한 인공신경망</p>
<ul>
<li><p>인간 뇌의 특징</p>
<ul>
<li>100억 개 뉴런과 6조 개 시냅스의 결합체</li>
<li>인간의 뇌: 컴퓨터보다 빠르고, 복잡하고, 비선형적, 병렬적인 정보 처리 시스템</li>
<li>적응성에 따라 잘못된 답에 대한 뉴런 사이 연결은 약화되고, 올바른 답에 대한 연결이 강화됨</li>
</ul>
</li>
<li><p>인간 뇌 모델링</p>
<ul>
<li>뉴런은 가중치 있는 링크로 연결되어 있음</li>
<li>뉴런은 <strong>여러 입력 신호를 받으나, 출력 신호는 하나만 생성</strong>함</li>
</ul>
</li>
</ul>
</li>
<li><p>인공신경망의 학습</p>
<ul>
<li>신경망은 <strong>가중치를 반복적으로 조정하며 학습</strong></li>
<li>뉴런은 링크로 연결되어 있고, 각 링크에는 수치적인 가중치가 있음</li>
<li>신경망 가중치를 초기화 → 훈련 데이터로 가중치 갱신 → 신경망 구조 선택 → 활용할 학습 알고리즘 결정 → 신경망 훈련</li>
</ul>
</li>
<li><p>인공신경망 특징</p>
<ol>
<li><p>구조</p>
<ul>
<li>입력 링크에서 여러 신호를 받아 새로운 활성화 수준을 계산하고 출력 링크로 출력 신호를 보냄</li>
<li>입력 신호는 미가공 데이터 또는 다른 뉴런의 출력이 될 수 있음</li>
<li>출력 신호는 문제의 최종적인 해(solution)가 되거나 다른 뉴런에 입력될 수 있음</li>
</ul>
</li>
<li><p>뉴런의 계산</p>
<ul>
<li>뉴런은 전이함수, 즉 활성화 함수를 사용</li>
<li>활성화 함수를 이용해 출력을 결정하며, 입력신호의 가중치 합을 계산하여 임계값과 비교</li>
<li><strong>가중치 합이 임계값보다 작으면 뉴련의 출력은 -1, 같거나 크면 +1을 출력</strong></li>
</ul>
</li>
<li><p>뉴런의 활성화 함수</p>
<ul>
<li><strong>시그모이드 함수</strong>: 로지스틱 회귀분석과 유사하며 0~1의 확률값을 가짐</li>
<li><strong>softmax 함수</strong>: 표준화지수 함수로도 불리며, 출력값이 여러 개로 주어지고 목표치가 다범주인 경우 각 범주에 속할 사후확률을 제공하는 함수</li>
<li><strong>relu 함수</strong>: 입력값이 0 이하는 0, 0 이상은 x값을 가지는 함수, 최근 딥러닝에서 많이 활용</li>
</ul>
</li>
<li><p>단일 뉴런의 학습(단층 퍼셉트론)</p>
<ul>
<li>퍼셉트론은 선형 결합기와 하드 리미터로 구성</li>
<li>초평면(hyperplane)은 n차원 공간을 두 개의 영역으로 나눔</li>
<li>초평면을 선형 분리 함수로 정의</li>
</ul>
</li>
</ol>
</li>
<li><p>신경망 모형 구축 시 고려사항</p>
<ol>
<li><p>입력변수</p>
<ul>
<li><p>신경망 모형은 복잡성으로 인해 입력 자료 선택에 매우 민감</p>
</li>
<li><p>입력변수가 범주형 또는 연속형 변수일 때 아래 조건이 신경망 모형에 적합</p>
<ul>
<li><strong>범주형 변수</strong>: 모든 범주에서 일정 빈도 이상의 값을 갖고 각 범주 빈도가 일정할 때</li>
<li><strong>연속형 변수</strong>: 입력변수 값의 범위가 변수간의 큰 차이가 없을 때</li>
</ul>
</li>
<li><p>연속형 변수의 경우, 분포가 평균을 중심으로 대칭이 아니면 좋지 않은 결과를 도출하므로 아래 방법을 활용</p>
<ul>
<li><strong>변환</strong>: 고객 소득(대부분 평균 미만, 특정 고객 소득이 매우 큰) 로그 변환</li>
<li><strong>범주화</strong>: 각 범주 빈도가 비슷해지도록 설정</li>
</ul>
</li>
<li><p>범주형 변수의 경우 가변수화하여 적용</p>
</li>
<li><p>가능한 경우 모든 범주형 변수는 같은 범위를 갖도록 가변수화 하는 것이 좋음</p>
</li>
</ul>
</li>
<li><p>가중치의 초기값과 다중 최소값 문제</p>
<ul>
<li>역전파 알고리즘은 초기값에 따라 결과가 많이 달라짐 → 초기값 선택은 매우 중요한 문제</li>
<li>가중치가 0이면 시그모이드 함수는 선형, 신경망 모형은 근사적으로 선형모형이 됨</li>
<li>일반적으로 초기값은 0 근처로 랜덤하게 선택 → 초기 모형은 선형모형에 가깝고, 가중치 값이 증가할수록 비선형모형이 됨</li>
<li>참고: 초기값이 0이면 반복해도 값이 전혀 변하지 않고, 너무 크면 좋지 않은 해를 주는 문제점 내포</li>
</ul>
</li>
<li><p>학습모드</p>
<ul>
<li><p>온라인 학습모드(online learning mode)</p>
<ul>
<li>각 관측값을 순차적으로 하나씩 신경망에 투입하여 가중치 추정값이 매번 바뀜</li>
<li>일반적으로 속도가 빠름, 훈련자료에 유사값 많은 경우 그 차이가 더 두드러짐</li>
<li>훈련자료가 비정상성과 같이 특이한 성질을 가진 경우가 좋음</li>
<li>국소최솟값에서 벗어나기 더 쉬움</li>
</ul>
</li>
<li><p>확률적 학습모드(probabilistic learning mode)</p>
<ul>
<li>온라인 학습모드와 같으나, 신경망에 투입되는 관측값의 순서가 랜덤</li>
</ul>
</li>
<li><p>배치 학습모드(batch learning mode)</p>
<ul>
<li>전체 훈련자료를 동시에 신경망에 투입</li>
</ul>
</li>
<li><p>은닉층(hidden layer)과 은닉노드(hidden node)의 수</p>
<ul>
<li>신경망을 적용 시, 가장 중요한 부분: 모형의 선택</li>
<li>은닉층과 은닉노드가 <strong>많으면 가중치가 많아져서 과대 적합 문제</strong> 발생</li>
<li>은닉층과 은닉노드가 <strong>적으면 과소적합 문제</strong> 발생</li>
<li>은닉층 수가 하나인 신경망: 범용 근사자 → 모든 매끄러운 함수 근사적 표현 가능</li>
<li>은닉노드 수는 적절히 큰 값으로 놓고 가중치를 감소시키며 적용하는 것이 좋음</li>
</ul>
</li>
<li><p>과대 적합 문제</p>
<ul>
<li>신경망에서는 많은 가중치를 추정해야 하므로 과대적합 문제가 빈번히 발생</li>
<li>알고리즘 조기종료와 가중치 감소 기법으로 해결할 수 있음</li>
<li>모형 적합 과정에서 검증오차가 증가하면 반복을 중지하는 조기종료 시행</li>
<li>선형모형의 능형회귀와 유사한 가중치 감소라는 벌점화 기법 활용</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="5절-군집분석"><a href="#5절-군집분석" class="headerlink" title="5절. 군집분석"></a>5절. 군집분석</h2><h3 id="1-군집분석"><a href="#1-군집분석" class="headerlink" title="1. 군집분석"></a>1. 군집분석</h3><ul>
<li><p>개요</p>
<ul>
<li>각 객체(대상)의 유사성을 측정하여 유사성이 높은 대상 집단을 분류하고, 군집에 속한 객체들의 유사성과 서로 다른 군집에 속한 객체간 상이성을 규명하는 분석 방법</li>
<li>특성에 따라 고객을 여러 개의 배타적인 집단으로 나눔</li>
<li>결과는 구체적인 군집분석 방법에 따라 차이 날 수 있음</li>
<li>군집 개수나 구조에 관한 가정 없이 데이터 사이 거리를 기준으로 군집화 유도</li>
<li>마케팅 조사에서 소비자의 상품구매행동이나 life style에 따른 소비자군을 분류하여 시장 전략 수립에 활용</li>
</ul>
</li>
<li><p>특징</p>
<ul>
<li><p>요인분석과의 차이</p>
<ul>
<li>요인분석은 유사한 변수를 함께 묶는 목적</li>
</ul>
</li>
<li><p>판별분석과의 차이</p>
<ul>
<li>판별분석은 사전에 집단이 나뉜 자료를 통해 새로운 데이터를 기존 집단에 할당하는 것이 목적</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-거리"><a href="#2-거리" class="headerlink" title="2. 거리"></a>2. 거리</h3><ul>
<li><p>군집분석에서는 관측 데이터 간 유사성이나 근접성을 측정해 어느 군집으로 묶을 수 있는지 판단해야 함  </p>
</li>
<li><p>아래 각 거리 식은 교재 참고</p>
</li>
<li><p><strong>연속형 변수의 경우</strong></p>
<ul>
<li><p><strong>유클리디안 거리</strong></p>
<ul>
<li>데이터 유사성 측정할 때 많이 사용하는 거리, 통계적 개념 내포 x → 변수 산포 정도가 감안되지 않음</li>
</ul>
</li>
<li><p>표준화 거리</p>
<ul>
<li>해당변수 표준편차로 척도 변환 후, 유클리드안 거리를 계산하는 방법</li>
<li>표준화하게 되면 척도 차이, 분산 차이로 인한 왜곡을 피할 수 있음</li>
</ul>
</li>
<li><p><strong>마할라노비스 거리</strong></p>
<ul>
<li>통계적 개념이 포함된 거리이며 변수들의 산포를 고려하여 이를 표준화한 거리</li>
<li>두 백터 사이 거리를 산포를 의미하는 표본공분산으로 나눠주어야 함</li>
<li>그룹에 관한 사전 지식 없이는 표본공분산S를 계산할 수 없으므로 사용하기 곤란</li>
</ul>
</li>
<li><p>체비셰프 거리</p>
</li>
<li><p><strong>맨하탄 거리</strong></p>
<ul>
<li>유클리디안 거리와 함께 가장 많이 사용되는 거리</li>
<li>맨하탄 도시 건물에서 건물을 가기 위한 최단 거리를 구하기 위해 고안</li>
</ul>
</li>
<li><p>캔버라 거리</p>
</li>
<li><p>민코우스키 거리</p>
<ul>
<li>맨하탄 거리와 유클리디안 거리를 한 번에 표현한 공식</li>
<li>L1 거리(맨하탄거리), L2 거리(유클리디안 거리)라고 불림</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>범주형 변수의 경우</strong></p>
<ul>
<li>자카드 거리</li>
<li>자카드 계수</li>
<li>코사인 거리<ul>
<li>유사도 기준으로 문서를 분류/그룹핑할 때 유용하게 사용</li>
</ul>
</li>
<li>코사인 유사도<ul>
<li>두 개체 백터 내적의 코사인 값을 이용하여 측정된 백터간의 유사한 정도</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-계층적-군집분석"><a href="#3-계층적-군집분석" class="headerlink" title="3. 계층적 군집분석"></a>3. 계층적 군집분석</h3><ul>
<li>n개의 군집으로 시작해 점차 군집 개수를 줄여가는 방법</li>
<li>계층적 군집을 형성하는 방법에는 합병형 방법과 분리형 방법이 있음</li>
</ul>
<ol>
<li><p><strong>최단연결법(single linkage, nearest neighbor)</strong></p>
<ul>
<li>n*n 거리행렬에서 거리가 가장 가까운 데이터를 묶어서 군집 형성</li>
<li>군집과 군집 또는 데이터와의 거리 계산 시, 최단거리(min)를 거리로 계산하여 거리행렬 수정 진행</li>
<li>수정된 거리행렬에서 거리가 가까운 데이터/군집을 새로운 군집으로 형성</li>
</ul>
</li>
<li><p><strong>최장연결법(complete linkage, farthest neighbor)</strong></p>
<ul>
<li>군집과 군집/데이터와 거리 계산 시, 최장거리(max)를 거리로 계산하여 거리행렬을 수정하는 방법</li>
</ul>
</li>
<li><p><strong>평균연결법(average linkage)</strong></p>
<ul>
<li>군집과 군집/데이터와 거리 계산 시, 평균(mean)을 거리로 계산하여 거리행렬을 수정하는 방법</li>
</ul>
</li>
<li><p><strong>와드연결법(ward linkage)</strong></p>
<ul>
<li>군집 내 편차들의 제곱합을 고려한 방법</li>
<li>군집간 정보 손실 최소화를 위해 군집화 진행</li>
</ul>
</li>
<li><p><strong>군집화</strong></p>
<ul>
<li>거리행렬을 통해 가장 가까운 거리의 객체들간 관계를 규명하고 덴드로그램을 그림</li>
<li><strong>덴드로그램</strong>을 보고 군집 개수를 변화해가며 적절한 군집 수 선정</li>
<li>군집 수는 분석 목적에 따라 선정할 수 있지만, 5개 이상은 잘 활용하지 않음</li>
<li>군집화 단계<ul>
<li>거리행렬을 기준으로 덴드로그램을 그림</li>
<li>덴드로그램 최상단부터 세로축 개수에 따라 가로선을 그어 군집 개수 선택</li>
<li>각 객체 구성을 고려하여 적절한 군집 수 선정</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-비계층적-군집분석"><a href="#4-비계층적-군집분석" class="headerlink" title="4. 비계층적 군집분석"></a>4. 비계층적 군집분석</h3><p>n개의 개체를 g개의 군집으로 나눌 수 있는 모든 가능한 방법을 점검해 최적화한 군집을 형성하는 것</p>
<ul>
<li><p><strong>K-평균 군집분석</strong></p>
<ul>
<li>주어진 데이터를 k개의 클러스터로 묶는 알고리즘</li>
<li>각 클러스터와 거리 차이 분산을 최소화하는 방식으로 동작</li>
</ul>
</li>
<li><p>K-평균 군집분석 과정</p>
<ul>
<li>원하는 군집 개수와 초기 값(seed)을 정해 seed 중심으로 군집 형성</li>
<li>각 데이터를 거리가 가장 가까운 seed가 있는 군집으로 분류</li>
<li>각 군집의 seed 값을 다시 계산</li>
<li>모든 개체가 군집으로 할당될 때까지 위 과정 반복</li>
</ul>
</li>
<li><p>K-평균 군집분석 특징</p>
<ul>
<li>거리 계산을 통해 군집화가 이루어지므로 <strong>연속형 변수에 활용 가능</strong></li>
<li>K개의 <strong>초기 중심값은 임의 선택 가능</strong>하며 가급적이면 멀리 떨어지는 것이 바람직함</li>
<li>초기 중심값을 임의로 선택할 때, 일렬로 선택하면 군집이 혼합되지 않고 층으로 나눠질 수 있어 주의해야 함</li>
<li><strong>초기 중심값 선정에 따라 결과가 달라질 수 있음</strong></li>
<li>초기 중심으로부터 오차 제곱합을 최소화하는 방향으로 군집이 형성되는 <strong>탐욕적(greedy) 알고리즘</strong>이므로 안정된 군집은 보장하나 최적이라는 보장은 없음</li>
</ul>
<table>
<thead>
<tr>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>알고리즘 단순, 수행 빠름 → 분석 방법 적용 용이, 계층적 군집분석에 비해 많은 양의 데이터를 다룰 수 있음, 내부 구조에 대한 사전정보 없이 의미 있는 자료구조 찾을 수 있음, 다양한 형태 데이터에 적용 가능</td>
<td>군집 수, 가중치와 거리 정의가 어려움, 사전에 주어진 목적이 없으므로 결과 해석이 어려움, 잡음이나 이상값의 영향을 많이 받음, 볼록한 형태가 아닌 군집이 존재할 경우에는 성능 떨어짐, 초기 군집 수 결정이 어려움</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="5-혼합-분포-군집-mixture-distribution-clustering"><a href="#5-혼합-분포-군집-mixture-distribution-clustering" class="headerlink" title="5. 혼합 분포 군집(mixture distribution clustering)"></a>5. 혼합 분포 군집(mixture distribution clustering)</h3><ul>
<li><p>개요</p>
<ul>
<li>모형 기반 군집 방법</li>
<li>데이터가 k개의 모수적 모형의 가중합으로 표현되는 모집단 모형으로부터 나왔다는 가정 하에서 모수와 함께 가중치를 자료로부터 추정하는 방법 사용</li>
<li>K개의 각 모형은 군집을 의미, 각 데이터는 추정된 k개의 모형 중 어느 모형으로부터 나왔을 확률이 높은지에 따라 군집 분류가 이루어짐</li>
<li>혼합모형에서 모수와 가중치의 추정(최대가능도 추정)에는 EM 알고리즘이 사용됨</li>
</ul>
</li>
<li><p>혼합 분포모형으로 설명할 수 있는 데이터 형태</p>
<ul>
<li>자료의 분포형태가 다봉형의 형태</li>
<li>교재 참고</li>
</ul>
</li>
<li><p><strong>EM(Expectation-Maximization) 알고리즘</strong>의 진행 과정</p>
<ul>
<li>각 자료에 대해 Z의 조건부분포(어느 집단에 속할지에 관한)로부터 조건부 기댓값을 구할 수 있음</li>
<li>관측변수 X와 잠재변수 Z를 포함하는 (X,Z)에 대한 로그-가능도함수에 Z 대신 상수값인 Z의 조건부 기댓값을 대입하면 로그-가능도함수를 최대로 하는 모수를 쉽게 찾을 수 있음, (M-단계) 갱신된 모수 추정치에 위 과정을 반복하면 수렴하는 값을 얻게 되고 이는 최대 가능도 추정치로 사용될 수 있음</li>
<li>E-단계: 잠재변수 Z의 기대치 계산</li>
<li>M-단계: 잠재변수 Z의 기대치를 이용하여 파라미터 추정</li>
</ul>
</li>
<li><p>혼합 분포 군집모형의 특징</p>
<ul>
<li>K-평균군집 절차와 유사하지만 <strong>확률분포를 도입하여 군집 수행</strong></li>
<li>군집을 몇 개의 모수로 표현할 수 있으며, 서로 다른 크기나 모양의 군집을 찾을 수 있음</li>
<li>EM 알고리즘을 이용한 모수 추정에서 데이터가 커지면 수렴에 시간이 걸릴 수 있음</li>
<li>군집 크기가 너무 작으면 추정 정도가 떨어지거나 어려울 수 있음</li>
<li>K-평균군집과 같이 <strong>이상치 자료에 민감</strong> → 사전 조치 필요</li>
</ul>
</li>
</ul>
<h3 id="6-SOM-Self-Organizing-Map"><a href="#6-SOM-Self-Organizing-Map" class="headerlink" title="6. SOM(Self Organizing Map)"></a>6. SOM(Self Organizing Map)</h3><ul>
<li><p>SOM</p>
<ul>
<li>자가조직화지도 알고리즘은 코호넨에 의해 제시, 개발 → 코호넨 맵(Ko-honen Maps)이라고도 알려져 있음</li>
<li><strong>SOM은 비지도 신경망으로 고차원의 데이터를 이해하기 쉬운 저차원의 뉴런으로 정렬</strong>하여 지도 형태로 형상화</li>
<li>형상화는 입력 변수의 위치 관계를 그대로 보존한다는 특징이 있음 → 실제 공간의 입력변수가 가까이 있으면 지도상에도 가까운 위치에 있음</li>
</ul>
</li>
<li><p>구성</p>
<ul>
<li>SOM 모델은 두 개의 인공신경망 층으로 구성되어 있음</li>
</ul>
<ol>
<li><p><strong>입력층(Input layer, 입력벡터를 받는 층)</strong></p>
<ul>
<li>입력변수 개수와 뉴런 수가 동일하게 존재</li>
<li>입력층 자료는 학습을 통해 경쟁층에 정렬되는데, 이를 지도라 부름</li>
<li>입력층에 있는 각각의 뉴런은 경쟁층에 있는 각각의 뉴런과 완전 연결(fully connected)되어 있음</li>
</ul>
</li>
<li><p><strong>경쟁층(Competitive layer, 2차원 격자(grid)로 구성된 층)</strong></p>
<ul>
<li>입력백터 특성에 따라 백터가 한 점으로 클러스터링 되는 층</li>
<li>SOM은 경쟁 학습으로 각각 뉴런이 입력백터와 얼마나 가까운가를 계산하여 연결 강도(connection weight)를 반복적으로 재조정하여 학습</li>
<li>위 과정을 거치며 연결강도는 입력 패턴과 가장 유사한 경쟁층 뉴런이 승자가 됨</li>
<li>입력층 표본 백터에 가장 가까운 프로토타입 백터를 BMU(Best-Matching-Unit)라고 하며, 코호넨 승자 독점의 학습 규칙에 따라 위상학적 이웃(topological neighbors)에 대한 연결 강도를 조정</li>
<li>승자 독식 구조로 인해 경쟁층에는 승자 뉴런만이 나타나며, 승자와 유사한 연결 강도를 갖는 입력 패턴이 동일한 경쟁 뉴런으로 배열됨</li>
</ul>
</li>
</ol>
</li>
<li><p>특징</p>
<ul>
<li>고차원의 데이터를 저차원의 지도 형태로 형상화 → 시각적으로 이해가 쉬움</li>
<li>입력변수의 위치 관계를 그대로 보존하기 때문에 실제 데이터가 유사하면 지도상에서 가깝게 표현 → 패턴 발견, 이미지 분석 등에서 뛰어난 성능을 보임</li>
<li>역전파(Back Propagation): 알고리즘 등을 이용하는 인공신경망과 달리 단 하나의 전방 패스를 사용함으로써 속도가 매우 빠름 → 실시간 학습처리를 할 수 있는 모형</li>
</ul>
</li>
<li><p>SOM과 신경망 모형의 차이점</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>구분</th>
<th>신경망 모형</th>
<th>SOM</th>
</tr>
</thead>
<tbody><tr>
<td>학습 방법</td>
<td>오차역전파법</td>
<td>경쟁학습방법</td>
</tr>
<tr>
<td>구성</td>
<td>입력층, 은닉층, 출력층</td>
<td>입력층, 2차원 격자 형태의 경쟁층</td>
</tr>
<tr>
<td>기계 학습 방법의 분류</td>
<td>지도학습(Supervised Learning)</td>
<td>비지도학습(Unsupervised Learning)</td>
</tr>
</tbody></table>
<p>###7. 최신 군집분석 기법</p>
<ul>
<li>교재 참고</li>
</ul>
<h2 id="6절-연관분석"><a href="#6절-연관분석" class="headerlink" title="6절. 연관분석"></a>6절. 연관분석</h2><h3 id="1-연관규칙"><a href="#1-연관규칙" class="headerlink" title="1. 연관규칙"></a>1. 연관규칙</h3><ul>
<li><p>**연관규칙분석(Association Analysis)**의 개념</p>
<ul>
<li>흔히 <strong>장바구니분석</strong> 또는 <strong>서열분석</strong>이라고 불림</li>
<li>기업 데이터베이스에서 상품의 구매, 서비스 등 일련의 거래 또는 사건 사이 규칙을 발견하기 위해 적용</li>
<li>장바구니 분석: 장바구니에 무엇이 같이 들어 있는지에 관한 분석</li>
<li>서열 분석: ‘A를 구매한 다음에 B를 구매한다’</li>
</ul>
</li>
<li><p>연관규칙의 형태</p>
<ul>
<li>조건과 반응의 형태(if-then)로 이루어져 있음<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(Item set A) → (Item set B)</span><br><span class="line">If A then B: 만일 A가 일어나면 B가 일어난다.</span><br><span class="line"></span><br><span class="line">- 아메리카노를 마시는 손님 중 10%가 브라우니를 먹는다.</span><br><span class="line">- 샌드위치를 먹는 고객의 30%가 탄산수를 함께 마신다.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>연관규칙의 측도</p>
<ul>
<li>산업 특성에 따라 지지도, 신뢰도, 향상도 값을 잘 보고 규칙을 선택해야 함</li>
</ul>
<ol>
<li><p><strong>지지도(support)</strong></p>
<ul>
<li>전체 거래 중 항목 A와 항목 B를 동시에 포함하는 거래의 비율</li>
<li>지지도 = P(A∩B) = $\frac{A와 B 동시에 포함된 거래 수}{전체 거래 수}$ = $\frac{A∩B}{전체}$</li>
</ul>
</li>
<li><p><strong>신뢰도(confidence)</strong></p>
<ul>
<li>항목 A를 포함한 거래 중에서 항목 A와 항목 B가 같이 포함될 확률 → 연관성 정도 파악 가능</li>
<li>신뢰도 = $\frac{P(A∩B)}{P(A)}$ = $\frac{A와 B 동시에 포함된 거래 수}{A 포함하는 거래 수}$ = $\frac{지지도}{P(A)}$</li>
</ul>
</li>
<li><p><strong>향상도(Lift)</strong></p>
<ul>
<li>A가 구매되지 않았을 때, 품목 B의 구매확률에 비해 A가 구매됐을 때 품목 B의 구매확률 증가 비</li>
<li>연관규칙 A → B는 품목 A와 품목 B의 구매가 서로 관련 없는 경우에 향상도가 1이 됨</li>
<li>향상도 = $\frac{P(B|A)}{P(B)}$ = $\frac{P(A∩B)}{P(A)P(B)}$ = $\frac{A와 B 동시에 포함된 거래 수}{A를 포함하는 거래 수 X B를 포함하는 거래 수}$ = $\frac{신뢰도}{P(B)}$</li>
</ul>
</li>
</ol>
</li>
<li><p>연관규칙의 절차</p>
<ul>
<li>최소 지지도보다 큰 집합만을 대상으로 높은 지지도를 갖는 품목 집합을 찾는 것</li>
<li>처음에는 5%로 잡고 규칙이 충분히 도출되는지 보고 다양하게 조절하여 시도</li>
<li>처음부터 너무 낮은 최소 지지도를 선정하는 것은 많은 리소스가 소모</li>
<li>절차<ul>
<li>최소 지지도 결정 → 품목 중 최소 지지도 넘는 품목 분류 → 2가지 품목 집합 생성 → 반복 수행해 빈발품목 집함 찾기</li>
</ul>
</li>
</ul>
</li>
<li><p>연관규칙의 장단점</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>조건 반응으로 표현되는 연관선 분석 결과를 쉽게 이해할 수 있음(탐색적 방법), 강력한 비목적성 분석기법으로 분석 방향이나 목적이 특별히 없는 경우 목적변수가 없어 유용하게 활용, 사용이 편리한 분석 데이터 형태로 거래 내용에 관한 데이터를 변환 없이 그 자체로 이용할 수 있는 간단한 자료 구조를 가짐, 분석을 위한 계산이 간단함</td>
<td>품목수가 증가하면 분석에 필요한 계산은 기하급수적으로 늘어남,세분화한 품목을 갖고 연관성 규칙을 찾으면 의미 없는 분석이 될 수 있음, 거래량 적은 품목은 당연히 포함된 거래수가 적을 것이고 규칙 발견 시 제외하기가 쉬움</td>
</tr>
</tbody></table>
<ul>
<li><strong>순차패턴(Sequence Analysis)</strong><ul>
<li>동시에 구매될 가능성이 큰 상품군을 찾는 연관성 분석에, 시간이라는 개념을 포함해 순차적으로 구매 가능성이 큰 상품군을 찾는 것</li>
<li>연관성분석에서의 데이터 형태에서 각각의 고객으로부터 발생한 구매시점에 대한 정보가 포함됨</li>
</ul>
</li>
</ul>
<h3 id="2-기존-연관성분석의-이슈"><a href="#2-기존-연관성분석의-이슈" class="headerlink" title="2. 기존 연관성분석의 이슈"></a>2. 기존 연관성분석의 이슈</h3><ul>
<li>대용량 데이터에 관한 연관성 분석 불가능</li>
<li>시간이 많이 걸리거나 기존 시스템에서 실행 시, 시스템 다운 현상 발생 가능</li>
</ul>
<h3 id="3-최근-연관성분성-동향"><a href="#3-최근-연관성분성-동향" class="headerlink" title="3. 최근 연관성분성 동향"></a>3. 최근 연관성분성 동향</h3><ul>
<li><p>1세대 알고리즘인 Apriori나 2세대인 FP-Growth에서 발전하여 3세대의 FPV를 이용해 메모리를 효율적으로 사용 → SKU 레벨인 연관성분석을 성공적으로 적용</p>
</li>
<li><p>거래내역에 포함된 모든 품목 개수가 n개일 때, 품목의 전체집합에서 추출할 수 있는 품목 부분집합 개수는 2^n^-1(공집합 제외)개, 가능한 모든 연관규칙 개서는 3^n^ - 2^n+1^ + 1개</p>
</li>
<li><p>Aprirori: 모든 가능한 품목 부분집합 개수를 줄이는 방식으로 작동</p>
</li>
<li><p>FP-Growth: 거래내역 안에 포함된 품목 개수를 줄여 비교하는 횟수를 줄이는 방식으로 작동</p>
</li>
<li><p><strong>Aprirori 알고리즘</strong></p>
<ul>
<li>빈발항목집합: 최소 지지도보다 큰 지지도 값을 갖는 품목 집합</li>
<li>모든 품목집합에 대한 지지도를 전부 계산하지 않고, 최소 지지도 이상의 빈발항목집합을 찾은 후 그것들에 대해서만 연관규칙을 계산하는 것</li>
<li>1994년에 발표된 알고리즘으로 구현과 이해가 쉬우나, 지지도 낮은 후보 집합 생성 시 아이템 개수가 많아지면 계산 복잡도가 증가하는 문제 발생</li>
</ul>
</li>
<li><p><strong>FP-Growth 알고리즘</strong></p>
<ul>
<li>후보 빈발항목집합을 생성하지 않고, FP-Tree(Frequent Pattern Tree)를 만든 후 분할정복 방식으로 Apriori 알고리즘보다 더 빠르게 빈발항목집합을 추출할 수 있는 방법</li>
<li>Apriori 알고리즘의 약점을 보안하기 위해 고안 → 데이터베이스 스캔 횟수가 작고 빠르게 분석 가능</li>
</ul>
</li>
</ul>
<h3 id="4-연관성분석-활용방안"><a href="#4-연관성분석-활용방안" class="headerlink" title="4. 연관성분석 활용방안"></a>4. 연관성분석 활용방안</h3><ul>
<li>장바구니 분석의 경우는 실시간 상품추천을 통한 교차판매에 응용</li>
<li>순차패턴 분석은 A를 구매한 사람인데 B를 구매하지 않은 경우, B를 추천하는 교차판매 캠페인에 사용</li>
</ul>
<h3 id="5-연관성분석-예제"><a href="#5-연관성분석-예제" class="headerlink" title="5. 연관성분석 예제"></a>5. 연관성분석 예제</h3><ul>
<li>교재 참고</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/17/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_2/" data-id="ckjqkgbar0034wkueb4h72mx9" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADSP%EC%9E%90%EA%B2%A9%EC%A6%9D/" rel="tag">ADSP자격증</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADsP/" rel="tag">ADsP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80/" rel="tag">데이터분석준전문가</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ADsP/Part03_데이터_분석_1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_1/">ADsP 자격증: Part03. 데이터 분석_1</a>
    </h1>
  

        <a href="/2020/11/16/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_1/" class="article-date">
  <time datetime="2020-11-15T15:00:00.000Z" itemprop="datePublished">2020-11-16</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>해당 자료는 <a target="_blank" rel="noopener" href="http://www.dataedu.kr/product/adsp-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D-%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80-2020-%EC%99%84%EC%A0%84%EA%B0%9C%EC%A0%95%ED%8C%90/">ADsP 데이터분석 준전문가 2020 완전 개정판</a> 요약본으로 저작권은 DATA EDU에 있습니다.</li>
</ul>
<h1 id="1장-데이터-분석-개요"><a href="#1장-데이터-분석-개요" class="headerlink" title="1장. 데이터 분석 개요"></a>1장. 데이터 분석 개요</h1><h2 id="1절-데이터-분석-기법의-이해"><a href="#1절-데이터-분석-기법의-이해" class="headerlink" title="1절. 데이터 분석 기법의 이해"></a>1절. 데이터 분석 기법의 이해</h2><h3 id="1-데이터-처리"><a href="#1-데이터-처리" class="headerlink" title="1. 데이터 처리"></a>1. 데이터 처리</h3><ul>
<li><p>데이터 분석</p>
<ul>
<li>통계 기반이나, 통계지식과 복잡한 가정이 상대적으로 적은 실용적인 분야  </li>
</ul>
</li>
<li><p>활용</p>
<ul>
<li>대기업은 데이터 웨어하우스(DW)와 데이터마트(DM)를 통해 분석 데이터를 가져와 사용</li>
<li>신규 시스템이나 DW에 포함되지 못한 자료는, 기존 운영 시스템(Legacy)나 스테이징 영역(staging area)과 ODS(Operational Data Store)에서 데이터를 가져와 DW에서 가져온 내용과 결합하여 활용 가능</li>
<li>단, 운영시스템에 직접 접근해 데이터를 활용하는 것은 매우 위험 → 스테이징 영역 데이터는 운영시스템에서 임시로 저장된 데이터기에 가급적 클린징 영역인 ODS에서 데이터 전처리를 하여 DW나 DM과 결합해 사용  </li>
</ul>
</li>
<li><p>최종 데이터 구조로 가공</p>
<ul>
<li><p><strong>데이터 마이닝 분류</strong></p>
<ul>
<li>분류값과 입력변수를 연관시켜 인구통계, 요약변수, 파생벽수 등 산출  </li>
</ul>
</li>
<li><p><strong>정형화된 패턴 처리</strong></p>
<ul>
<li>비정형 데이터나 소셜 데이터는 정형화된 패턴으로 처리해야 함</li>
</ul>
<ol>
<li><p><strong>비정형 데이터</strong></p>
<ul>
<li>DMBS에 저장됐다가 텍스트 마이닝을 거쳐 데이터 마트와 통합</li>
</ul>
</li>
<li><p><strong>관계형 데이터</strong></p>
<ul>
<li>DBMS에 저장되어 사회 신경망 분석을 거쳐 분석 결과 통계값이 마트와 통합되어 활용  </li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-시각화-시각화-그래프"><a href="#2-시각화-시각화-그래프" class="headerlink" title="2. 시각화(시각화 그래프)"></a>2. 시각화(시각화 그래프)</h3><ul>
<li>가장 낮은 수준의 분석이지만, 제대로 사용하면 복잡한 분석보다도 효율적</li>
<li>대용량 데이터를 다루는 빅데이터 분석에서 시각화는 필수</li>
<li>탐색적 분석을 할 때, 시각화는 필수</li>
<li>SNA 분석(사회연결망 분석)을 할 때, 자주 활용</li>
</ul>
<h3 id="3-공간분석-GIS"><a href="#3-공간분석-GIS" class="headerlink" title="3. 공간분석(GIS)"></a>3. 공간분석(GIS)</h3><ul>
<li><strong>공간분석(Spatial Analysis)</strong>: 공간적 차원과 관련된 속성을 시각화하는 분석</li>
<li>지도 위에 관련 속성을 생성하고 크기, 모양, 선, 굵기 등으로 구분하여 인사이트를 얻음</li>
</ul>
<h3 id="4-탐색적-자료-분석-EDA"><a href="#4-탐색적-자료-분석-EDA" class="headerlink" title="4. 탐색적 자료 분석(EDA)"></a>4. 탐색적 자료 분석(EDA)</h3><ul>
<li><p>탐색적 분석</p>
<ul>
<li>다양한 차원과 값을 조합하며 특이점이나 의미 있는 사실을 도출하여 분석의 최종 목적을 달성하는 과정</li>
<li>데이터의 특징과 내재하는 구조적 관계를 알아내기 위한 기법의 통칭</li>
</ul>
</li>
<li><p><strong>EDA의 4가지 주제</strong></p>
<ul>
<li><strong>저항성의 강조, 잔차 계산, 자료변수의 재표현, 그래프를 통한 현시성</strong></li>
</ul>
</li>
<li><p>탐색적 분석 효율 예시<br>-데이터 이해 단계, 변수 생성 단계, 변수 선택 단계에서 활용</p>
</li>
</ul>
<h3 id="5-통계분석"><a href="#5-통계분석" class="headerlink" title="5. 통계분석"></a>5. 통계분석</h3><ul>
<li><p><strong>통계</strong></p>
<ul>
<li>어떤 현상을 종합적으로 알아보기 쉽게 일정한 체계에 따라 숫자, 표, 그림 형태로 나타낸 것</li>
</ul>
</li>
<li><p><strong>기술통계(descriptive statistics)</strong></p>
<ul>
<li>모집단으로부터 표본을 추출하고 표본이 가진 정보를 쉽게 파악하도록 데이터를 정리하거나 요약하기 위해 하나의 숫자 또는 그래프 형태로 표현하는 절차</li>
</ul>
</li>
<li><p><strong>추측(추론)통계(inferential statistics)</strong></p>
<ul>
<li>모집단으로부터 추출된 표본의 표본통계량으로부터 모집단 특성인 모수에 관해 통계적으로 추론하는 절차</li>
</ul>
</li>
<li><p>활용 분야</p>
<ul>
<li>정부 경제정책 수립 / 평가 근거자료(통계청 실업률, 고용률, 물가지수)</li>
<li>농업(가뭄, 수해, 병충해에 강한 품종 개발 및 개량)</li>
<li>의학(치료 방법의 효과나 신약 개발을 위한 임상실험 결과 분석)</li>
<li>경영(제품 개발, 품질관리, 시장조사, 영업관리)</li>
<li>스포츠(선수 체질향상, 경기 분석, 전략 분석, 선수 평가, 기용)</li>
</ul>
</li>
</ul>
<h3 id="6-데이터-마이닝"><a href="#6-데이터-마이닝" class="headerlink" title="6. 데이터 마이닝"></a>6. 데이터 마이닝</h3><ul>
<li><p>데이터 마이닝</p>
<ul>
<li>대표적인 고급 데이터 분석법</li>
<li>대용량 자료를 요약하고 미래 예측을 목표로 자료의 관계, 패턴, 규칙을 탐색하고 모형화</li>
<li>이전에 알려지지 않은 유용한 지식을 추출하는 분석</li>
</ul>
</li>
<li><p>방법론</p>
<ul>
<li><p><strong>데이터베이스</strong>에서의 지식 탐색</p>
<ul>
<li>데이터 웨어하우스에서 데이터 마트를 생성하면서 각 데이터 속성을 사전분석하여 지식을 얻는 방법  </li>
</ul>
</li>
<li><p><strong>기계학습</strong>(machine learning)</p>
<ul>
<li>인공지능의 한 분야</li>
<li>컴퓨터가 학습할 수 있도록 알고리즘과 기술을 개발하는 분야</li>
<li>인공신경망, 의사결정나무, 클러스터링, 베이지안 분류, SVM 등</li>
</ul>
</li>
<li><p><strong>패턴인식</strong>(pattern recognition)</p>
<ul>
<li>원자료를 이용하여 사전지식, 패턴에서 추출된 통계 정보를 기반으로 자료 또는 패턴을 분류</li>
<li>장바구니 분석, 연관 규칙</li>
</ul>
</li>
</ul>
</li>
<li><p>활용 분야</p>
<ul>
<li>데이터베이스 마케팅(고객 행동정보를 활용한 목표 마케팅, 고객 세분화, 장바구니 분석, 추천 시스템)</li>
<li>신용평가 및 조기경보시스템(금융기관에서 신용카드 발급, 보험, 대출 발생 시)</li>
<li>생물정보학(세포 유전자 분석으로 질병 진단과 치료법, 신약 개발)</li>
<li>텍스트마이닝(전자우편, SNS 등 디지털 텍스트 정보로 고객성향, 감정, 사회관계망 분석)  </li>
</ul>
</li>
</ul>
<h1 id="2장-R-프로그래밍-기초"><a href="#2장-R-프로그래밍-기초" class="headerlink" title="2장. R 프로그래밍 기초"></a>2장. R 프로그래밍 기초</h1><h2 id="1절-R-소개"><a href="#1절-R-소개" class="headerlink" title="1절. R 소개"></a>1절. R 소개</h2><h3 id="1-데이터-분석-도구의-현황"><a href="#1-데이터-분석-도구의-현황" class="headerlink" title="1. 데이터 분석 도구의 현황"></a>1. 데이터 분석 도구의 현황</h3><ul>
<li><p>R의 탄생</p>
<ul>
<li>오픈소스 프로그램으로 통계, 데이터 마이닝과 그래프를 위한 언어</li>
<li>최신 통계 분석과 마이닝 기능 제공</li>
<li>세계적인 사용자와 다양한 예제 공유 가능</li>
<li>패키지가 수시로 업데이트 됨</li>
</ul>
</li>
<li><p>분석 도구 비교</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>SAS</th>
<th>SPSS</th>
<th>오픈소스 R</th>
</tr>
</thead>
<tbody><tr>
<td>프로그램 비용</td>
<td>유료, 고가</td>
<td>유료, 고가</td>
<td>오픈소스</td>
</tr>
<tr>
<td>설치 용량</td>
<td>대용량</td>
<td>대용량</td>
<td>모듈화로 간단함</td>
</tr>
<tr>
<td>다양한 모듈 지원 및 비용</td>
<td>별도 구매</td>
<td>별도 구매</td>
<td>오픈 소스</td>
</tr>
<tr>
<td>최근 알고리즘 및 기술 반양</td>
<td>느림</td>
<td>다소 느림</td>
<td>매우 빠름</td>
</tr>
<tr>
<td>학습자료 입수 편의성</td>
<td>유료 도서 위주</td>
<td>유료 도서 위주</td>
<td>공개 논문 및 자료 많음</td>
</tr>
<tr>
<td>질의용 공개 커뮤니티</td>
<td>NA</td>
<td>NA</td>
<td>매우 활발</td>
</tr>
</tbody></table>
<ul>
<li><p>R의 특징</p>
<ol>
<li><p>오픈소스 프로그램</p>
<ul>
<li>사용자 커뮤니티에 도움 요청이 많음</li>
<li>많은 패키지가 수시 업데이트</li>
</ul>
</li>
<li><p>그래픽 및 성능</p>
<ul>
<li>프로그래밍, 그래픽 측명 등 사용 프로그램과 대등하거나 월등함</li>
</ul>
</li>
<li><p>시스템 데이터 저장 방식</p>
<ul>
<li>각 세션 사이마다 시스템에 데이터셋을 저장 → 매번 데이터 로딩 필요가 없음</li>
<li>명령어 스토리 저장 가능</li>
</ul>
</li>
<li><p>모든 운영체제</p>
<ul>
<li>윈도우, 맥, 리눅스 운영체제에서 사용 가능</li>
</ul>
</li>
<li><p>표준 플랫폼</p>
<ul>
<li>S 통계 언어 기반으로 구현</li>
<li>R/S 플랫폼은 통계전문가의 사실상 표준 플랫폼</li>
</ul>
</li>
<li><p>객체지향 언어이며 함수형 언어</p>
<ul>
<li><p>통계 기능뿐 아니라 일반 프로그래밍 언어처럼 자동화하거나 새로운 함수 생성 가능</p>
</li>
<li><p><strong>객체지향 언어의 특징</strong></p>
<ul>
<li>SAS, SPSS 회귀 분석 시, 화면에 결과가 나와 추가 작업이 필요</li>
<li>R은 추정계수, 표준오차, 잔차 등 결괏값을 객체에 저장할 수 있어서 활용이 쉬움</li>
</ul>
</li>
<li><p><strong>함수형 언어의 특징</strong></p>
<ul>
<li>깔끔하고 단축된 코드</li>
<li>코드 실행이 빠름</li>
<li>단순한 코드로 디버깅 노력 감소</li>
<li>병렬 프로그래밍으로의 전환 용이</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>R 스튜디오</p>
<ul>
<li>오픈소스이며 다양한 운영체계 지원</li>
<li>메모리에 변수가 어떻게 되어 있는지, 타입이 무엇인지를 볼 수 있음</li>
<li>스크립트 관리와 도큐먼테이션이 편리</li>
<li>코딩은 스크립트용 프로그래밍으로 어렵지 않게 자동화 가능</li>
<li>래틀(Rattle)은 GUI가 패키지와 긴밀하게 결합외어 있어 정해진 기능만 사용 가능 → 업그레이드가 제대로 되지 않으면 통합성에 문제 발생  </li>
</ul>
</li>
<li><p>R 기반 작업 환경</p>
<ul>
<li>R 메모리: 64bit 유닉스- 무제한, x86 64bit- 128TB, 64bit 윈도우- 8TB</li>
</ul>
</li>
</ul>
<h2 id="2절-R-기초"><a href="#2절-R-기초" class="headerlink" title="2절. R 기초"></a>2절. R 기초</h2><ul>
<li>교재 참고</li>
</ul>
<h2 id="3절-입력과-출력"><a href="#3절-입력과-출력" class="headerlink" title="3절. 입력과 출력"></a>3절. 입력과 출력</h2><h3 id="1-데이터-분석-과정"><a href="#1-데이터-분석-과정" class="headerlink" title="1. 데이터 분석 과정"></a>1. 데이터 분석 과정</h3><ul>
<li>분석자가 분석 목적에 맞는 방법론을 선택하여 얻은 결과를 해석하는 과정</li>
<li>INPUT → ANALYSIS → OUTPUT</li>
</ul>
<h3 id="2-R에서의-데이터-입력과-출력"><a href="#2-R에서의-데이터-입력과-출력" class="headerlink" title="2. R에서의 데이터 입력과 출력"></a>2. R에서의 데이터 입력과 출력</h3><ul>
<li>R에서 다룰 수 있는 파일 타입<ul>
<li>Tab-delimited text, Comma-separated text, Excel file, JSON file, HTML/XML file, Database, (other) Statistical SW’s file</li>
</ul>
</li>
</ul>
<h2 id="4절-데이터-구조와-데이터-프레임-1"><a href="#4절-데이터-구조와-데이터-프레임-1" class="headerlink" title="4절. 데이터 구조와 데이터 프레임 1"></a>4절. 데이터 구조와 데이터 프레임 1</h2><h3 id="1-백터-Vector"><a href="#1-백터-Vector" class="headerlink" title="1. 백터(Vector)"></a>1. 백터(Vector)</h3><ul>
<li><p>백터들은 동질적</p>
<ul>
<li>한 백터의 모든 원소는 같은 자료형 또는 같은 모드(mode)를 가짐</li>
</ul>
</li>
<li><p>백터는 위치로 인덱스 됨</p>
<ul>
<li>V[2]는 V 백터의 2번째 원소</li>
</ul>
</li>
<li><p>백터는 인덱스를 통해 여러 개 원소로 구성된 하위 백터를 반환할 수 있음</p>
<ul>
<li>V[c(2,3)]은 V 백터의 2번째, 3번째 원소로 구성된 하위 백터</li>
</ul>
</li>
<li><p>백터 원소들은 이름을 가질 수 있음</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V &lt;- c(10,20,30); names(v) &lt;- c(&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;)</span><br><span class="line">v[&quot;Larry&quot;]  </span><br><span class="line">Larry  </span><br><span class="line">20</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-리스트-Lists"><a href="#2-리스트-Lists" class="headerlink" title="2. 리스트(Lists)"></a>2. 리스트(Lists)</h3><ul>
<li><p>리스트는 이질적</p>
<ul>
<li>여러 자료형 원소가 포함될 수 있음</li>
</ul>
</li>
<li><p>리스트는 위치로 인덱스 됨</p>
<ul>
<li>L[[2]]는 L 리스트의 2번째 원소</li>
</ul>
</li>
<li><p>리스트에서 하위 리스트 추출 가능</p>
<ul>
<li>L[c(2,3)]은 L 리스트의 2번째, 3번째 원소로 이루어진 하위 리스트</li>
</ul>
</li>
<li><p>리스트의 원소들은 이름을 가질 수 있음</p>
<ul>
<li>L[[“Moe”]]와 L$Moe는 둘 다 “Moe”라는 이름의 원소를 지칭</li>
</ul>
</li>
</ul>
<h3 id="3-R에서의-자료-형태-mode"><a href="#3-R에서의-자료-형태-mode" class="headerlink" title="3. R에서의 자료 형태(mode)"></a>3. R에서의 자료 형태(mode)</h3><table>
<thead>
<tr>
<th>객체</th>
<th>예시</th>
<th>모드</th>
</tr>
</thead>
<tbody><tr>
<td><strong>숫자</strong></td>
<td>3.1415</td>
<td>수치형(numeric)</td>
</tr>
<tr>
<td><strong>숫자 백터</strong></td>
<td>c(2,3,4,5,5)</td>
<td>수치형(numeric)</td>
</tr>
<tr>
<td><strong>문자열</strong></td>
<td>“Tom”</td>
<td>문자형(character)</td>
</tr>
<tr>
<td><strong>문자열 백터</strong></td>
<td>c(“Tom”,”Yoon”,”Kim”)</td>
<td>문자형(character)</td>
</tr>
<tr>
<td><strong>요인</strong></td>
<td>factor(c(“A”,”B”,”C”))</td>
<td><strong>수치형(numeric)</strong></td>
</tr>
<tr>
<td><strong>리스트</strong></td>
<td>list(“Tom”,”Yoon”,”Kim”)</td>
<td>리스트(list)</td>
</tr>
<tr>
<td><strong>데이터 프레임</strong></td>
<td>data.frame(x=1:3, y=c(“Tom”,”Yoon”,”Kim”))</td>
<td>리스트(list)</td>
</tr>
<tr>
<td><strong>함수</strong></td>
<td>print</td>
<td>함수(function)</td>
</tr>
</tbody></table>
<h3 id="4-데이터-프레임-data-frames"><a href="#4-데이터-프레임-data-frames" class="headerlink" title="4. 데이터 프레임(data frames)"></a>4. 데이터 프레임(data frames)</h3><ul>
<li><p>강력하고 유연한 구조, SAS 데이터셋을 모방해서 만들어짐</p>
</li>
<li><p>데이터 프레임의 리스트 원소는 백터 또는 요인</p>
</li>
<li><p>백터와 요인은 데이터 프레임의 열</p>
</li>
<li><p>백터와 요인은 동일한 길이</p>
</li>
<li><p>데이터 프레임은 표 형태의 데이터 구조, 열별로 다른 데이터 형식을 가질 수 있음</p>
</li>
<li><p>열에는 이름이 있어야 함</p>
</li>
<li><p>데이터 프레임 원소 접근 방법</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b[1]; b[&quot;empno&quot;]</span><br><span class="line">  b[[i]]; b[[&quot;empno&quot;]]</span><br><span class="line">  b$empno</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-그밖의-데이터-구조"><a href="#5-그밖의-데이터-구조" class="headerlink" title="5. 그밖의 데이터 구조"></a>5. 그밖의 데이터 구조</h3><ul>
<li><p>단일값(Scalars)</p>
<ul>
<li>R에서는 원소가 하나인 백터로 인식/처리<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi</span><br><span class="line">length(pi)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>행렬(Matrix)</p>
<ul>
<li>R에서는 차원을 가진 백터로 인식<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- 1:9</span><br><span class="line">dim(a) &lt;- c(3,3)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>배열(Arrays)</p>
<ul>
<li>행렬에 3차원 또는 n차원까지 확장된 형태</li>
<li>주어진 백터에 더 많은 차원을 부여해 배열 생성<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &lt;- 1:12</span><br><span class="line">dim(b) &lt;- c(2,3,2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>요인(Factors)</p>
<ul>
<li>백터처럼 생겼지만, R에서는 백터에 있는 고유값(unique key) 정보를 얻는데, 고유값들을 요인의 수준(level)이라고 함</li>
<li>요인의 주된 2가지 사용처: 범주형 변수, 집단 분류</li>
</ul>
</li>
</ul>
<h3 id="6-백터-리스트-행렬-다루기"><a href="#6-백터-리스트-행렬-다루기" class="headerlink" title="6. 백터, 리스트, 행렬 다루기"></a>6. 백터, 리스트, 행렬 다루기</h3><ul>
<li>행렬(Matrix)은 R에서 차원을 가진 백터이며, 텍스트마이닝과 소셜 네트워크 분석 등에 활용</li>
<li>재활용 규칙(Recycling Rule)<ul>
<li>길이가 다른 두 백터 연산을 할 때, R은 짧은 백터의 처음으로 돌아가 연산이 끝날 때까지 원소를 재활용</li>
</ul>
</li>
</ul>
<h1 id="3장-데이터-마트"><a href="#3장-데이터-마트" class="headerlink" title="3장. 데이터 마트"></a>3장. 데이터 마트</h1><h2 id="1절-데이터-변경-및-요약"><a href="#1절-데이터-변경-및-요약" class="headerlink" title="1절. 데이터 변경 및 요약"></a>1절. 데이터 변경 및 요약</h2><h3 id="1-R-reshape를-이용한-데이터-마트-개발"><a href="#1-R-reshape를-이용한-데이터-마트-개발" class="headerlink" title="1. R reshape를 이용한 데이터 마트 개발"></a>1. R reshape를 이용한 데이터 마트 개발</h3><ul>
<li><p><strong>데이터 마트</strong></p>
<ul>
<li><strong>데이터 웨어하우스와 사용자 사이의 중간층</strong>에 위치한 것</li>
<li>하나의 주제 또는 하나의 부서 중심의 데이터 웨어하우스</li>
<li>데이터 마트 내 대부분의 데이터는 데이터 웨어하우스로부터 복제</li>
<li>또는 자체적으로 수집되거나 관계형/다차원 데이터 베이스를 이용해 구축</li>
<li>CRM 관련 업무 중 핵심: 고객 데이터 마트 구축</li>
<li>동일한 데이터셋 활용 시, 데이터 마트를 어떻게 구축하느냐에 분석 효과 차이를 만듦</li>
</ul>
</li>
<li><p><strong>요약변수</strong></p>
<ul>
<li>수집된 정보를 분석에 맞게 종합한 변수</li>
<li>가장 기본적인 변수로 총 구매 금액, 금액, 횟수, 구매여부 등 데이터 분석을 위해 만들어지는 변수</li>
<li>많은 모델을 공통으로 사용할 수 있어 재활용성이 높음</li>
<li>합계, 횟수와 같이 간단한 구조이므로 자동화하여 구측 가능</li>
<li><strong>단점</strong>: 얼마 이상이면 구매하더라도 기준값 의미 해석이 애매할 수 있음 → 연속형 변수를 그룹핑해 사용하는 것이 좋음</li>
</ul>
</li>
<li><p><strong>파생변수</strong></p>
<ul>
<li>사용자(분석자)가 특정 조건을 만족하거나 특정 함수에 의해 값을 만들어 의미를 부여한 변수</li>
<li>매우 주관적일 수 있으므로 논리적 타당성을 갖추어 개발해야 함</li>
<li>세분화, 고객행동 예측, 캠페인 반응 예측에 활용</li>
<li>파생변수는 상황에 따라 특정 상황에만 유의미하지 않고 대표성을 띄게 해야 함</li>
</ul>
</li>
<li><p><strong>reshape의 활용</strong></p>
<ul>
<li>reshape 패키지에는 melt()와 cast()라는 2개 핵심 함수가 있음<ul>
<li><strong>melt(): 쉬운 casting을 위해 적당한 형태로 만들어주는 함수</strong></li>
<li>melt(data, id=…)</li>
<li><strong>cast(): 데이터를 원하는 형태로 계산, 변형하는 함수</strong></li>
<li>cast(data, formula=… ~ variable, fun)</li>
</ul>
</li>
<li>변수를 조합해 변수명을 만들고 변수를 시간, 상품 등 차원과 결합해 다양한 요약변수와 파생변수를 쉽게 생성하여 데이터 마트를 구성할 수 있게 함</li>
</ul>
</li>
</ul>
<h3 id="2-sqldf를-이용한-데이터-분석"><a href="#2-sqldf를-이용한-데이터-분석" class="headerlink" title="2. sqldf를 이용한 데이터 분석"></a>2. sqldf를 이용한 데이터 분석</h3><ul>
<li>sqldf는 R에서 sql 명령어를 사용 가능하게 하는 패키지</li>
<li>SAS에서의 proc sql과 같은 역할을 하는 패키지</li>
<li>명령어 차이(sql, R)<ul>
<li>sql: select * from [data frame], R: sqldf(“select * from [data frame]”)</li>
<li>sql: select * from [data frame] numrows 10, R: sqldf(“select * from [data frame] limit 10”)</li>
<li>sql: select * from [data frame] where [col] = ‘char%’, R: sqldf(“select * from [data frame] where [col] like ‘char%’ “)</li>
</ul>
</li>
</ul>
<h3 id="3-plyr을-이용한-데이터-분석"><a href="#3-plyr을-이용한-데이터-분석" class="headerlink" title="3. plyr을 이용한 데이터 분석"></a>3. plyr을 이용한 데이터 분석</h3><ul>
<li>apply 함수에 기반해 데이터와 출력변수를 동시에 배열로 치환하여 처리하는 패키지</li>
<li>split - apply - combine: 데이터 분리, 처리, 결합 등 필수적인 처리 기능 제공</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>array</th>
<th>data frame</th>
<th>list</th>
<th>nothing</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>aaply</td>
<td>adply</td>
<td>alply</td>
<td>a_ply</td>
</tr>
<tr>
<td>data frame</td>
<td>daply</td>
<td>ddply</td>
<td>dlply</td>
<td>d_ply</td>
</tr>
<tr>
<td>list</td>
<td>laply</td>
<td>ldply</td>
<td>llply</td>
<td>l_ply</td>
</tr>
<tr>
<td>n replicates</td>
<td>raply</td>
<td>rdply</td>
<td>rlply</td>
<td>r_ply</td>
</tr>
<tr>
<td>function arguments</td>
<td>maply</td>
<td>mdply</td>
<td>mlply</td>
<td>m_ply</td>
</tr>
</tbody></table>
<h3 id="4-데이터-테이블"><a href="#4-데이터-테이블" class="headerlink" title="4. 데이터 테이블"></a>4. 데이터 테이블</h3><ul>
<li>data.table 패키지는 R에서 가장 많이 사용하는 데이터 핸들링 패키지 중 하나</li>
<li>data.table은 큰 데이터를 탐색, 연산, 병합하는 데 유용</li>
<li>기존 data.frame 방식보다 월등히 빠른 속도</li>
<li>특정 column을 key 값으로 색인 지정 후, 데이터 처리</li>
<li>빠른 그루핑과 ordering, 짧은 문장 지원 측면에서 데이터프레임보다 유용(속도차 큼)</li>
</ul>
<h2 id="2절-데이터-가공"><a href="#2절-데이터-가공" class="headerlink" title="2절. 데이터 가공"></a>2절. 데이터 가공</h2><h3 id="1-Data-Exploration"><a href="#1-Data-Exploration" class="headerlink" title="1. Data Exploration"></a>1. Data Exploration</h3><ul>
<li><p>Data Exploration</p>
<ul>
<li>데이터 분석을 위해 구성된 데이터 변수들의 상태를 파악</li>
</ul>
</li>
<li><p>종류</p>
<ol>
<li>head(데이터셋), tail(데이터셋)</li>
<li>summary(데이터셋)<ul>
<li>수치형변수: 최대값, 최소값, 평균, 1사분위수, 2사분위수(중앙값), 3사분위수</li>
<li>명목형변수: 명목값, 데이터 개수</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-변수-중요도"><a href="#2-변수-중요도" class="headerlink" title="2. 변수 중요도"></a>2. 변수 중요도</h3><ul>
<li><p>변수 중요도</p>
<ul>
<li>변수 선택법과 유사한 개념으로 모형을 생성하여 사용된 변수의 중요도를 살피는 과정</li>
</ul>
</li>
<li><p>종류</p>
<ul>
<li>klaR 패키지<ul>
<li>특정 변수가 주어졌을 때, 클래스가 어떻게 분류되는지에 관한 에러율을 계산하고 그래픽으로 결과를 보여주는 기능</li>
<li>greedy.wilks(): 세분화를 위한 stepwise forward 변수 선택을 위한 패키지, 종속변수에 가장 영향력을 미치는 변수를 wilks lambda를 활용하여 변수 중요도 정리 <strong>(Wilk’s Lambda = 집단내분산/총분산)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-변수의-구간화"><a href="#3-변수의-구간화" class="headerlink" title="3. 변수의 구간화"></a>3. 변수의 구간화</h3><ul>
<li><p>변수의 구간화</p>
<ul>
<li><strong>연속형 변수</strong>를 분석 목적에 맞게 활용하기 위해 구간화하여 모델링에 적용</li>
<li>일반적으로 10진수 단위로 구간화, 구간을 5개로 나누는 것이 보통이며 7개 이상의 구간을 만들지 않음</li>
<li>신용 평가 모형, 고객 세분화 같은 시스템에서 모형에 활용하는 각 변수를 구간화해서 구간별로 점수를 적용하는 스코어링 방식으로 활용</li>
</ul>
</li>
<li><p>구간화 방법</p>
<ol>
<li><p>binning</p>
<ul>
<li>신용평가모형 개발에서 연속형 변수(부채비율 등)를 범주형 변수로 구간화하는데 자주 활용</li>
</ul>
</li>
<li><p>의사결정나무</p>
<ul>
<li>세분화 또는 예측에 활용되는 의사결정나무 모형을 사용해 입력변수 구간화 가능</li>
<li>동일한 변수를 여러 번의 분리 기준으로 사용 가능하기 때문에, 연속변수가 반복적으로 선택될 경우 각각 분리 기준값으로 연속형 변수를 구간화할 수 있음</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="3절-기초-분석-및-데이터-관리"><a href="#3절-기초-분석-및-데이터-관리" class="headerlink" title="3절. 기초 분석 및 데이터 관리"></a>3절. 기초 분석 및 데이터 관리</h2><h3 id="1-데이터-EDA-탐색적-자료-분석"><a href="#1-데이터-EDA-탐색적-자료-분석" class="headerlink" title="1. 데이터 EDA(탐색적 자료 분석)"></a>1. 데이터 EDA(탐색적 자료 분석)</h3><ul>
<li>데이터 분석에 앞서 전체적으로 데이터 특징을 파악하고 다양한 각도로 데이터에 접근</li>
<li>summary()를 이용해 데이터의 기초통계량 확인</li>
</ul>
<h3 id="2-결측값-인식"><a href="#2-결측값-인식" class="headerlink" title="2. 결측값 인식"></a>2. 결측값 인식</h3><ul>
<li>결측값은 NA, 99999999, ‘ ‘(공백), Not Answer 등으로 표현</li>
<li>결측값 자체에 의미가 있는 경우도 있음: 쇼핑몰 중 특정 거래 자체가 존재하지 않는 경우, 아주 부자이거나 아주 가난한 경우 정보를 잘 채우지 않음</li>
<li>결측값 처리는 전체 작업속도에 많은 영향을 줌</li>
</ul>
<h3 id="3-결측값-처리-방법"><a href="#3-결측값-처리-방법" class="headerlink" title="3. 결측값 처리 방법"></a>3. 결측값 처리 방법</h3><ul>
<li><p><strong>단순 대치법(Single Imputation)</strong></p>
<ol>
<li><p>completes analysis</p>
<ul>
<li>결측값이 존재하는 레코드 삭제</li>
</ul>
</li>
<li><p>평균 대치법(Mean Imputation)</p>
<ul>
<li>관측 또는 실험을 통해 얻어진 데이터의 평균으로 대치</li>
<li>비조건부 평균 대치법: 관측 데이터 평균으로 대치</li>
<li>조건부 평균 대치법(regression imputation): 회귀분석을 활용한 대치법</li>
</ul>
</li>
<li><p>단순확률 대치법(Single Stochastic Imputation)</p>
<ul>
<li>평균 대치법에서 추정량 표준 오차의 과소 추정문제를 보완하고자 고안된 방법</li>
<li>Hot-deck 방법, nearest neighbor 방법 등</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>다중 대치법(Multiple Imputation)</strong></p>
<ul>
<li>m번의 대치를 통해 m개의 가상적 완전 자료를 만드는 방법</li>
<li>1단계: 대치(imputation step), 2단계: 분석(Analysis step), 3단계: 결합(combination step)</li>
<li>Amelia-time series cross sectional data set(여러 국가에서 매년 측정된 자료)에서 boostrapping based algorithm을 활용한 다중 대치법</li>
</ul>
</li>
</ul>
<h3 id="4-R에서-결측값-처리"><a href="#4-R에서-결측값-처리" class="headerlink" title="4. R에서 결측값 처리"></a>4. R에서 결측값 처리</h3><ul>
<li>관련 함수</li>
</ul>
<table>
<thead>
<tr>
<th>함수</th>
<th>내용</th>
</tr>
</thead>
<tbody><tr>
<td>complete.cases()</td>
<td>데이터 내 레코드에 결측값 있으면 FALSE, 있으면 TRUE로 반환</td>
</tr>
<tr>
<td>is.na()</td>
<td>결측값을 NA로 인식하여 결측값 있으면 TRUE, 없으면 FALSE로 반환</td>
</tr>
<tr>
<td>DMwR 패키지의 centrallmputation()</td>
<td>NA 값에 가운데 값(central value)으로 대치, 숫자는 중위수, 요인(factor)은 최빈값으로 대치</td>
</tr>
<tr>
<td>DMwR 패키지의 knnlmputation</td>
<td>NA 값을 k 최근 이웃 분류 알고리즘을 사용하여 대치, k개 주변 이웃까지의 거리를 고려하여 가중 평균한 값 사용</td>
</tr>
<tr>
<td>Amelia 패키지의 amelia()</td>
<td>time-series-cross-sectional data set에서 활용(랜덤포레스트 모델은 결측값 돈재할 경우 바로 에러 발생), ramdomForest 패키지의 rflmpute() 함수를 활용해 NA 결측값을 대치한 후 알고리즘에 적용</td>
</tr>
</tbody></table>
<h3 id="5-이상값-Outlier-인식과-처리"><a href="#5-이상값-Outlier-인식과-처리" class="headerlink" title="5. 이상값(Outlier) 인식과 처리"></a>5. 이상값(Outlier) 인식과 처리</h3><ul>
<li><p>이상값이란?</p>
<ul>
<li>의도하지 않게 잘못 입력한 경우 (Bad data)</li>
<li>의도하지 않게 입력되었으나 분석 목접에 부합되지 않아 제거해야 하는 경우 (Bad data)</li>
<li>의도하지 않은 현상이지만 분석에 포함해야 하는 경우</li>
<li>의도된 이상값(fraud, 불량)인 경우</li>
<li>이상값을 꼭 제거해야 하는 것은 아님</li>
</ul>
</li>
<li><p>이상값 인식 방법</p>
<ol>
<li><p><strong>ESD(Extreme Studentized Deviation)</strong></p>
<ul>
<li>평균으로부터 3 표준편차 떨어진 값(각 0.15%)</li>
</ul>
</li>
<li><p>기하평균 -2.5 x 표준편차 &lt; data &lt; 기하평균 +2.5 x 표준편차</p>
</li>
<li><p>사분위수 이용하여 제거하기(상자 그림의 outer fence 밖에 있는 값 제거)</p>
<ul>
<li>이상값 정의: Q1 - 1.5(Q3 - Q1) &lt; data &lt; Q3 + 1.5(Q3 - Q1)을 벗어나는 데이터</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>극단값 절단(trimming) 방법</strong></p>
<ol>
<li><p>기하평균을 이용한 제거</p>
<ul>
<li>geo_mean</li>
</ul>
</li>
<li><p>하단, 상단 % 이용한 제거</p>
<ul>
<li>10% 절단(상하위 5%에 해당되는 데이터 제거)</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>극단값 조정(winsorizing) 방법</strong></p>
<ul>
<li>상한값과 하한값을 벗어나는 값들을 상한, 하한값으로 바꾸어 활용</li>
</ul>
</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/16/ADsP/Part03_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_1/" data-id="ckjqkgb9x001dwkueep8m2wn5" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADSP%EC%9E%90%EA%B2%A9%EC%A6%9D/" rel="tag">ADSP자격증</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADsP/" rel="tag">ADsP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80/" rel="tag">데이터분석준전문가</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ADsP/Part02_데이터_분석_기획" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/14/ADsP/Part02_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_%EA%B8%B0%ED%9A%8D/">ADsP 자격증: Part02. 데이터 분석 기획</a>
    </h1>
  

        <a href="/2020/11/14/ADsP/Part02_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_%EA%B8%B0%ED%9A%8D/" class="article-date">
  <time datetime="2020-11-14T00:00:00.000Z" itemprop="datePublished">2020-11-14</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>  해당 자료는 <a target="_blank" rel="noopener" href="http://www.dataedu.kr/product/adsp-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D-%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80-2020-%EC%99%84%EC%A0%84%EA%B0%9C%EC%A0%95%ED%8C%90/">ADsP 데이터분석 준전문가 2020 완전 개정판</a> 요약본으로 저작권은 DATA EDU에 있습니다.</li>
</ul>
<h1 id="1장-데이터-분석-기획의-이해"><a href="#1장-데이터-분석-기획의-이해" class="headerlink" title="1장. 데이터 분석 기획의 이해"></a>1장. 데이터 분석 기획의 이해</h1><h2 id="1절-분석기획-방향성-도출"><a href="#1절-분석기획-방향성-도출" class="headerlink" title="1절. 분석기획 방향성 도출"></a>1절. 분석기획 방향성 도출</h2><h3 id="1-분석기획의-특징"><a href="#1-분석기획의-특징" class="headerlink" title="1. 분석기획의 특징"></a>1. 분석기획의 특징</h3><ul>
<li>분석기획이란?<ul>
<li>  분석을 수행할 과제를 정의하고, 의도했던 결과를 도출하도록 관리할 방안을 사전에 계획하는 작업</li>
</ul>
</li>
<li>데이터 사이언티스트의 역량<ul>
<li>  Math &amp; Statistics</li>
<li>  Information Technology</li>
<li>  Domain Knowledge</li>
</ul>
</li>
</ul>
<h3 id="2-분석-대상과-방법"><a href="#2-분석-대상과-방법" class="headerlink" title="2. 분석 대상과 방법"></a>2. 분석 대상과 방법</h3><ul>
<li><strong>분석 대상(What), 분석 방법(How)</strong> 따라 4가지로 나뉘어짐<ul>
<li>  Optimization(최적화): 분석 대상 &amp; 분석 방법 모두 앎</li>
<li>  Solution(솔루션): 분석 대상 앎 &amp; 분석 방법 모름</li>
<li>  Insight(통찰): 분석 대상 모름 &amp; 분석 방법 앎</li>
<li>  Discovery(발견): 분석 대상 모름 &amp; 분석 방법 모름</li>
</ul>
</li>
</ul>
<h3 id="3-목표-시점별-분석-기획-방안"><a href="#3-목표-시점별-분석-기획-방안" class="headerlink" title="3. 목표 시점별 분석 기획 방안"></a>3. 목표 시점별 분석 기획 방안</h3><ul>
<li>  <strong>과제 중심적 접근 방식</strong>: 당면 과제를 빠르게 해결하는 방식</li>
<li>  <strong>장기적인 마스터 플랜 방식</strong>: 지속적인 분석 내재화를 위한 방식</li>
<li>  분석 기획에서는 문제해결을 위한 단기적 접근방식과 분석과제 정의를 위한 중장기적인 마스터 플랜 접근방식을 융합하는 것이 중요</li>
<li>  목표 시점별 분석 기획 방안</li>
</ul>
<table>
<thead>
<tr class="header">
<th>당면한 분석 주제 해결(과제 단위)</th>
<th></th>
<th>지속적 분석 문화 내재화(마스터 플랜 단위)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Speed &amp; Test</td>
<td>1차 목표</td>
<td>Accuracy &amp; Deploy</td>
</tr>
<tr class="even">
<td>Quick &amp; Win</td>
<td>과제 유형</td>
<td>Long Term View</td>
</tr>
<tr class="odd">
<td>Problem Solving</td>
<td>접근 방식</td>
<td>Problem Definition</td>
</tr>
</tbody>
</table>

<ul>
<li>  의미 있는 분석을 위해서는 <strong>분석 기술, IT 및 프로그래밍, 분석 주제에 관한 도메인 전문성, 의사 소통</strong>이 중요  </li>
<li>  분석대상 및 방식에 따른 다양한 분석 주제를 과제 단위 또는 마스터 플랜 단위로 도출할 수 있어야 함</li>
</ul>
<h3 id="4-분석-기획-시-고려사항"><a href="#4-분석-기획-시-고려사항" class="headerlink" title="4. 분석 기획 시 고려사항"></a>4. 분석 기획 시 고려사항</h3><ul>
<li><p><strong>가용 데이터(Available Data)</strong></p>
<ul>
<li>분석을 위한 데이터 확보가 우선적이며, 유형 분석이 선행되어야 함</li>
<li>데이터 유형에 따라 적용 가능한 솔루션 및 분석 방법이 다르기 때문  </li>
</ul>
</li>
<li><p><strong>적절한 활용 방안과 유즈 케이스(Proper Business Use Case)</strong></p>
<ul>
<li>분석을 통해 가치가 창출될 수 있음  </li>
<li>‘바퀴를 재발명하지 마라’ 기존에 구현된 유사 분석 시나리오와 솔루션을 최대한 활용  </li>
</ul>
</li>
<li><p><strong>장애요소에 대한 사전계획 수립(Low Barrier Of Execution</strong></p>
<ul>
<li>일회성 분석에 그치지 않고 조직의 역량으로 내재화 필요</li>
<li>충분하고 계속적인 교육 및 활용방안 등의 변화 관리가 고려되어야함</li>
</ul>
</li>
</ul>
<h2 id="2절-분석-방법론"><a href="#2절-분석-방법론" class="headerlink" title="2절. 분석 방법론"></a>2절. 분석 방법론</h2><h3 id="1-분석-방법론-개요"><a href="#1-분석-방법론-개요" class="headerlink" title="1. 분석 방법론 개요"></a>1. 분석 방법론 개요</h3><ul>
<li><p>  데이터 분석이 기업 내 효과적으로 정착하기 위해서는 절차와 방법이 정리된 데이터 분석 방법론 수립 필요  </p>
</li>
<li><p>  프로젝트는 일정한 수준의 품질을 갖춘 산출물과 성공 가능성을 확보할 수 있어야 함 (개인의 역량이나 조직의 우연한 성공에 기인하면 안 됨)  </p>
</li>
<li><p>  상체한 절차(Procedures), 방법(Methods), 도구와 기법(Tools&amp;Techniques), 템플릿과 산출물(Templates&amp;Options)로 구성되어 어느 정도 지식으로 활용할 수 있어야 함</p>
</li>
<li><p>데이터 기반 의사결정의 필요성</p>
<ul>
<li>  경험과 감에 따른 의사결정 → 데이터 기반 의사결정</li>
<li>기업의 합리적 의사결정을 막는 장애요소<ul>
<li>고정관념(Stereotype), 편향된 생각(Bias), 프레이밍<br>  효과(Framing Effect, 문제 표현 방식에 따라 동일한 사건임에도<br>  판단이나 선택이 달라지는 현상)  </li>
</ul>
</li>
</ul>
</li>
<li><p>방법론의 생성 과정<br>  <strong>암묵지</strong> → (형식화) → <strong>형식지</strong> → (체계화) → <strong>방법론</strong> → (내재화) → <strong>암묵지</strong>  </p>
</li>
<li><p>방법론 적용 업무 특성에 따른 모델</p>
<ul>
<li><p><strong>폭포수 모델</strong>(Waterfall Model)</p>
<ul>
<li>  단계를 순차적으로 진행하는 방법, 이전 단계가 완료되어야 다음 단계 진행 가능</li>
<li>  문제 발결 시 피드백 과정이 수행됨</li>
<li>  기존 IT의 SW 개발 방식</li>
</ul>
</li>
<li><p><strong>프로토타임 모델</strong>(Prototype Model)</p>
<ul>
<li>  폭포수 모델 단점을 보환하기 위해 점진적으로 시스템을 개발해가는 접근 방식</li>
<li>  고객 요구를 완전히 이해하지 못하거나 완벽한 요구 분석의 어려움을 해결하기 위한 방법</li>
<li>  일부분을 우선 개발하여 사용자에게 제공</li>
<li>  시험 사용 후, 사용자 요구를 분석하여 요구 정당성을 점검하고 개선 작업을 진행</li>
</ul>
</li>
<li><p><strong>나선형 모델</strong>(Spiral Model)</p>
<ul>
<li>  반복을 통해 점증적으로 개발하는 방법</li>
<li>  처음 시도하는 프로젝트에는 용이하나, 관리 체계를 갖추지 못하면 복잡도 상승</li>
</ul>
</li>
</ul>
<ul>
<li>방법론의 구성</li>
</ul>
</li>
</ul>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>단계</strong></td>
<td>최상위 계층으로서 프로세스 그룹을 통해 완성된 단계별 산출물 생성, 각 단계는 기준선으로 설정되어 관리되어야 함, 버전관리 등으로 통제</td>
<td>→ 단계별 완료 보고서</td>
</tr>
<tr class="even">
<td><strong>태스크</strong></td>
<td>단계를 구성하는 단위 활동으로써 물리적 또는 논리적 단위로 품질검토의 항목이 됨</td>
<td>→ 보고서</td>
</tr>
<tr class="odd">
<td><strong>스탭</strong></td>
<td>WBS(Work Breakdown Structure)의 워크 패키지에 해당, 입력자료/처리 및 도구/출력자료로 구성된 단위 프로세스</td>
<td>→ 보고서 구성요소</td>
</tr>
</tbody>
</table>

<h3 id="2-KDD-분석-방법론"><a href="#2-KDD-분석-방법론" class="headerlink" title="2. KDD 분석 방법론"></a>2. KDD 분석 방법론</h3><ul>
<li><p>KDD(Knowledge Discovery in Databases)</p>
<ul>
<li>  프로파일링 기술 기반으로 데이터에서 통계적 패턴이나 지식을 찾는 데 활용할 수 있도록 정리한 데이터 마이닝 프로세스  </li>
<li>  데이터 마이닝, 기계학습, 인공지능, 패턴인식, 데이터 시각화 등에서 응용될 수 있는 구조를 가짐</li>
</ul>
</li>
<li><p>KDD 분석 절차<br>  [Data] → <strong>1. Selection</strong> → [Target Data] → <strong>2. Preprocessing</strong><br>  → [Preprocessed Data] → <strong>3. Transformation</strong> → [Transformed<br>  Data] → <strong>4.Data Mining</strong> → [Patterns] → <strong>5. Interpretation /<br>  Eveluation</strong> → [Knowledge]</p>
</li>
</ul>
<ol>
<li><strong>데이터셋 선택</strong>(Selection)  </li>
</ol>
<ul>
<li>데이터셋 선택에 앞서 분석 대상 비즈니스 도메인에 대한 이해와 프로젝트<br>목표 설정이 필수 - 데이터베이스 또는 원시 데이터에서 분석에 필요한<br>데이터를 선택하는 단계 - 데이터마이닝에 필요한 목표데이터(target data)를<br>구성하여 분석에 활용</li>
</ul>
<ol start="2">
<li><p><strong>데이터 전처리</strong>(Preprocessing)</p>
<ul>
<li>  데이터셋을 정제하는 단계</li>
<li>  잡음(Noise), 이상치(Outlier), 결측치(Missing Value)를 식별하고 제거하거나 의미 있는 데이터로 재처리</li>
<li>  전처리 단계에서 추가로 요구되는 데이터셋이 필요한 경우, 데이터 선택 프로세스를 재실행</li>
</ul>
</li>
<li><p><strong>데이터 변환</strong>(Transformation)</p>
<ul>
<li>  데이터 전처리 과정을 통해 정제된 데이터에 분석 목적에 맞는 변수 생성, 선택</li>
<li>  데이터 차원을 축소하여 효율적으로 데이터 마이닝 하도록 변경하는 단계</li>
<li>  학습용 데이터(training data)와 검증용 데이터(test data)로 데이터를 분리하는 단계</li>
</ul>
</li>
<li><p><strong>데이터 마이닝</strong>(Data Mining)</p>
<ul>
<li>  학습용 데이터를 이용하여 분석 목적에 맞는 데이터 마이닝 기법을 선택하고 적절한 알고리즘으로 데이터 마이닝 작업을 실행</li>
<li>  필요에 따라 데이터 전처리와 데이터 변환 프로세스를 추가로 실행</li>
</ul>
</li>
<li><p><strong>데이터 마이닝 결과 평가</strong>(Interpretation / Evaluation)</p>
<ul>
<li>  데이터 마이닝 결과에 대한 해석과 평가, 분석 목적과의 일치성 확인</li>
<li>  데이터 마이닝을 통해 발견한 지식을 업무에 활용하기 위한 방안 마련 단계</li>
<li>  필요에 따라 데이터 선택 프로세스에서 데이터 마이닝 프로세스를 반복 수행</li>
</ul>
</li>
</ol>
<h3 id="3-CRISP-DM-분석-방법론"><a href="#3-CRISP-DM-분석-방법론" class="headerlink" title="3. CRISP-DM 분석 방법론"></a>3. CRISP-DM 분석 방법론</h3><ul>
<li><p>CRISP-DM(Cross Industy Standard Process for Data Mining)</p>
<ul>
<li>  5개 업체가 주도: Daimler-Chrysler, SPSS, NCR, Teradata, OHRA</li>
<li>  계층적 프로세스 모델로써 4개 레벨로 구성됨</li>
</ul>
</li>
<li><p>CRISP-DM의 4레벨 구조</p>
<ul>
<li>  Phases(단계) → Generic Tasks(일반화 태스크) → Specialized Task(세분화 태스크) → Process Instances(프로세스 실행)</li>
</ul>
</li>
<li><p>CRISP-DM의 6단계 프로세스</p>
<ul>
<li><p>각 단계는 단방향으로 구성되지 않고, 단계 간 피드백을 통해 단계별 완성도를 높이게 되어 있음</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>단계</th>
<th>내용</th>
<th>수행업무</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1. 업무 이해</td>
<td>프로젝트 목적과 요구사항을 이해, 도메인 지식을 데이터 분석을 위한 문제 정의로 변경하고 초기 프로젝트 계획을 수립</td>
<td>업무 목적 파악, 상황 파악, 데이터 마이닝 목표 설정, 프로젝트 계획 수립</td>
</tr>
<tr class="even">
<td>2. 데이터 이해</td>
<td>데이터 수집하고 데이터 속성 이해, 데이터 품질 문제점 식별, 숨겨진 인사이트 발견</td>
<td>초기 데이터 수집, 데이터 기술 분석, 데이터 탐색, 데이터 품질 확인</td>
</tr>
<tr class="odd">
<td>3. 데이터 준비</td>
<td>분석을 위해 수진된 데이터에서 분석기법에 적합한 데이터 편성</td>
<td>초기 데이터 수집, 데이터 기술 분석, 데이터 탐색, 데이터 품질 확인</td>
</tr>
<tr class="even">
<td>4. 모델링</td>
<td>다양한 모델링 기법과 알고리즘 선택, 파라미터 최적화, 데이터셋이 추가로 필요한 경우 <strong>준비 단계 반복 수행</strong>, 테스트용 데이터셋을 평가해 모델의 과적합 문제 확인</td>
<td>모델링 기법 선택, 모델 테스트 계획 설계, 모델 작성, 모델 평가</td>
</tr>
<tr class="odd">
<td>5. 평가</td>
<td>모델링 결과가 프로젝트 목적에 부합하는지 평가, 데이터 마이닝 결과를 최종적으로 수용할 것인지 판단</td>
<td>분석 결과 평가, 모델링 과정 평가, 모델 적용성 평가</td>
</tr>
<tr class="even">
<td>6. 전개</td>
<td>모델을 실 업무에 적용하기 위한 계획 수립, 유지보수 계획 마련(생명주기 고려 필요)</td>
<td>전개 계획 수립, 모니터링/유지보수 계획 수립, 프로젝트 종료 보고서 작성, 프로젝트 리뷰</td>
</tr>
</tbody>
</table>


</li>
</ul>
</li>
</ul>
<h3 id="4-KDD-vs-CRISP-DM"><a href="#4-KDD-vs-CRISP-DM" class="headerlink" title="4. KDD vs CRISP-DM"></a>4. KDD vs CRISP-DM</h3><table>
<thead>
<tr class="header">
<th>KDD</th>
<th>CRISP-DM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>분석대상 비즈니스 이해</td>
<td>업무 이해</td>
</tr>
<tr class="even">
<td>데이터셋 선택 / 데이터 전처리</td>
<td>데이터의 이해</td>
</tr>
<tr class="odd">
<td>데이터 변환</td>
<td>데이터 준비</td>
</tr>
<tr class="even">
<td>데이터 마이닝</td>
<td>모델링</td>
</tr>
<tr class="odd">
<td>데이터 마이닝 결과 평가</td>
<td>평가</td>
</tr>
<tr class="even">
<td>데이터 마이닝 활용</td>
<td>전개</td>
</tr>
</tbody>
</table>

<h3 id="5-빅데이터-분석-방법론"><a href="#5-빅데이터-분석-방법론" class="headerlink" title="5. 빅데이터 분석 방법론"></a>5. 빅데이터 분석 방법론</h3><ul>
<li>빅데이터 분석의 계층적 프로세스<ul>
<li>  단계(Phase): 프로세스 그룹을 통해 완성된 단계별 산출물 생성</li>
<li>  태스크(Task): 각 단계는 여러 개의 태스크로 구성, 단계를 구성하는 단위 활동이며 물리/논리적 단위로 품질 검토 항목이 될 수 있음</li>
<li>  스텝(Step): WBS의 워크 패키지에 해당되고 입력자료, 처리 및 도구, 출력자료로 구성된 단위 프로세스</li>
</ul>
</li>
<li>빅데이터 분석 방법론 5단계<ul>
<li>  분석 기획(Planning): 비즈니스 도메인과 문제점 인식, 분석 계획 및 프로젝트 수행계획을 수립하는 단계  </li>
<li>  데이터 준비(Preparing): 비즈니스 요구사항과 데이터 분석데 필요한 원천 데이터를 정의하고 준비하는 단계  </li>
<li>  데이터 분석(Analyzing): 원천 데이터를 분석용 데이터셋으로 편성하고 분석 기법과 알고리즘으로 데이터를 분석하는 단계, 추가 데이터가 필요할 경우 <strong>준비 단계로 피드백하여 두 단계 반복 진행</strong></li>
<li>  시스템 구현(Developing): 분석 기획에 맞는 모델 도출, 운영 중인 가동 시스템에 적용하거나 시스템 개발을 위한 사전 검증</li>
<li>  평가 및 전개(Lesson Learned): 프로젝트 성과를 평가하고 정리, 모델 발전 계획을 수립하여 차기 분석 기획으로 전달</li>
</ul>
</li>
</ul>
<h2 id="3절-분석-과제-발굴"><a href="#3절-분석-과제-발굴" class="headerlink" title="3절. 분석 과제 발굴"></a>3절. 분석 과제 발굴</h2><h3 id="1-분석-과제-발굴-방법론"><a href="#1-분석-과제-발굴-방법론" class="headerlink" title="1. 분석 과제 발굴 방법론"></a>1. 분석 과제 발굴 방법론</h3><ul>
<li>개요<ul>
<li>  <strong>과제 정의서 형태</strong>로 도출</li>
<li>  하향식 접근 방법과 상향식 접근 방법이 있음</li>
</ul>
</li>
<li>최적의 의사 결정은 두 접근 방식이 상호 보완일 때 가능<ul>
<li>  디자인 사고: 상향식 접근의 발산 단계, 하향식 접근의 수렴 단계를 반복적으로 수행하여 분석 가치를 높임</li>
</ul>
</li>
</ul>
<ol>
<li>하향식 접근법(Top Down Approach)<ul>
<li>  현황 분석을 통해 기회나 문제 탐색 → 문제 정의 → 해결방안 탐색</li>
<li>  데이터 분석의 타당성 평가를 거쳐 분석 과제를 도출하는 과정으로 구성</li>
</ul>
</li>
</ol>
<ul>
<li><p>1단계. 문제 탐색</p>
<ul>
<li><p>  문제를 해결함으로 나타나는 가치에 중점</p>
</li>
<li><p>  비즈니스 모델 기반 문제 탐색: <strong>비즈니스 모델 캔버스</strong> 업무(Operation), 제품(Product), 고객(Customer), 규제와 감사(Regulation &amp; Audit), 지원 인프라(IT &amp; Human Resource)</p>
</li>
<li><p>분석 기회 발굴 범위 확장</p>
<ol>
<li> 거시적 관점: 사회, 기술, 경제, 환경, 정치</li>
<li> 경쟁자 확대: 대체제, 경쟁자, 신규 진입자</li>
<li> 시장 니즈 탐색: 고객, 채널, 영향자들</li>
<li> 역량의 재해석: 내부역량, 파트너 네트워크</li>
</ol>
</li>
<li><p>외부 참조 모델 기반 문제탐색</p>
<ul>
<li>  Quick &amp; Easy 방식으로 빠르게 도출</li>
<li>  데이터 분석을 통한 인사이트 도출</li>
<li>  지속적 조사와 데이터 분석을 통한 가치 발굴 사례를 정리하여 풀(Pool)로 만들면 좋음</li>
</ul>
</li>
<li><p>분석 유즈 케이스(Analytics Use Case)</p>
<ul>
<li>  빠짐 없이 도출한 분석 기회를 구체적인 과제로 만들기 전에 분석 유즈 케이스로 표기하는 것이 필요</li>
</ul>
</li>
</ul>
</li>
<li><p>2단계. 문제 정의(Problem Definition)</p>
<ul>
<li>  식별된 비즈니스 문제를 데이터 문제로 변환하여 정의하는 단계 (How ?)</li>
<li>  데이터 분석 문제 정의 및 요구사항: 분석 수행 당사자뿐 아니라 최종 사용자(End User) 관점에서 이루어져야 함  </li>
<li>  데이터 정의 및 기법 발굴을 용이하게 하기 위해 정확히 분석의 관점에서 문제를 재정의할 필요가 있음</li>
</ul>
</li>
<li><p>3단계. 해결 방안 탐색(Solution Search)</p>
<ul>
<li>정의된 데이터 분석 문제 해결을 위해 다양한 방안 모색<ul>
<li>  기존 정보시스템의 단순한 보완으로 분석 가능한지 고려</li>
<li>  엑셀 등 간단한 도구로 분석 가능한지 고려</li>
<li>  하둡 등 분산병렬처리를 활용한 빅데이터 분석 도구로 보다 체계적이고 심도 있는 방안 고려</li>
</ul>
</li>
<li>  분석 역량이 없을 경우, 교육이나 전문인력 채용으로 역량을 확보하거나 전문 업체를 활용</li>
</ul>
</li>
<li><p>4단계. 타당성 검토(Feasibility Study)</p>
<ul>
<li>  경제적 타당성: 비용 대비 편익 분석 관점으로 접근</li>
<li>  데이터 및 기술적 타당성</li>
</ul>
</li>
</ul>
<ol>
<li> 상향식 접근법(Bottom up Approach)  </li>
</ol>
<ul>
<li><p>  다양한 원천 데이터를 대상으로 분석하여 가치 있는 모든 문제를 도출하는 과정  </p>
</li>
<li><p>하향식 접근법의 한계를 극복하기 위한 분석 방법론</p>
<ul>
<li>  단계별 접근법은 문제 구조가 분명하고, 문제 해결이 데이터 분석가 및 의사결정자에게 주어져 있음을 가정 → 솔루션 도출에는 유리하나 새로운 문제 탐색에는 한계</li>
<li>  디자인 사고 접근법을 통해 전통적인 분석적 사고 한계를 극복해야 함</li>
<li>  Why가 아닌 사물을 그대로 인식하는 What 관점으로 보아야 함</li>
<li>  데이터 그 자체를 관찰하고 행동하여 대상을 잘 이해하는 방식의 접근법</li>
<li>  Empathize → Define → Ideate → Prototype → Test</li>
</ul>
</li>
<li><p>비지도 학습과 지도 학습</p>
<ul>
<li><p>비지도 학습(Unsupervised Learning)</p>
<ul>
<li>일반적으로 상향식 접근방식의 데이터 분석은 비지도 학습<br>  방법으로 수행</li>
<li>데이터 자체의 결합, 연관성, 유사성을 중심으로 데이터 상태를<br>  표현하는 것</li>
<li>  예) 장바구니 분석, 군집 분석, 기술 통계 및 프로파일링</li>
</ul>
</li>
<li><p>지도 학습(Supervised Learning)</p>
<ul>
<li>  명확한 목적 하에 데이터 분석을 실시하는 것</li>
<li>분류, 추측, 예측, 최적화를 통해 사용자 주도 하 분석을<br>  실시하고 지식을 도출하려는 목적  </li>
<li>  상관관계 분석, 연관 분석을 통해 다양한 문제를 해결</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>시행 착오를 통한 문제 해결</p>
<ul>
<li><p>프로토타이핑 접근법</p>
<ul>
<li>  요구사항이나 데이터 규정이 어렵고, 데이터 소스를 명확히 파악하기 어려운 상황에서 일단 분석하고 결과를 보면서 반복적으로 개선해 나가는 방식</li>
<li>  완벽하지는 못하지만, 신속하게 해결책이나 모형을 제시함으로써 이를 바탕으로 문제를 명확히 인식하고 필요한 데이터를 식별하여 구체화하게 하는 상향식 접근 방식</li>
<li>  가설 생성 → 디자인 실험 → 실제 환경 테스트 → 인사이트 도출 및 가설 확인</li>
</ul>
</li>
<li><p>빅데이터 분석 환경에서 프로토타이핑의 필요성</p>
<ul>
<li>  문제 인식 수준: 문제 정의가 불명확하거나 새로운 문제일 경우 문제 이해와 구체화에 도움</li>
<li>  필요 데이터 존재 여부의 불확실성: 데이터를 어떻게 찾을 것인지 사용자와 분석가 간 반복적인 협의 과정 필요</li>
<li>  데이터 사용 목적 가변성: 기존 데이터 정의를 재검토하여 데이터 사용 목적과 범위 확대 가능</li>
</ul>
</li>
<li><p>분석과제 정의: 분석별 필요한 소스 데이터, 분석 방법, 데이터 입수, 분석 난이도, 분석 수행주기, 분석 결과 검증 오너십, 상세 분석 과정 정의</p>
<ul>
<li>  분석 데이터 소스: 내/외부 비구조적인 데이터와 소셜 미디어 및 오픈 데이터까지 범위 확장하여 고려하고 분석 방법 또한 상세하게 정의</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4절-분석-프로젝트-관리-방안"><a href="#4절-분석-프로젝트-관리-방안" class="headerlink" title="4절. 분석 프로젝트 관리 방안"></a>4절. 분석 프로젝트 관리 방안</h2><h3 id="1-분석과제-관리를-위한-5가지-주요-영역"><a href="#1-분석과제-관리를-위한-5가지-주요-영역" class="headerlink" title="1. 분석과제 관리를 위한 5가지 주요 영역"></a>1. 분석과제 관리를 위한 5가지 주요 영역</h3><ul>
<li><p>Data Size</p>
<ul>
<li>  분석하고자 하는 데이터 양 고려</li>
</ul>
</li>
<li><p>Data Complexity</p>
<ul>
<li>  초기 데이터 확보와 통합뿐 아니라 해당 데이터에 적용될 수 있는 분석 모델 선정 등의 사전 고려 필요</li>
</ul>
</li>
<li><p>Speed</p>
<ul>
<li>  시나리오 측면에서의 속도 고려 필요</li>
<li>  프로젝트 수행 시 분석 모델의 성능 및 속도를 고려한 개발/테스트</li>
</ul>
</li>
<li><p>Analytic Complexity</p>
<ul>
<li>  분선 모델의 정확도와 복잡도는 트레이드 오프 관계</li>
<li>  분석 모델이 복잡할수록 정확도는 올라가지만 해석이 어려워짐</li>
<li>  해석이 가능하면서도 정확도를 올릴 수 있는 최적모델을 찾아야 함</li>
</ul>
</li>
<li><p>Accuracy &amp; Precision</p>
<ul>
<li>  정확도: 모델과 실제 값 사이 차이가 적음을 의미</li>
<li>  일관성: 모델을 반복했을 때의 편차의 수준</li>
<li>  활용 측면에서는 정확도가, 안정성 측면에서는 일관성이 중요</li>
</ul>
</li>
</ul>
<h1 id="2장-분석-마스터-플랜"><a href="#2장-분석-마스터-플랜" class="headerlink" title="2장. 분석 마스터 플랜"></a>2장. 분석 마스터 플랜</h1><h2 id="1절-마스터-플랜-수립-프레임-워크"><a href="#1절-마스터-플랜-수립-프레임-워크" class="headerlink" title="1절. 마스터 플랜 수립 프레임 워크"></a>1절. 마스터 플랜 수립 프레임 워크</h2><h3 id="1-분석-마스터-플랜-수립-프레임-워크"><a href="#1-분석-마스터-플랜-수립-프레임-워크" class="headerlink" title="1. 분석 마스터 플랜 수립 프레임 워크"></a>1. 분석 마스터 플랜 수립 프레임 워크</h3><ul>
<li><p>마스터 플랜 수립 개요</p>
<ul>
<li>  우선 순위 고려 요소: 전략적 중요도, 비즈니스 성과/ROI, 실행 용이성</li>
<li>  적용 범위/방식 고려 요소: 업무 내재화 적용 수준, 분석 데이터 적용 수준, 기술 적용 수준</li>
</ul>
</li>
<li><p>수행 과제 도출 및 우선순위 평가</p>
<ul>
<li>일반적인 IT 프로젝트의 우선순위 평가 예시<ol>
<li> 전략적 중요도: 전략적 필요성, 시급성</li>
<li> 실행 용이성: 투자 용이성, 기술 용이성</li>
</ol>
</li>
<li>  ROI 관점의 빅데이터 핵심 특징 3V(난이도): 크기(Volume), 다양성(variety), 속도(Velocity) → 투자비용 요소 4V(시급성): 3V + 가치(Value) → 비즈니스 효과</li>
</ul>
</li>
</ul>
<h2 id="2절-분석-거버넌스-체계-수립"><a href="#2절-분석-거버넌스-체계-수립" class="headerlink" title="2절. 분석 거버넌스 체계 수립"></a>2절. 분석 거버넌스 체계 수립</h2><h3 id="1-거버넌스-체계"><a href="#1-거버넌스-체계" class="headerlink" title="1. 거버넌스 체계"></a>1. 거버넌스 체계</h3><ul>
<li>구성 요소<ul>
<li>  분석 기획 및 관리를 수행하는 조직(Organization)</li>
<li>  과제 기획 및 운영 프로세스(Process)</li>
<li>  분석 관련 시스템(System)</li>
<li>  데이터(Data)</li>
<li>  분석 관련 교육 및 마인드 육성 체계(Human Resource)</li>
</ul>
</li>
</ul>
<h3 id="2-데이터-분석-수준-진단"><a href="#2-데이터-분석-수준-진단" class="headerlink" title="2. 데이터 분석 수준 진단"></a>2. 데이터 분석 수준 진단</h3><ul>
<li><p>  분석 준비도(Readiness): 분석 업무, 분석 인력 및 조직, 분석 기법, 분석 데이터, 분석 문화, 분석 인프라  </p>
</li>
<li><p>  분석 성숙도(Maturity): 도입 &gt; 활용 &gt; 확산 &gt; 최적화(비즈니스, 조직 및 역량, IT)</p>
</li>
<li><p><strong>분석 준비도</strong></p>
 <table>
  <colgroup>
  <col style="width: 50%" />
  <col style="width: 50%" />
  </colgroup>
  <thead>
  <tr class="header">
  <th>진단 과정</th>
  <th>내용</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>분석업무 파악</td>
  <td>발생 사실 분석, 예측 분석, 시뮬레이션 분석, 최적화 분석, 분석 업무 정기적 개선</td>
  </tr>
  <tr class="even">
  <td>인력 및 조직</td>
  <td>분석 전문가 직무, 분석 전문가 교육 훈련, 관리자의 기본적 분석 능력, 전사 분석업무 총괄 조직, 경영진의 분석 업무 이해</td>
  </tr>
  <tr class="odd">
  <td>분석 기법</td>
  <td>업무별 적합한 분석 기법, 분석 업무 도입 방법론, 분석 기법 라이브러리, 분석 기법 효과성 평가, 분석 기법 정기적 개선</td>
  </tr>
  <tr class="even">
  <td>분석 데이터</td>
  <td>데이터 충분성 / 신뢰성 / 적시성, 비구조적 데이터 관리, 외부 데이터 활용 체계, 기준 데이터 관리(MDM)</td>
  </tr>
  <tr class="odd">
  <td>IT 인프라</td>
  <td>운영 시스템 데이터 통합, EAI/ETL 등 데이터 유통 체계, 분석 전용 서버 및 스토리지, 빅데이터 분석 환경, 통계 분석 환경, 비쥬얼 분석 환경</td>
  </tr>
  </tbody>
  </table>
</li>
<li><p>분석 성숙도 모델</p>
<ul>
<li>  조직의 성숙도 평가 도구: CMMI(Capability Maturity Model Integration)</li>
<li>  성숙도 수준 분류: 도입 단계 → 활용 단계 → 확산 단계 → 최적화 단계</li>
<li>  분석 성숙도 진단 분류: 비즈니스 부문, 조직/역량 부문, IT 부문</li>
</ul>
</li>
<li><p>분석 관점에서의 사분면 분석</p>
<ul>
<li>  정착형(준비도 낮음, 성숙도 높음)</li>
<li>  확산형(준비도 높음, 성숙도 높음)</li>
<li>  준비형(준비도 낮음, 성숙도 낮음)</li>
<li>  도입형(준비도 높음, 성숙도 낮음)</li>
</ul>
</li>
</ul>
<h3 id="3-분석-지원-인프라-방안-수립"><a href="#3-분석-지원-인프라-방안-수립" class="headerlink" title="3. 분석 지원 인프라 방안 수립"></a>3. 분석 지원 인프라 방안 수립</h3><ul>
<li><p>분석 과제 단위별로 별도 분석 시스템을 구축하면, 관리 복잡 &amp; 비용<br>  증대 문제가 발생</p>
</li>
<li><p>분석 마스터 플랜 기획 단계에서부터 확장성을 고려한 플랫폼 구조<br>  도입이 필요</p>
</li>
<li><p>플랫폼 구조: 공동 기능, 중앙 집중적 데이터 관리, 시스템 간<br>  인터페이스 최소화</p>
</li>
<li><p>플랫폼</p>
<ul>
<li>  단순한 분석 응용프로그램뿐 아니라, 분석 서비스를 위한 응용프로그램이 실행될 수 있는 기초를 이루는 컴퓨터 시스템</li>
<li>  일반적으로 하드웨어에 탑재되어 데이터 분석에 필요한 프로그래밍 환경과 실행 및 서비스 환경을 제공</li>
<li>  분석 플랫폼이 구성된 경우, 개별적인 분석 시스템 추가 대신 서비스를 추가하는 방식으로 확장성을 높일 수 있음</li>
</ul>
</li>
</ul>
<h3 id="4-데이터-거버넌스-체계-수립"><a href="#4-데이터-거버넌스-체계-수립" class="headerlink" title="4. 데이터 거버넌스 체계 수립"></a>4. 데이터 거버넌스 체계 수립</h3><ul>
<li><p>데이터 거버넌스</p>
<ul>
<li>  전사 차원 데이터에 대해 관리 체계 수립, 프레임워크 및 저장소 구축</li>
<li>마스터 데이터(Master Data), 메타 데이터(Meta Data), 데이터 사전(Data Dictionary)<ul>
<li>  데이터 거버넌스 체계를 구축함으로써 데이터의 가용성, 유용성, 통합성, 보안성, 안정성 확보 가능</li>
<li>  독자적 수행도 가능하나, 전사 차원의 IT 거버넌스나 EA(Enterprise Architecture)의 구성요소로 구축되는 경우도 있음</li>
<li>  빅데이터의 효율적인 관리, 다양한 데이터 관리 체계, 데이터 최적화, 정보 보호, 데이터 생명주기 관리, 데이터 카테고리별 관리 책임자 지정 등 포함</li>
</ul>
</li>
</ul>
</li>
<li><p>데이터 거버넌스 구성 3요소</p>
<ul>
<li><p>원칙(Principle)</p>
<ul>
<li>  데이터를 유지/관리하기 위한 지침과 가이드</li>
<li>  보안, 품질 기준, 변경 관리</li>
</ul>
</li>
<li><p>조직(Organization)</p>
<ul>
<li>  데이터 관리 조직의 역할과 책임</li>
<li>  데이터 관리자, 데이터베이스 관리자, 데이터 아키텍트</li>
</ul>
</li>
<li><p>프로세스(Process)</p>
<ul>
<li>  데이터 관리 위한 활동과 체계</li>
<li>  작업 절차, 모니터링 활동, 측정 활동</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>데이터 거버넌스 체계</p>
<ul>
<li><p><strong>데이터 표준화</strong></p>
<ul>
<li>  업무: 데이터 표준 용어 설정, 명명 규칙 수립, 메타 데이터 구축, 데이터 사전 구축  </li>
<li>  데이터 표준 용어는 표준 단어사전, 표준 도메인사전, 표준 코드 등으로 구성 (점검 프로세스 포함 필요)</li>
<li>  명명 규칙은 필요 시 언어별로 작성되어 매핑 상태를 유지해야 함</li>
</ul>
</li>
<li><p><strong>데이터 관리 체계</strong></p>
<ul>
<li>  표준 데이터를 포함한 메타 데이터와 데이터 사전 관리 원칙 수립 → 데이터 정합성 및 활용 효율성을 위해</li>
<li>  수립된 원칙에 근거해 상세 프로세스를 만들고 담당자와 조직을 상세히 준비</li>
<li>  데이터 생명주기 관리 방안(Data Life Cycle Management) 수립 필요</li>
</ul>
</li>
<li><p><strong>데이터 저장소 관리(Repository)</strong></p>
<ul>
<li>  메타 데이터 및 표준 데이터 관리를 위한 전사 차원 저장소</li>
<li>  워크플로우 및 관리용 응용 소프트웨어를 지원하고 관리 대상 시스템과의 인터페이스를 통제가 이뤄져야 함</li>
<li>  데이터 구조 변경에 따른 사전 영향 평가 수행 필요 → 효율적 활용을 위해</li>
</ul>
</li>
<li><p><strong>표준화 활동</strong></p>
<ul>
<li>  데이터 거버넌스 체계 구축 후, 표준 준수 여부를 주기적으로 점검하고 모니터링 실시</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-데이터-조직-및-인력방안-수립"><a href="#5-데이터-조직-및-인력방안-수립" class="headerlink" title="5. 데이터 조직 및 인력방안 수립"></a>5. 데이터 조직 및 인력방안 수립</h3><ul>
<li><p>분석을 위한 3가지 조직 구조</p>
<ul>
<li><p><strong>집중 구조</strong></p>
<ul>
<li>  전사 분석업무를 별도 분석 전담 조직에서 담당</li>
<li>  전략적 중요도에 따라 분석조직이 우선순위 정하여 진행</li>
<li>  현업 업무부서의 분석업무와 이중화/이원화 가능성이 높음</li>
</ul>
</li>
<li><p><strong>기능 구조</strong></p>
<ul>
<li>  일반적인 분석 수행 구조</li>
<li>  별도 분석조직이 없고 해당 업무 부서에서 분석 수행</li>
<li>  전사적 핵심 분석이 어려우며, 과거 실적에 국한된 분석이 수행될 가능성이 높음</li>
</ul>
</li>
<li><p><strong>분산 구조</strong></p>
<ul>
<li>  분석조직 인력을 현업부서로 직접 배치하여 분석 업무 수행</li>
<li>  전사 차원 우선순위 수행</li>
<li>  분석결과에 따른 신속한 Action 가능</li>
<li>  베스트 프랙티스 공유 가능</li>
<li>  부서 분석업무와 역할 분담을 명확히 해야함 → 업무 과다 이원화 가능성</li>
</ul>
</li>
</ul>
</li>
<li><p>분석 조직 인력 구성</p>
<ul>
<li>  분석 조직(DSCoE: Data Science Center of Excellence)</li>
<li>  비즈니스 인력, IT 기술 인력, 분석 전문 인력, 변화 관리 인력, 교육 담당 인력</li>
</ul>
</li>
</ul>
<h3 id="6-분석-과제-관리-프로세스-수립"><a href="#6-분석-과제-관리-프로세스-수립" class="headerlink" title="6. 분석 과제 관리 프로세스 수립"></a>6. 분석 과제 관리 프로세스 수립</h3><ul>
<li>과제 관리 프로세스<ol>
<li> 과제 발굴: 분석 idea 발굴 → 분석 과제 후보 제안 → 분석 과제 확정</li>
<li> 과제 수행: → 탐구성 → 분석 과제 실행 → 분석 과제 진행 관리 → 결과 공유 및 개선</li>
</ol>
</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/14/ADsP/Part02_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B6%84%EC%84%9D_%EA%B8%B0%ED%9A%8D/" data-id="ckjqkgb9y001fwkue0hhf8nip" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADSP%EC%9E%90%EA%B2%A9%EC%A6%9D/" rel="tag">ADSP자격증</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADsP/" rel="tag">ADsP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80/" rel="tag">데이터분석준전문가</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-빅데이터분석과_R프로그래밍/Ⅲ_R_데이터구조" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/13/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A2_R_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0/">빅데이터 분석과 R 프로그래밍 1: Ⅲ. R 데이터구조</a>
    </h1>
  

        <a href="/2020/11/13/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A2_R_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0/" class="article-date">
  <time datetime="2020-11-13T00:00:00.000Z" itemprop="datePublished">2020-11-13</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>  POSTECH에서 제공하는 <a target="_blank" rel="noopener" href="https://pabi.smartlearn.io/">MOOC</a> 중, 빅데이터분석과 R프로그래밍 Ⅰ 과정입니다.</li>
</ul>
<h2 id="1-R-데이터-생성"><a href="#1-R-데이터-생성" class="headerlink" title="1. R 데이터 생성"></a>1. R 데이터 생성</h2><h3 id="파일-불러들이기"><a href="#파일-불러들이기" class="headerlink" title="파일 불러들이기"></a>파일 불러들이기</h3><ol>
<li><p>csv</p>
<p> brain &lt;- read.csv(“week3_2/brain2210.csv”, header=T)</p>
</li>
<li><p> xls  </p>
</li>
</ol>
<ul>
<li>*.xls 파일인 경우, 데이터를 csv(comma separated value)로 저장한<br>  다음 read.csv 함수를 사용해 r로 불러들이는 게 편리  </li>
<li>  readxl로도 가능함</li>
</ul>
<ol>
<li> txt</li>
</ol>
<pre><code>파일을 부를 이름 &lt;- read.table(file = &quot;파일명.txt, na = &quot; &quot;, header = TRUE)</code></pre>
<h3 id="데이터-저장-폴더"><a href="#데이터-저장-폴더" class="headerlink" title="데이터 저장 폴더"></a>데이터 저장 폴더</h3><ul>
<li>데이터와 프로그램 저장 폴더 지정<ul>
<li>  폴더 이름은 영문으로 생성할 것</li>
</ul>
</li>
<li>  r 프로그램의 기본 경로 지정하는 명령어</li>
</ul>
<pre><code># change working directory
#set working directory
setwd(&quot;경로&quot;) 

# check the current working directory
getwd()</code></pre>
<h3 id="데이터와-변수-이름"><a href="#데이터와-변수-이름" class="headerlink" title="데이터와 변수 이름"></a>데이터와 변수 이름</h3><p>attach를 사용하면 정의된 파일 이름 입력 없이 바로 항목 조회가 가능</p>
<pre><code># attach 사용  
attach(brain)  

# 원래대로라면  
table(brain$sex)  

## 
##   f   m 
##  77 108

# attach를 쓰고 나면  
table(sex)  

## sex
##   f   m 
##  77 108</code></pre>
<h2 id="2-R-데이터-활용-Ⅰ"><a href="#2-R-데이터-활용-Ⅰ" class="headerlink" title="2. R 데이터 활용 Ⅰ"></a>2. R 데이터 활용 Ⅰ</h2><h3 id="데이터-추출-subset"><a href="#데이터-추출-subset" class="headerlink" title="데이터 추출_subset"></a>데이터 추출_subset</h3><ul>
<li>subset(데이터 이름, 조건)<br>  예제 1. brain 데이터에서 female만 있는 subset 데이터 생성</li>
</ul>
<pre><code>brainf &lt;- subset(brain, sex = &quot;f&quot;)
mean(brainf$wt)

## [1] 1206.822</code></pre>
<p>예제 2. brain 데이터에서 wt &lt; 1300 이하인 데이터 생성</p>
<pre><code># subset with wt &lt; 1300
brain1300 &lt;- subset(brain, brain$wt &lt; 1300)

# same subset of brain1300
# brain1300 &lt;- subset(brain, !brain@wt =&gt; 1300)
summary(brain1300)

##        wt           sex           
##  Min.   : 915   Length:138        
##  1st Qu.:1074   Class :character  
##  Median :1155   Mode  :character  
##  Mean   :1145                     
##  3rd Qu.:1230                     
##  Max.   :1289

# subset with female
# brainf &lt;- subset(brain, sex = &quot;f&quot;)
brainf &lt;- subset(brain, sex == &quot;f&quot;)
mean(brainf$wt)

## [1] 1117.169

sd(brainf$wt)

## [1] 98.97094

# subset with male
brainm &lt;- subset(brain, sex == &quot;m&quot;)
mean(brainm$wt)

## [1] 1270.741

sd(brainm$wt)

## [1] 129.22</code></pre>
<h3 id="요약통계치-그룹별-aggregate"><a href="#요약통계치-그룹별-aggregate" class="headerlink" title="요약통계치 (그룹별)_aggregate"></a>요약통계치 (그룹별)_aggregate</h3><ul>
<li>  aggregate(변수~그룹, 데이터, 함수)</li>
</ul>
<pre><code># &#39;aggregate&#39; for statistics by group
aggregate(wt~sex, data = brain, FUN = mean)

##   sex       wt
## 1   f 1117.169
## 2   m 1270.741

aggregate(wt~sex, data = brain, FUN = sd)

##   sex        wt
## 1   f  98.97094
## 2   m 129.21997</code></pre>
<ul>
<li>  추출한 데이터의 활용 (그룹별 히스토그램)</li>
</ul>
<pre><code># histogram for female and male
# 2*2 multiple plot
par(mfrow=c(2,2))
brainf&lt;-subset(brain,brain$sex==&#39;f&#39;) 
hist(brainf$wt, breaks = 12,col = &quot;green&quot;,cex=0.7, main=&quot;Histogram (Female)&quot; ,xlab=&quot;brain weight&quot;)

# subset with male
brainm&lt;-subset(brain,brain$sex==&#39;m&#39;) 
hist(brainm$wt, breaks = 12,col = &quot;orange&quot;, main=&quot;Histogram with (Male)&quot; ,  xlab=&quot;brain weight&quot;)</code></pre>
<p><img src="/images/mooc/r_programming/unnamed-chunk-7-1.png"></p>
<ul>
<li>  추출한 데이터의 활용</li>
</ul>
<pre><code># histogram with same scale
hist(brainf$wt, breaks = 12,col = &quot;green&quot;,cex=0.7, main=&quot;Histogram with Normal Curve (Female)&quot; , xlim=c(900,1700),ylim=c(0,25), xlab=&quot;brain weight&quot;)</code></pre>
<p><img src="/images/mooc/r_programming/unnamed-chunk-8-1.png"></p>
<pre><code>hist(brainm$wt, breaks = 12,col = &quot;orange&quot;, main=&quot;Histogram with Normal Curve (Male)&quot; , xlim=c(900,1700), ylim=c(0,25),xlab=&quot;brain weight&quot;)</code></pre>
<p><img src="/images/mooc/r_programming/unnamed-chunk-8-2.png"></p>
<ul>
<li>  csv로 내보내기</li>
</ul>
<pre><code># plot margin
# par(mar=c(2,2,2,2))

# export csv file - write out to csv file 
write.table(brainf,file=&quot;week3_2/brainf.csv&quot;, row.names = FALSE, sep=&quot;,&quot;, na=&quot; &quot;)

write.csv(brainf,file=&quot;week3_2/brainf.csv&quot;, row.names = FALSE)

# export txt file 
write.table(brainm, file=&quot;week3_2/brainm.txt&quot;, row.names = FALSE,  na=&quot; &quot;)</code></pre>
<ul>
<li>퀴즈<br>  brain1000 &lt;- subset(brain, brain$wt &lt; 1000) brain1000</li>
</ul>
<p>table(brain1000)</p>
<h2 id="3-R-데이터-활용-Ⅱ"><a href="#3-R-데이터-활용-Ⅱ" class="headerlink" title="3. R 데이터 활용 Ⅱ"></a>3. R 데이터 활용 Ⅱ</h2><h3 id="dplyr-패키지"><a href="#dplyr-패키지" class="headerlink" title="dplyr 패키지"></a>dplyr 패키지</h3><pre><code>library(dplyr)

## 
## Attaching package: &#39;dplyr&#39;

## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag

## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union

car &lt;- read.csv(&quot;week3_3/autompg.csv&quot;)
head(car)

##   mpg cyl disp hp   wt accler year origin                   carname
## 1  18   8  307 17 3504   12.0   70      1 chevrolet chevelle malibu
## 2  15   8  350 35 3693   11.5   70      1         buick skylark 320
## 3  18   8  318 29 3436   11.0   70      1        plymouth satellite
## 4  16   8  304 29 3433   12.0   70      1             amc rebel sst
## 5  17   8  302 24 3449   10.5   70      1               ford torino
## 6  15   8  429 42 4341   10.0   70      1          ford galaxie 500</code></pre>
<p>데이터 구조 파악하기</p>
<pre><code># 데이터의 수와 변수는?
dim(car)

## [1] 398   9

# 데이터 수: 398개, 변수: 9개

# 데이터 전체 주고 파악하기: str 함수
str(car)

## &#39;data.frame&#39;:    398 obs. of  9 variables:
##  $ mpg    : num  18 15 18 16 17 15 14 14 14 15 ...
##  $ cyl    : int  8 8 8 8 8 8 8 8 8 8 ...
##  $ disp   : num  307 350 318 304 302 429 454 440 455 390 ...
##  $ hp     : num  17 35 29 29 24 42 47 46 48 40 ...
##  $ wt     : int  3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ...
##  $ accler : num  12 11.5 11 12 10.5 10 9 8.5 10 8.5 ...
##  $ year   : int  70 70 70 70 70 70 70 70 70 70 ...
##  $ origin : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ carname: chr  &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ...

# num: 실수, int: 정수

# 데이터 요약하기: summary 함수
summary(car)

##       mpg             cyl             disp             hp              wt      
##  Min.   : 9.00   Min.   :3.000   Min.   : 68.0   Min.   : 1.00   Min.   :1613  
##  1st Qu.:17.50   1st Qu.:4.000   1st Qu.:104.2   1st Qu.:26.00   1st Qu.:2224  
##  Median :23.00   Median :4.000   Median :148.5   Median :60.50   Median :2804  
##  Mean   :23.51   Mean   :5.455   Mean   :193.4   Mean   :51.39   Mean   :2970  
##  3rd Qu.:29.00   3rd Qu.:8.000   3rd Qu.:262.0   3rd Qu.:79.00   3rd Qu.:3608  
##  Max.   :46.60   Max.   :8.000   Max.   :455.0   Max.   :94.00   Max.   :5140  
##      accler           year           origin        carname         
##  Min.   : 8.00   Min.   :70.00   Min.   :1.000   Length:398        
##  1st Qu.:13.82   1st Qu.:73.00   1st Qu.:1.000   Class :character  
##  Median :15.50   Median :76.00   Median :1.000   Mode  :character  
##  Mean   :15.57   Mean   :76.01   Mean   :1.573                     
##  3rd Qu.:17.18   3rd Qu.:79.00   3rd Qu.:2.000                     
##  Max.   :24.80   Max.   :82.00   Max.   :3.000

# 데이터 요약통계치(빈도 구하기): table 함수
attach(car) # attach를 쓰면 변수에 이름을 안 써도 됨

## The following object is masked from brain:
## 
##     wt

table(origin)

## origin
##   1   2   3 
## 249  70  79

table(year)

## year
## 70 71 72 73 74 75 76 77 78 79 80 81 82 
## 29 28 28 40 27 30 34 28 36 29 29 29 31

# 데이터 요약통계치 (평균, 표준편차): mean
mean(mpg)

## [1] 23.51457

mean(hp)

## [1] 51.38945

mean(wt)

## [1] 2970.425</code></pre>
<h2 id="4-데이터-핸들링"><a href="#4-데이터-핸들링" class="headerlink" title="4. 데이터 핸들링"></a>4. 데이터 핸들링</h2><h3 id="dplyr-활용"><a href="#dplyr-활용" class="headerlink" title="dplyr 활용"></a>dplyr 활용</h3><p>dplyr: 전처리 과정을 하기 위한 편리한 기능</p>
<pre><code>library(dplyr)

attach(car)

## The following objects are masked from car (pos = 3):
## 
##     accler, carname, cyl, disp, hp, mpg, origin, wt, year

## The following object is masked from brain:
## 
##     wt

str(car)

## &#39;data.frame&#39;:    398 obs. of  9 variables:
##  $ mpg    : num  18 15 18 16 17 15 14 14 14 15 ...
##  $ cyl    : int  8 8 8 8 8 8 8 8 8 8 ...
##  $ disp   : num  307 350 318 304 302 429 454 440 455 390 ...
##  $ hp     : num  17 35 29 29 24 42 47 46 48 40 ...
##  $ wt     : int  3504 3693 3436 3433 3449 4341 4354 4312 4425 3850 ...
##  $ accler : num  12 11.5 11 12 10.5 10 9 8.5 10 8.5 ...
##  $ year   : int  70 70 70 70 70 70 70 70 70 70 ...
##  $ origin : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ carname: chr  &quot;chevrolet chevelle malibu&quot; &quot;buick skylark 320&quot; &quot;plymouth satellite&quot; &quot;amc rebel sst&quot; ...</code></pre>
<h3 id="변수-추출-select"><a href="#변수-추출-select" class="headerlink" title="변수 추출: select"></a>변수 추출: select</h3><p>car 데이터에서 mpg, hp 변수만 추출</p>
<pre><code># Data handling usin &quot;dplyr&quot;
# 1 subset data: selecting a few variables
set1 &lt;- select(car, mpg, hp)
head(set1)

##   mpg hp
## 1  18 17
## 2  15 35
## 3  18 29
## 4  16 29
## 5  17 24
## 6  15 42</code></pre>
<p>car 데이터에서 mpg로 시작하는 변수를 제외</p>
<pre><code># 2 subset data: drop variables with -
set2 &lt;- select(car, -starts_with(&quot;mpg&quot;))
head(set2)

##   cyl disp hp   wt accler year origin                   carname
## 1   8  307 17 3504   12.0   70      1 chevrolet chevelle malibu
## 2   8  350 35 3693   11.5   70      1         buick skylark 320
## 3   8  318 29 3436   11.0   70      1        plymouth satellite
## 4   8  304 29 3433   12.0   70      1             amc rebel sst
## 5   8  302 24 3449   10.5   70      1               ford torino
## 6   8  429 42 4341   10.0   70      1          ford galaxie 500</code></pre>
<h3 id="데이터-추출-filter"><a href="#데이터-추출-filter" class="headerlink" title="데이터 추출: filter"></a>데이터 추출: filter</h3><ul>
<li>조건에 맞는 데이터 추출: filter(데이터, 변수 조건, …)<br>  car 데이터에서 mpg가 30보다 큰 행 추출</li>
</ul>
<pre><code># 3 subset data: filter mpg &gt; 50
set3 &lt;- filter(car, mpg &gt; 30)
head(set3)

##   mpg cyl disp hp   wt accler year origin             carname
## 1  31   4   71 62 1773   19.0   71      3 toyota corolla 1200
## 2  35   4   72 66 1613   18.0   71      3         datsun 1200
## 3  31   4   79 64 1950   19.0   74      3         datsun b210
## 4  32   4   71 62 1836   21.0   74      3 toyota corolla 1200
## 5  31   4   76 53 1649   16.5   74      3       toyota corona
## 6  32   4   83 58 2003   19.0   74      3          datsun 710</code></pre>
<h3 id="변수-생성-mutate"><a href="#변수-생성-mutate" class="headerlink" title="변수 생성: mutate"></a>변수 생성: mutate</h3><ul>
<li>  mutate(새로운 변수 이름 = 기존 변수 활용)</li>
<li>  <strong>%&gt;% 파이프 연산자</strong>: 연산자 사용하여 연결</li>
</ul>
<pre><code># create a derived variable
set4 &lt;- car %&gt;%
   filter(!is.na(mpg)) %&gt;%
   mutate(mpg_km = mpg*1.609)
head(set4)

##   mpg cyl disp hp   wt accler year origin                   carname mpg_km
## 1  18   8  307 17 3504   12.0   70      1 chevrolet chevelle malibu 28.962
## 2  15   8  350 35 3693   11.5   70      1         buick skylark 320 24.135
## 3  18   8  318 29 3436   11.0   70      1        plymouth satellite 28.962
## 4  16   8  304 29 3433   12.0   70      1             amc rebel sst 25.744
## 5  17   8  302 24 3449   10.5   70      1               ford torino 27.353
## 6  15   8  429 42 4341   10.0   70      1          ford galaxie 500 24.135

# filter: car 데이터 mpg열의 NA가 아닌 모든 데이터 추출
# mutate: 기존 mpg열을 사용해 새로운 mpg_km열 생성</code></pre>
<h3 id="데이터-요약-통계치-평균"><a href="#데이터-요약-통계치-평균" class="headerlink" title="데이터 요약 통계치(평균)"></a>데이터 요약 통계치(평균)</h3><ul>
<li>  summarize(mean(변수이름))</li>
</ul>
<pre><code># mean and standard deviation
car %&gt;%
   summarize(mean(mpg), mean(hp), mean(wt))

##   mean(mpg) mean(hp) mean(wt)
## 1  23.51457 51.38945 2970.425

# 몇 개 변수의 평균값 한 번에 구하기
select(car, 1:6) %&gt;%
   colMeans() # 데이터를 열로 재구성하여 평균값 구함

##         mpg         cyl        disp          hp          wt      accler 
##   23.514573    5.454774  193.425879   51.389447 2970.424623   15.568090</code></pre>
<h3 id="백터화-요약치-summarize-all-FUN"><a href="#백터화-요약치-summarize-all-FUN" class="headerlink" title="백터화 요약치: summarize_all(FUN)"></a>백터화 요약치: summarize_all(FUN)</h3><ul>
<li>  열추출하여 기술통계치 구하고 요약치 보기</li>
</ul>
<pre><code>a1 &lt;- select(car, 1:6) %&gt;% summarize_all(mean)
a2 &lt;- select(car, 1:6) %&gt;% summarize_all(sd)
a3 &lt;- select(car, 1:6) %&gt;% summarize_all(min)
a4 &lt;- select(car, 1:6) %&gt;% summarize_all(max)

table1 &lt;- data.frame(rbind(a1,a2,a3,a4))
rownames(table1) &lt;- c(&quot;mean&quot;, &quot;sd&quot;, &quot;min&quot;, &quot;max&quot;) # data.frame을 tbl_df로 전환시켰으므로 data.frame으로 원상복귀하여 행 이름을 바꿈

table1

##            mpg      cyl     disp       hp        wt    accler
## mean 23.514573 5.454774 193.4259 51.38945 2970.4246 15.568090
## sd    7.815984 1.701004 104.2698 29.93236  846.8418  2.757689
## min   9.000000 3.000000  68.0000  1.00000 1613.0000  8.000000
## max  46.600000 8.000000 455.0000 94.00000 5140.0000 24.800000</code></pre>
<h3 id="그룹별-통계량-group-by"><a href="#그룹별-통계량-group-by" class="headerlink" title="그룹별 통계량: group_by"></a>그룹별 통계량: group_by</h3><ul>
<li>  group_by(변수), summarize(__=FUN()) 그룹별 요약통계량 구하기</li>
</ul>
<pre><code># summary statistics by group variable
car %&gt;%
   group_by(cyl) %&gt;%
   summarize(mean_mpg = mean(mpg), na.rm = TRUE)

## `summarise()` ungrouping output (override with `.groups` argument)

## # A tibble: 5 x 3
##     cyl mean_mpg na.rm
##   &lt;int&gt;    &lt;dbl&gt; &lt;lgl&gt;
## 1     3     20.6 TRUE 
## 2     4     29.3 TRUE 
## 3     5     27.4 TRUE 
## 4     6     20.0 TRUE 
## 5     8     15.0 TRUE

# group_by: car 데이터의 cyl열을 그룹으로 묶음
# summarize: cyl그룹의 mpg 평균을 구함
# na.rm = TURE: 통계 분석 시 결측값을 제외</code></pre>
<ul>
<li>  퀴즈</li>
</ul>
<pre><code>height &lt;- c(165, 170, 155, 185)  
weight &lt;- c(55, 65, 50, 110)  
gender &lt;- c(&quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;)

df &lt;- data.frame(height, weight, gender)

df

##   height weight gender
## 1    165     55 Female
## 2    170     65   Male
## 3    155     50 Female
## 4    185    110   Male

df %&gt;% 
   group_by(height) %&gt;%
   summarize(result = mean(gender))

## Warning in mean.default(gender): argument is not numeric or logical: returning
## NA

## Warning in mean.default(gender): argument is not numeric or logical: returning
## NA

## Warning in mean.default(gender): argument is not numeric or logical: returning
## NA

## Warning in mean.default(gender): argument is not numeric or logical: returning
## NA

## `summarise()` ungrouping output (override with `.groups` argument)

## # A tibble: 4 x 2
##   height result
##    &lt;dbl&gt;  &lt;dbl&gt;
## 1    155     NA
## 2    165     NA
## 3    170     NA
## 4    185     NA

summarize(group_by(df, gender), result=mean(height))

## `summarise()` ungrouping output (override with `.groups` argument)

## # A tibble: 2 x 2
##   gender result
##   &lt;chr&gt;   &lt;dbl&gt;
## 1 Female   160 
## 2 Male     178.

filter(df, gender = c(&quot;Male&quot;, &quot;Female&quot;)) %&gt;%
   summarize(result = mean())

## Error: Problem with `filter()` input `..1`.
## x Input `..1` is named.
## i This usually means that you&#39;ve used `=` instead of `==`.
## i Did you mean `gender == c(&quot;Male&quot;, &quot;Female&quot;)`?

df %&gt;%
   select(height) %&gt;%
   summarize(result = mean(gender))

## Warning in mean.default(gender): argument is not numeric or logical: returning
## NA

##   result
## 1     NA</code></pre>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/13/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A2_R_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B5%AC%EC%A1%B0/" data-id="ckjqkgb9r0011wkuebbyfdkrg" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postech-MOOC/" rel="tag">Postech_MOOC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R-programming/" rel="tag">R programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dplyr/" rel="tag">dplyr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/r-data/" rel="tag">r data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/read-csv/" rel="tag">read csv</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ADsP/Part01_데이터_이해" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/12/ADsP/Part01_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9D%B4%ED%95%B4/">ADsP 자격증: Part01. 데이터 이해</a>
    </h1>
  

        <a href="/2020/11/12/ADsP/Part01_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9D%B4%ED%95%B4/" class="article-date">
  <time datetime="2020-11-12T00:00:00.000Z" itemprop="datePublished">2020-11-12</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>  해당 자료는 <a target="_blank" rel="noopener" href="http://www.dataedu.kr/product/adsp-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D-%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80-2020-%EC%99%84%EC%A0%84%EA%B0%9C%EC%A0%95%ED%8C%90/">ADsP 데이터분석 준전문가 2020 완전 개정판</a> 요약본으로 저작권은 DATA EDU에 있습니다.</li>
</ul>
<h1 id="1장-데이터의-이해"><a href="#1장-데이터의-이해" class="headerlink" title="1장. 데이터의 이해"></a>1장. 데이터의 이해</h1><h2 id="1절-데이터와-정보"><a href="#1절-데이터와-정보" class="headerlink" title="1절. 데이터와 정보"></a>1절. 데이터와 정보</h2><h3 id="1-데이터의-정의와-특성"><a href="#1-데이터의-정의와-특성" class="headerlink" title="1. 데이터의 정의와 특성"></a>1. 데이터의 정의와 특성</h3><ul>
<li><p>데이터의 정의</p>
<ul>
<li>  데이터는 1646년 영군 문헌에 처음 등장, 라틴어인 dare(주다)의 과거분사형으로 주어진 것이라는 의미  </li>
<li>  데이터는 추론과 추정의 근거를 이루는 사실  </li>
<li>단순한 객체로서의 가치뿐 아니라 다른 객체와의 상호관계 속에서 가치를 가짐    <br>
</li>
</ul>
</li>
<li><p>데이터의 특성</p>
  <table>
  <thead>
  <tr class="header">
  <th>구분</th>
  <th>특성</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>존재적 특성</td>
  <td>객관적 사실(fact, raw material)</td>
  </tr>
  <tr class="even">
  <td>당위적 특성</td>
  <td>추론·예측·전망·추정을 위한 근거(basis)</td>
  </tr>
  </tbody>
  </table>

</li>
</ul>
<h3 id="2-데이터의-유형"><a href="#2-데이터의-유형" class="headerlink" title="2. 데이터의 유형"></a>2. 데이터의 유형</h3><table>
<thead>
<tr class="header">
<th>구분</th>
<th>형태</th>
<th>예</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>정성적 데이터(qualitative data)</td>
<td>언어, 문자 등</td>
<td>회사 매출 증가</td>
<td>저장·검색·분석에 많은 비용 소모</td>
</tr>
<tr class="even">
<td>정량적 데이터(quantitative data)</td>
<td>수치, 도형, 기호 등</td>
<td>나이, 몸무게, 주가 등</td>
<td>정형화된 데이터로 비용 소모 적음</td>
</tr>
</tbody>
</table>

<h3 id="3-지식경영의-핵심-이슈"><a href="#3-지식경영의-핵심-이슈" class="headerlink" title="3. 지식경영의 핵심 이슈"></a>3. 지식경영의 핵심 이슈</h3><ul>
<li><p>데이터는 지식경영의 핵심 이슈인 암묵지(tacit knowledge)와 형식지(explicit knowledge)의 상호 작용에 있어 중요한 역할을 함</p>
  <table>
  <thead>
  <tr class="header">
  <th>구분</th>
  <th>의미</th>
  <th>예</th>
  <th>특징</th>
  <th>상호작용</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>암묵지</td>
  <td>학습/경험으로 개인에 체화되어 있지만 드러나지 않는 지식</td>
  <td>김장, 자전거 타기</td>
  <td>사회적으로 중요하지만 공유 어려움</td>
  <td>공통화, 내면화</td>
  </tr>
  <tr class="even">
  <td>형식지</td>
  <td>문서/매뉴얼처럼 형상화된 지식</td>
  <td>교과서, 비디오, DB</td>
  <td>전달과 공유 용이</td>
  <td>표출화, 연결화</td>
  </tr>
  </tbody>
  </table>

<ul>
<li>  암묵지: 개인에게 축적된 내면화(internalization)된 지식 → 조직의 지식으로 공통화(socialization)  </li>
<li>  형식지: 언어, 기호, 숫자로 표출화(externalization)된 지식 → 개인의 지식으로 연결화(combination)</li>
</ul>
</li>
</ul>
<h3 id="4-데이터와-정보의-관계"><a href="#4-데이터와-정보의-관계" class="headerlink" title="4. 데이터와 정보의 관계"></a>4. 데이터와 정보의 관계</h3><ul>
<li><p>DIKW의 정의</p>
  <table>
  <thead>
  <tr class="header">
  <th>구분</th>
  <th>내용</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>데이터(data)</td>
  <td>개별 데이터 자체로는 의미가 중요하지 않은 객관적 사실</td>
  </tr>
  <tr class="even">
  <td>정보(information)</td>
  <td>데이터 가공, 처리와 데이터 간 연관관계 속에서 의미가 도출된 것</td>
  </tr>
  <tr class="odd">
  <td>지식(knowledge)</td>
  <td>도출된 정보를 구조화해 유의미한 정보 분류, 개인 경험과 결합시켜 고유의 지식으로 내재화된 것</td>
  </tr>
  <tr class="even">
  <td>지혜(wisdon)</td>
  <td>지식의 축적과 아이디어가 결합된 창의적 산물</td>
  </tr>
  </tbody>
  </table>
</li>
<li><p>DIKW 피라미드</p>
<ul>
<li>지혜: 근본 원리에 대한 깊은 이해를 바탕으로 도출되는 창의적 아이디어<br>  i.e. A마트의 다른 상품도 B마트보다 저렴할 것이다.  </li>
<li>지식: 상호 연결된 정보 패턴을 이해하여 이를 토대로 예측한 결과물<br>  i.e. 상대적으로 저렴한 A마트에서 연필을 사야겠다.  </li>
<li>정보: 데이터 가공 및 상관관계를 이해하여 패턴을 인식하고 의미를 부여한 데이터<br>  i.e. A마트에서 파는 연필이 더 저렴하다.  </li>
<li>데이터: 존재형식을 불문하고, 타 데이터와 상관관계 있는 가공 전의 순수한 수치나 기호<br>  : 연필은 A마트에서는 100원에, B마트에서는 200원에 판매된다.</li>
</ul>
</li>
</ul>
<h2 id="2절-데이터베이스-정의와-특징"><a href="#2절-데이터베이스-정의와-특징" class="headerlink" title="2절. 데이터베이스 정의와 특징"></a>2절. 데이터베이스 정의와 특징</h2><h3 id="1-용어의-연혁"><a href="#1-용어의-연혁" class="headerlink" title="1. 용어의 연혁"></a>1. 용어의 연혁</h3><ul>
<li>  1950년대: 미국, 군비상황 집중 관리를 위해 컴퓨터 도서관 설립 → 데이터의 기지(base)라는 뜻의 데이터베이스 탄생</li>
<li>  1975년: 미국의 CAC가 KORSTIC을 통해 서비스되며 우리나라에서 데이터베이스 이용</li>
<li>  1980년대 중반: 국내 데이터베이스 관련 기술의 연구 및 개발</li>
</ul>
<h3 id="2-데이터베이스-정의"><a href="#2-데이터베이스-정의" class="headerlink" title="2. 데이터베이스 정의"></a>2. 데이터베이스 정의</h3><ul>
<li>  1차 개념 확대: 정형데이터 관리</li>
<li>  2차 개념 확대: 빅데이터의 출현으로 비정형데이터 포함</li>
</ul>
<h3 id="3-데이터베이스의-특징"><a href="#3-데이터베이스의-특징" class="headerlink" title="3. 데이터베이스의 특징"></a>3. 데이터베이스의 특징</h3><ul>
<li>  데이터베이스의 일반적 특징</li>
</ul>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>데이터베이스 특징</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>통합된(integrated) 데이터</td>
<td>동일한 내용의 데이터가 중복되지 않음, 데이터 중복은 관리상 부작용 초래</td>
</tr>
<tr class="even">
<td>저장된(stored) 데이터</td>
<td>컴퓨터가 접근할 수 있는 저장 매체에 저장, 데이터베이스는 컴퓨터 기술 바탕</td>
</tr>
<tr class="odd">
<td>공용(shared) 데이터</td>
<td>여러 사용자가 서로 다른 목적으로 데이터 이용, 대용량화 &amp; 복잡한 구조</td>
</tr>
<tr class="even">
<td>변화되는(changable) 데이터</td>
<td>데이터베이스에 저장된 내용은 데이터베이스의 현 시점의 상태를 나타냄, 항상 변화하면서도 현재의 정확한 데이터 유지 필요</td>
</tr>
</tbody>
</table>

<ul>
<li>데이터베이스의 다양한 측면에서의 특징<ul>
<li><strong>정보 축적 및 전달</strong><ul>
<li>  기계가독성: 일정 형식에 따라 컴퓨터 등 정보처리기기가 읽고 쓸 수 있음</li>
<li>  검색가독성: 다양한 방법으로 필요한 정보 검색</li>
<li>  원격조작성: 정보통신망을 통해 원거리에서도 즉시 온라인 이용</li>
</ul>
</li>
<li><strong>정보 이용</strong><ul>
<li>  이용자의 정보 요구에 맞게 다양한 정보를 신속하게 획득</li>
<li>  원하는 정보를 정확하고 경제적으로 찾아낼 수 있음</li>
</ul>
</li>
<li><strong>정보 관리</strong><ul>
<li>  정보를 일정한 질서와 구조에 따라 정리, 저장, 검색, 관리할 수 있도록 하여 방대한 양의 정보를 체계적으로 축적</li>
<li>  새로운 내용의 추가 또는 갱신이 용이</li>
</ul>
</li>
<li><strong>정보 기술 발전</strong><ul>
<li>  정보처리, 검색·관리 소프트웨어, 관련된 하드웨어, 네트워크기술 발전 견인</li>
</ul>
</li>
<li><strong>경제·산업</strong><ul>
<li>  정보 인프라적 특성</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3절-데이터베이스의-활용"><a href="#3절-데이터베이스의-활용" class="headerlink" title="3절. 데이터베이스의 활용"></a>3절. 데이터베이스의 활용</h2><ul>
<li><p>기업내부 데이터베이스</p>
<ul>
<li><p>1980년대 기업내부 데이터베이스</p>
<ul>
<li><p>  OLTP(On-Line Transaction Processing)  </p>
</li>
<li><p>  호스트 컴퓨터와 온라인으로 접속된 여러 단말간 처리 형태의 하나</p>
</li>
<li><p>  호스트 컴퓨터가 데이터베이스를 엑세스하고, 처리 결과를 바로 돌려보내는 형태</p>
</li>
<li><p>  주문입력시스템 재고관리시스템 등 현업의 대부분 업무가 이 성격을 띔</p>
</li>
<li><p>  OLAP(On-Line Analytical Processing)  </p>
</li>
<li><p>  다양한 비즈니스 관점에서 쉽고 빠르게 다차원적 데이터 접근하여 의사 결정에 활용할 수 있는 정보를 얻게 하는 기술</p>
</li>
<li><p>  OLTP에서 처리된 트랜잭션 데이터로 다양한 분석 실행  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OLTP가 데이터 갱신 위주라면, OLAP는 데이터 조회 위주 (비교 보기 p.69)</p>
<ul>
<li>2000년대 기업내부 데이터베이스<ul>
<li>  CRM(Customer Relationship Management)</li>
<li>  SCM(Supply Chain Management) </li>
</ul>
</li>
<li>분야별 내부 데이터베이스<ul>
<li>  제조: ERP(Enterprise Resource Planning), BI(Business Intelligence), CRM, RTE(Real-Time Enterprise)  </li>
<li>  금융: EAI(Enterprise Application Integration), EDW(Enterprise Data Warehouse)</li>
<li>  유통: KMS(Knowledge Management System), RFID(RF, Radio Frequency)</li>
</ul>
</li>
<li>사회기반구조로서의 데이터베이스<ul>
<li>  EDI(Electronic Data Interchange), VAN(Value Added Network), CALS(Commerce At Light Speed)</li>
</ul>
</li>
</ul>
<h1 id="2장-데이터의-가치와-미래"><a href="#2장-데이터의-가치와-미래" class="headerlink" title="2장. 데이터의 가치와 미래"></a>2장. 데이터의 가치와 미래</h1><h2 id="1절-빅데이터의-이해"><a href="#1절-빅데이터의-이해" class="headerlink" title="1절. 빅데이터의 이해"></a>1절. 빅데이터의 이해</h2><h3 id="1-빅데이터의-이해"><a href="#1-빅데이터의-이해" class="headerlink" title="1. 빅데이터의 이해"></a>1. 빅데이터의 이해</h3><ul>
<li><p>관점에 따른 빅데이터의 정의</p>
<ul>
<li>  <strong>좁은 범위의 정의</strong>: 3V로 요약되는 데이터 자체의 특성 변화에 초점</li>
<li>  <strong>중간 범위의 정의</strong>: 데이터 자체뿐 아니라 처리, 분석의 기술적 변화까지 포함</li>
<li>  <strong>넓은 관점에서의 정의</strong>: 인재, 조직 변화까지 포함  </li>
</ul>
</li>
<li><p>가트너 그룹 더그 래니의 3V</p>
<ul>
<li>  양(Volume): 데이터 규모 측면 → 센싱 데이터, 비정형데이터</li>
<li>  다양성(Variety): 데이터 유형과 소스 측면 → 정형, 비정형데이터(영상, 사진)</li>
<li>  속도(Velocity): 대이터 수집과 처리 측면 → 원하는 데이터 추출 및 분석 속도</li>
<li>  PLUS, 가치(Value), 시각화(Visualization), 정확성(Veracity)  </li>
</ul>
</li>
<li><p>빅데이터 정의의 범주 및 효과</p>
<ul>
<li>  데이터 변화: 규모, 형태, 속도</li>
<li>  기술 변화: 데이터 처리, 저장, 분석기술 및 아키텍처, 클라우드 컴퓨팅 활용</li>
<li>  인재, 조직 변화: Data Scientist 같은 새로운 인재 필요, 데이터 중심 조직</li>
</ul>
</li>
</ul>
<h3 id="2-출현-배경과-변화"><a href="#2-출현-배경과-변화" class="headerlink" title="2. 출현 배경과 변화"></a>2. 출현 배경과 변화</h3><p>없던 것이 새로 등장한 것이 아니라, 기존의 것에서 변화된 것 - 3가지 출현 배경</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>출현 배경</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>산업계</td>
<td>고객 데이터 축적</td>
<td>데이터에 숨은 가치를 발굴해 새로운 성장동력원 확보</td>
</tr>
<tr class="even">
<td>학계</td>
<td>거대 데이터 활용, 과학 확산</td>
<td>거대 데이터를 다루는 학문이 많아지면서 필요한 기술 아키텍처 및 통계 도구 발전</td>
</tr>
<tr class="odd">
<td>기술 발전</td>
<td>관련 기술의 발달</td>
<td>디지털화, 저장 기술 발달, 인터넷 보급, 모바일 혁명, 클라우드 컴퓨팅</td>
</tr>
</tbody>
</table>

<h3 id="3-빅데이터의-기능"><a href="#3-빅데이터의-기능" class="headerlink" title="3. 빅데이터의 기능"></a>3. 빅데이터의 기능</h3><ul>
<li><p>비유</p>
  <table>
  <thead>
  <tr class="header">
  <th>비유 대상</th>
  <th>내용</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>산업혁명의 석탄, 철</td>
  <td>제조업 ~ 서비스 분야 생산성을 끌어올려 사회 전반에 혁명적 변화를 가져올 것</td>
  </tr>
  <tr class="even">
  <td>21세기의 원유</td>
  <td>경제 성장에 필요한 정보를 제공하여 산업 생산성을 한 단계 향상 시키고 기존에 없던 새 범주 산업을 만들어 낼 것</td>
  </tr>
  <tr class="odd">
  <td>렌즈</td>
  <td>현미경이 생물학 발전에 미친 영향만큼 데이터가 산업 발전에 영향을 미칠 것</td>
  </tr>
  <tr class="even">
  <td>플랫폼</td>
  <td>공동 활용 목적으로 구축된 유무형의 구조물로써 다양한 서드파티 비즈니스에 활용되며 플랫폼 역할을 할 것</td>
  </tr>
  </tbody>
  </table>


</li>
</ul>
<h3 id="4-빅데이터가-만드는-본질적-변화"><a href="#4-빅데이터가-만드는-본질적-변화" class="headerlink" title="4. 빅데이터가 만드는 본질적 변화"></a>4. 빅데이터가 만드는 본질적 변화</h3><ul>
<li>과거에서 현재로<ul>
<li>  사전 처리 → 사후처리</li>
<li>  표본조사 → 전수조사</li>
<li>  질 → 양</li>
<li>  인과관계 → 상관관계</li>
</ul>
</li>
</ul>
<h2 id="2절-빅데이터의-가치와-영향"><a href="#2절-빅데이터의-가치와-영향" class="headerlink" title="2절. 빅데이터의 가치와 영향"></a>2절. 빅데이터의 가치와 영향</h2><h3 id="1-빅데이터의-가치"><a href="#1-빅데이터의-가치" class="headerlink" title="1. 빅데이터의 가치"></a>1. 빅데이터의 가치</h3><ul>
<li>빅데이터 가치 산정이 어려운 이유<ul>
<li>  데이터 활용방식: 재사용, 재조합, 다목적용 데이터 개발</li>
<li>  새로운 가치 창출: 기존에 없던 가치를 창출하여 가치 측정이 어려움</li>
<li>  분석 기술 발전: 현재는 가치 없는 데이터가 추후 분석 기법 등장으로 큰 가치를 지닐 수 있음</li>
</ul>
</li>
</ul>
<h3 id="2-빅데이터의-영향"><a href="#2-빅데이터의-영향" class="headerlink" title="2. 빅데이터의 영향"></a>2. 빅데이터의 영향</h3><ul>
<li>빅데이터가 미치는 영향<ul>
<li>  기업: 혁신, 경쟁력 제고, 생산성 향상 → 소비자 행동 분석, 시장 변동 예측</li>
<li>  정부: 환경 탐색, 상황 분석, 미래 대응 → 기상, 인구 이동, 법제 데이터 등 수집</li>
<li>  개인: 목적에 따른 활용 → 개인 인지도 향상에도 빅데이터가 활용</li>
</ul>
</li>
</ul>
<h2 id="3절-비즈니스-모델"><a href="#3절-비즈니스-모델" class="headerlink" title="3절. 비즈니스 모델"></a>3절. 비즈니스 모델</h2><h3 id="1-빅데이터-활용-사례"><a href="#1-빅데이터-활용-사례" class="headerlink" title="1. 빅데이터 활용 사례"></a>1. 빅데이터 활용 사례</h3><ul>
<li>기업<ul>
<li>  구글: 사용자 로그 데이터를 활용한 검색엔진 개발, 기존 페이지랭크 알고리즘 혁신으로 검색 서비스 개선</li>
<li>  월마트: 고객 구매패턴을 분석해 상품 진열에 활용</li>
</ul>
</li>
<li>정부<ul>
<li>  실시간 교통정보 수집, 기후 정보, 지질 활동, 소방 서비스 등 국가 안전 확보를 위해 실시간 모니터링</li>
</ul>
</li>
<li>개인<ul>
<li>  정치인: 선거 승리를 위해 사회관계망 분석 → 유세 지역 선정, 해당 지역 유권자에게 영향을 줄 수 있는 내용을 선정해 효과적인 선거 활동</li>
<li>  가수: 팬들의 음악 청취 기록 분석을 통해 실제 공연에서 부를 노래 순서 선정</li>
</ul>
</li>
</ul>
<h3 id="2-빅데이터-활용-기본-테크닉"><a href="#2-빅데이터-활용-기본-테크닉" class="headerlink" title="2. 빅데이터 활용 기본 테크닉"></a>2. 빅데이터 활용 기본 테크닉</h3><ul>
<li><p>테크닉 종류와 예시</p>
<ul>
<li><p><strong>연관규칙학습</strong></p>
<ul>
<li>변인들 간 주목할 상관관계 확인  </li>
<li>커피를 구매하는 사람이 탄산음료를 더 많이 사는가?  </li>
</ul>
</li>
<li><p><strong>유형분석</strong></p>
<ul>
<li>문서 분류 또는 조직과 팀을 특성에 따라 분류할 때  </li>
<li>이 사용자는 어떤 특성을 가진 집단에 속하는가?  </li>
</ul>
</li>
<li><p><strong>유전자 알고리즘</strong></p>
<ul>
<li>최적화 필요한 문제의 해결책을 선택, 돌연변이 같은 매커니즘으로 점진적으로 진화(evolve)시키는 법  </li>
<li>최대의 시청률을 얻으려면 어떤 프로그램을 어떤 시간대에 방송해야 하는가?  </li>
</ul>
</li>
<li><p><strong>기계학습</strong></p>
<ul>
<li>훈련 데이터로부터 학습한 알려진 특성을 활용해 예측하는 방법  </li>
<li>기존 시청 기록을 바탕으로, 시청자가 현재 보유한 영화 중 어떤 것을 가장 보고 싶어 할까?  </li>
</ul>
</li>
<li><p><strong>회귀분석</strong></p>
<ul>
<li>독립변수를 조작함에 따라, 종속변수가 어떻게 변하는지를 보며 두 변인 관계를 파악  </li>
<li>구매자의 나이가 구매 차량의 타입에 어떤 영향을 미치는가?   </li>
</ul>
</li>
<li><p><strong>감정분석</strong></p>
<ul>
<li>특정 주제에 관해 말하거나 글 쓴 사람의 감정 분석  </li>
<li>새로운 환불 정책에 대한 고객 평가는?  </li>
</ul>
</li>
<li><p><strong>소셜네트워크(사회관계망)분석</strong></p>
<ul>
<li>특정인과 다른 사람이 몇 촌 정도 관계인가를 파악, 영향력 있는 사람을 찾을 때 사용  </li>
<li>고객들 간 관계망은 어떻게 구성되어 있나?</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4절-위기-요인과-통제-방안"><a href="#4절-위기-요인과-통제-방안" class="headerlink" title="4절. 위기 요인과 통제 방안"></a>4절. 위기 요인과 통제 방안</h2><h3 id="1-빅데이터-시대의-위기-요인"><a href="#1-빅데이터-시대의-위기-요인" class="headerlink" title="1. 빅데이터 시대의 위기 요인"></a>1. 빅데이터 시대의 위기 요인</h3><ul>
<li><p><strong>사생활 침해</strong></p>
<ul>
<li>  내용: 개인정보 포함된 데이터가 목적 외에 사용될 경우 사생활 침해 + 사회적 위협으로 변형될 수 있음</li>
<li>  예시: 여행사실을 트위트한 사람 집을 강도가 노리는 사례 → 익명화의 기술 발전 필요  </li>
</ul>
</li>
<li><p><strong>책임 원칙 훼손</strong></p>
<ul>
<li>  내용: 분석대상이 되는 사람들이 예측 알고리즘의 희생양이 될 가능성 증가</li>
<li>  예시: 범죄 예측 프로그램에 의해 범행을 저지르기 전 체포, 신용도와 무관하게 대출 거절</li>
</ul>
</li>
<li><p><strong>데이터 오용</strong>  </p>
<ul>
<li>  내용: 빅데이터으로 한 예측은 항상 맞을 수 없음</li>
<li>  예시: 적군 사망자 수를 전쟁 진척 상황 지표로 사용했으나, 적군 사망자 수가 과장되어 보고</li>
</ul>
</li>
</ul>
<h3 id="2-위기-요인에-따른-통제-방안"><a href="#2-위기-요인에-따른-통제-방안" class="headerlink" title="2. 위기 요인에 따른 통제 방안"></a>2. 위기 요인에 따른 통제 방안</h3><ul>
<li><p><strong>동의에서 책임으로</strong></p>
<ul>
<li>  개인정보 제공자의 동의 → 개인정보 사용자의 책임  </li>
</ul>
</li>
<li><p><strong>결과 기반 책임 원칙 고수</strong></p>
<ul>
<li>  책임원칙 훼손 위기 요인에 대한 통제 방안</li>
<li>  예측 자료에 의한 불이익을 당할 가능성을 최소화하는 장치 마련 필요  </li>
</ul>
</li>
<li><p><strong>알고리즘 접근 허용</strong></p>
<ul>
<li>  데이터 오용 위기요소에 대한 대응책 → 예측 알고리즘의 부당함을 반증할 수 있는 방법</li>
</ul>
</li>
</ul>
<h2 id="5절-미래의-빅데이터"><a href="#5절-미래의-빅데이터" class="headerlink" title="5절. 미래의 빅데이터"></a>5절. 미래의 빅데이터</h2><h3 id="1-빅데이터-활용-3요소"><a href="#1-빅데이터-활용-3요소" class="headerlink" title="1. 빅데이터 활용 3요소"></a>1. 빅데이터 활용 3요소</h3><ul>
<li>기본 3요소<ul>
<li>  <strong>데이터</strong>: 모든 것을 데이터화(Datafication)하는 추세로, 목적없이 축적된 데이터를 통한 창의적인 분석이 가능  </li>
<li>  <strong>기술</strong>: 대용량 데이터를 빠르게 처리하기 위한 알고리즘의 진화, 스스로 학습하고 데이터를 처리할 수 있는 인공지능 기술 출현  </li>
<li>  <strong>인력</strong>: 빅데이터 처리 위한 데이터 사이언티스트와 알고리즈미스트의 역할 → 빅데이터의 다각적 분석을 통한 인사이트 도출이 중요해짐</li>
</ul>
</li>
</ul>
<h1 id="3장-가치-창조를-위한-데이터-사이언스와-전략-인사이트"><a href="#3장-가치-창조를-위한-데이터-사이언스와-전략-인사이트" class="headerlink" title="3장. 가치 창조를 위한 데이터 사이언스와 전략 인사이트"></a>3장. 가치 창조를 위한 데이터 사이언스와 전략 인사이트</h1><h2 id="1절-빅데이터-분석과-전략-인사이트"><a href="#1절-빅데이터-분석과-전략-인사이트" class="headerlink" title="1절. 빅데이터 분석과 전략 인사이트"></a>1절. 빅데이터 분석과 전략 인사이트</h2><h3 id="1-빅데이터-열풍과-회의론"><a href="#1-빅데이터-열풍과-회의론" class="headerlink" title="1. 빅데이터 열풍과 회의론"></a>1. 빅데이터 열풍과 회의론</h3><p>빅데이터 회의론은 실제 빅데이터 분석에서 찾을 수 있는 가치를 발굴하기도 전에 사전에 활용 자체를 차단해 버릴 수 있음</p>
<h3 id="2-빅데이터-회의론의-원인-및-진단"><a href="#2-빅데이터-회의론의-원인-및-진단" class="headerlink" title="2. 빅데이터 회의론의 원인 및 진단"></a>2. 빅데이터 회의론의 원인 및 진단</h3><ul>
<li>  투자효과를 못 거둔 부정적 학습효과 → 과거 CRM</li>
<li>  빅데이터 성공사례 중, 기존 분석 프로젝트를 포함한 것이 많음</li>
</ul>
<h3 id="3-’Big’이-핵심이-아님"><a href="#3-’Big’이-핵심이-아님" class="headerlink" title="3. ’Big’이 핵심이 아님"></a>3. ’Big’이 핵심이 아님</h3><ul>
<li>빅데이터 분석 가치<br>  크기 이슈가 아니라, 어떤 시각과 통찰을 얻을 수 있는지가 중요</li>
</ul>
<h3 id="4-전략적-통찰이-없는-분석의-함정"><a href="#4-전략적-통찰이-없는-분석의-함정" class="headerlink" title="4. 전략적 통찰이 없는 분석의 함정"></a>4. 전략적 통찰이 없는 분석의 함정</h3><h3 id="5-일차원적-분석-vs-가치기반-분석"><a href="#5-일차원적-분석-vs-가치기반-분석" class="headerlink" title="5. 일차원적 분석 vs 가치기반 분석"></a>5. 일차원적 분석 vs 가치기반 분석</h3><ul>
<li>  산업별 분석 애플리케이션 </li>
</ul>
<table>
<thead>
<tr class="header">
<th>산업</th>
<th>일차원적 분석 애플리케이션</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>금융 서비스</td>
<td>신용점수 산정, 사기 탐지, 가격 책정, 프로그램트레이딩, 클레임분석, 고객수익성분석</td>
</tr>
<tr class="even">
<td>소매업</td>
<td>판촉, 매대 관리, 수요 예측, 재고 보충, 가격 및 제조 최적화</td>
</tr>
<tr class="odd">
<td>제조업</td>
<td>공급사슬 최적화, 수요 예측, 재고 보충, 보증서 분석, 맞춤형 상품 개발, 신상품 개발</td>
</tr>
<tr class="even">
<td>운송업</td>
<td>일정 관리, 노선 배정, 수익 관리</td>
</tr>
<tr class="odd">
<td>헬스케어</td>
<td>약품 거래, 예비 진단, 질병 관리</td>
</tr>
<tr class="even">
<td>병원</td>
<td>가격 책정, 고객 로열티, 수익 관리</td>
</tr>
<tr class="odd">
<td>에너지</td>
<td>트레이딩, 공급/수요 예측</td>
</tr>
<tr class="even">
<td>커뮤니케이션</td>
<td>가격 계획 최적화, 고객 보유, 수요 예측, 생산능력 계획, 네트워크 최적화, 고객 수익성 관리</td>
</tr>
<tr class="odd">
<td>서비스</td>
<td>콜센터 직원 관리, 서비스-수익 사슬 관리</td>
</tr>
<tr class="even">
<td>정부</td>
<td>사기 탐지, 사례 관리, 범죄 방지, 수익 최적화</td>
</tr>
<tr class="odd">
<td>온라인</td>
<td>웹 매트릭스, 사이트 설계 고객 추천</td>
</tr>
<tr class="even">
<td>모든사업</td>
<td>성과관리</td>
</tr>
</tbody>
</table>

<ul>
<li><p>  일차원적 분석의 문제점은 환경변화와 같은 큰 변화에 대응하기 어렵고, 새로운 기회를 포착하기 어렵다는 것</p>
</li>
<li><p>전략도출 가치기반 분석</p>
<ul>
<li>  해당 사업에 중요한 기회 발굴, 주요 경영진의 지원 얻기 가능</li>
<li>  분석의 활용 범위를 더 넓고 전략적으로 변화시키는 것 필요</li>
<li>차별화를 위한 전략적 인사이트를 주는 가치기반 분석단계로<br>  나아가야 함</li>
</ul>
</li>
</ul>
<h2 id="2절-전략-인사이트-도출에-필요한-역량"><a href="#2절-전략-인사이트-도출에-필요한-역량" class="headerlink" title="2절. 전략 인사이트 도출에 필요한 역량"></a>2절. 전략 인사이트 도출에 필요한 역량</h2><h3 id="1-데이터-사이언스"><a href="#1-데이터-사이언스" class="headerlink" title="1. 데이터 사이언스"></a>1. 데이터 사이언스</h3><ul>
<li>  데이터사이언스는 데이터로부터 의미 있는 정보를 추출해내는 학문  </li>
<li>  비즈니스 성과를 좌우하는 핵심 이슈에 답하고, 사업의 성과를 견인할 수 있어야 함</li>
</ul>
<h3 id="2-데이터-사이언스의-구성요소"><a href="#2-데이터-사이언스의-구성요소" class="headerlink" title="2. 데이터 사이언스의 구성요소"></a>2. 데이터 사이언스의 구성요소</h3><ul>
<li>데이터 사이언스의 영역<ul>
<li>  <strong>Analytics</strong>: 수학, 확률모델, 머신러닝, 분석학, 패턴 인식과 학습, 불확실성 모델링</li>
<li>  <strong>IT</strong>: 시그널 프로세싱, 프로그래밍, 데이터 엔지니어링, 데이터 웨어하우스, 고성능 컴퓨팅</li>
<li>  <strong>비즈니스 분석</strong>: 커뮤니케이션, 프레젠테이션, 스토리텔링, 시각화</li>
</ul>
</li>
</ul>
<h3 id="3-데이터-사이언티스트-요구-역량"><a href="#3-데이터-사이언티스트-요구-역량" class="headerlink" title="3. 데이터 사이언티스트 요구 역량"></a>3. 데이터 사이언티스트 요구 역량</h3><ul>
<li>Hard Skill<ul>
<li>  빅데이터에 관한 이론적 지식</li>
<li>  분석 기술의 숙련</li>
</ul>
</li>
<li>Soft skill<ul>
<li>  통찰력 있는 분석</li>
<li>  설득력 있는 전달</li>
<li>  다분야간 협력</li>
</ul>
</li>
</ul>
<h3 id="4-데이터-사이언스-과학과-인문의-교차로"><a href="#4-데이터-사이언스-과학과-인문의-교차로" class="headerlink" title="4. 데이터 사이언스: 과학과 인문의 교차로"></a>4. 데이터 사이언스: 과학과 인문의 교차로</h3><p>스토리텔링, 커뮤니케이션, 창의력, 열정, 직관력, 비판적 시각, 대화능력 등의 인문학적 요소가 필요</p>
<h3 id="5-전략적-통찰력과-인문학의"><a href="#5-전략적-통찰력과-인문학의" class="headerlink" title="5. 전략적 통찰력과 인문학의"></a>5. 전략적 통찰력과 인문학의</h3><ul>
<li>  외부 환경 측면에서 본 인문학 열풍 이유</li>
</ul>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>외부환경의 변화</th>
<th>내용</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>컨버전스 → 디버전스</td>
<td>단순세계화에서 복잡한 세계화로 변화</td>
<td>규모의 경제, 세계화, 표준화, 이성화 → 복잡한 세계, 다양성, 관계, 연결성, 창조성</td>
</tr>
<tr class="even">
<td>생산 → 서비스</td>
<td>비즈니스 중심이 제품 생산에서 서비스로 이동</td>
<td>고장나지 않는 제품 → 뛰어난 서비스</td>
</tr>
<tr class="odd">
<td>생산 → 시장 창조</td>
<td>공급자 중심 기술 경쟁에서 무형자산 경쟁으로 변화</td>
<td>생산 기술 중심, 기술 중심 투자 → 패러다임에 근거한 시장 창조, 현지 사회와 문화에 관한 지식</td>
</tr>
</tbody>
</table>

<h2 id="3절-빅데이터-데이터-사이언스의-미래"><a href="#3절-빅데이터-데이터-사이언스의-미래" class="headerlink" title="3절. 빅데이터, 데이터 사이언스의 미래"></a>3절. 빅데이터, 데이터 사이언스의 미래</h2><h3 id="1-가치-패러다임-변화"><a href="#1-가치-패러다임-변화" class="headerlink" title="1. 가치 패러다임 변화"></a>1. 가치 패러다임 변화</h3><ul>
<li>  과거: Digitalization, 아날로그 세상을 디지털화하는지가 가치 창출 원천</li>
<li>  현재: Connection, 디지털화된 정보가 연결되기 시작하면서 효과적인 연결을 찾는 것이 성공 요인</li>
<li>  미래: Agency, 복잡한 연결을 효과적이고 믿을 수 있게 관리하는 것이 중요</li>
</ul>
<h3 id="2-데이터-사이언스의-한계"><a href="#2-데이터-사이언스의-한계" class="headerlink" title="2. 데이터 사이언스의 한계"></a>2. 데이터 사이언스의 한계</h3><ul>
<li>한계<ul>
<li>  분석과정에서는 가정 등 인간의 해석이 개입되는 단계가 반드시 존재</li>
<li>  분석결과를 해석하는 사람에 따라 다른 결과가 도출</li>
<li>  정량적인 분석이라고 할지라도 결국 가정에 근거</li>
</ul>
</li>
</ul>
<h2 id="추가-최신-빅데이터-상식"><a href="#추가-최신-빅데이터-상식" class="headerlink" title="추가. 최신 빅데이터 상식"></a>추가. 최신 빅데이터 상식</h2><h3 id="1-DMBS와-SQL"><a href="#1-DMBS와-SQL" class="headerlink" title="1. DMBS와 SQL"></a>1. DMBS와 SQL</h3><ul>
<li><p><strong>DMBS</strong>(Data Base Management System)</p>
<ul>
<li>  데이터베이스를 관리하여 응용프로그램들이 데이터베이스를 공유하며 사용하는 환경을 제공하는 소프트웨어</li>
<li>  데이터베이스를 구축하는 틀, 데이터 검색, 저장 기능 등 제공</li>
<li>  대표 시스템: 오라클, 인포믹스, 액세스  </li>
</ul>
</li>
<li><p>데이터베이스 관리 시스템의 종류</p>
<ul>
<li>관계형 DBMS<ul>
<li>  데이터를 column과 row를 이루는 하나 이상의 테이블/관계로 정리</li>
<li>  Primary key가 각 row를 식별</li>
<li>  row는 레코드나 튜플로 불림</li>
<li>  일반적으로 각 테이블/관계는 하나의 엔티티 타입(고객이나 제품과 같은)을 대표</li>
</ul>
</li>
<li>객체지향 DMBS<ul>
<li>  일반적으로 사용되는 테이블 기반의 관계형DB와 다르게 정보를 ‘객체’ 형태로 표현하는 데이터베이스 모델</li>
</ul>
</li>
<li>네트워크 DMBS<ul>
<li>  레코드들이 노드로, 레코드들 사이 관계가 간선으로 표현되는 그래프를 기반으로 하는 데이터베이스 모델</li>
</ul>
</li>
<li>계층형 DMBS<ul>
<li>  트리 구조를 기반으로 하는 계층 데이터베이스 모델  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SQL</strong>(Structured Query Language)</p>
<ul>
<li>  데이터베이스에 접근할 수 있는 데이터베이스의 하부 언어</li>
<li>  단순한 질의 기능뿐 아니라 데이터의 완전한 정의와 조작 기능을 갖춤</li>
<li>  테이블 단위로 연산 수행, 영어 문장과 비슷한 구문으로 사용하기 쉬움</li>
</ul>
</li>
</ul>
<h3 id="2-Data-관련-기술"><a href="#2-Data-관련-기술" class="headerlink" title="2. Data 관련 기술"></a>2. Data 관련 기술</h3><ul>
<li><p>개인정보 비식별 기술<br>  데이터 셋에서 개인을 식별할 수 있는 요소를 전부/일부 삭제하거나 다른 값으로 대체하는 기술</p>
  <table>
  <colgroup>
  <col style="width: 33%" />
  <col style="width: 33%" />
  <col style="width: 33%" />
  </colgroup>
  <thead>
  <tr class="header">
  <th>비식별 기술</th>
  <th>내용</th>
  <th>예시</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td>데이터 마스킹</td>
  <td>데이터 길이, 유형, 형식 유지한채, 새로운 데이터를 익명으로 생상</td>
  <td>홍길동, 35세, 서울 거주, 한국대 재학 → 홍–, 35세, 서울 거주, –대학 재학</td>
  </tr>
  <tr class="even">
  <td>가명 처리</td>
  <td>개인정보 주체 이름을 변경하는 기술, 변경 규칙이 노출되지 않아야 함</td>
  <td>홍길동, 35세, 서울 거주, 한국대 재학 → 임꺽정, 30대, 서울 거주, 국내대 재학</td>
  </tr>
  <tr class="odd">
  <td>총계처리</td>
  <td>데이터의 총합값을 보임</td>
  <td>임꺽정 180cm, 홍길동 170cm → 물리학과 학생 키 합: 350cm, 평균키 175cm</td>
  </tr>
  <tr class="even">
  <td>데이터값 삭제</td>
  <td>필요 없는 값 또는 개인식별에 중요한 값을 삭제, 날짜 정보는 연단위 처리</td>
  <td>홍길동, 35세, 서울 거주, 한국대 졸업 → 35세, 서울 거주, 주민번호 901206-1234567 → 90년대 생, 남자</td>
  </tr>
  <tr class="odd">
  <td>데이터 범주화</td>
  <td>데이터 값을 범주 값으로 변환하여 값 숨김</td>
  <td>홍길동, 35세 → 홍씨, 30~40세</td>
  </tr>
  </tbody>
  </table>
</li>
<li><p>무결성과 레이크</p>
<ul>
<li><p>데이터 무결성(Data integrity)</p>
<ul>
<li>  데이터 변경/수정 시 제한을 두어 데이터의 정확성을 보증</li>
<li>  유형: 개체 무결성(Entity integrity), 참조 무결성(Referential integrity), 범위 무결성(Domain integrity)  </li>
</ul>
</li>
<li><p>데이터 레이크(Data Lake)</p>
<ul>
<li>  수많은 정보 속에서 의미 있는 내용을 찾기 위해 방식 상관 없이 데이터를 저장하는 시스템</li>
<li>  대용량의 정형 및 비정형 데이터 저장, 접근이 쉬운 대규모의 저장소</li>
<li>  주요 플랫폼: Apache Hadoop, Teredata Integrated Big Data Platform 1700</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-빅데이터-분석-기술"><a href="#3-빅데이터-분석-기술" class="headerlink" title="3. 빅데이터 분석 기술"></a>3. 빅데이터 분석 기술</h3><ul>
<li><p>Hadoop</p>
<ul>
<li>  여러 컴퓨터를 하나인 것처럼 묶어 대용량 데이터를 처리하는 기술</li>
<li>  분산파일 시스템(HDFS)을 통해 대용량 파일을 저장할 수 있는 기능 제공</li>
<li>  하둡 에코시스템으로 하둡의 부족한 기능 보완  </li>
</ul>
</li>
<li><p>Apache Spark</p>
<ul>
<li>  실시간 분산형 컴퓨팅 플랫폼</li>
<li>  스칼라로 작성되었으나, 스칼라, 자바, R, 파이썬, API 지원</li>
<li>  In-Memory 방식으로 하둡에 비해 처리속도가 빠름  </li>
</ul>
</li>
<li><p>Smart Factory</p>
<ul>
<li>  공장 내 설비와 기계에 사물인터넷이 설치 → 공정 데이터가 실시간으로 수집, 데이터에 기반한 의사결정  </li>
</ul>
</li>
<li><p>Machine Learning &amp; Deep Learning</p>
<ul>
<li>  머신러닝: 인공지능 연구 분야 중 하나, 인간의 학습 능력과 같은 기능을 컴퓨터에서 실현</li>
<li>  딥러닝: 컴퓨터가 데이터를 이용해 스스로 합습하도록 인공신경망(Artificial Neural Natwork) 등 기술로 구축한 기계 학습 기술</li>
</ul>
</li>
</ul>
<h3 id="4-기타"><a href="#4-기타" class="headerlink" title="4. 기타"></a>4. 기타</h3><ul>
<li>  데이터의 유형</li>
</ul>
<pre><code>&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;col style=&quot;width: 33%&quot; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;유형&lt;/th&gt;
&lt;th&gt;내용&lt;/th&gt;
&lt;th&gt;예시&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;정형데이터&lt;/td&gt;
&lt;td&gt;형태(고정된 필드) 존재, 연산 가능, 주로 관계형 데이터베이스에 저장, 데이터 수집 난이도 낮고 형식이 정해져 처리 쉬움&lt;/td&gt;
&lt;td&gt;관계형 데이터베이스, 스프레드시트, CSV&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;반정형데이터&lt;/td&gt;
&lt;td&gt;형태(스키마, 메타데이터) 존재, 연산 불가능, 주로 파일로 저장, 보통 API 형태로 제공되어 데이터 처리 기술(파싱) 필요&lt;/td&gt;
&lt;td&gt;XML. HTML, JSON, 로그형태(웹로그, 센서데이터)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;비정형데이터&lt;/td&gt;
&lt;td&gt;형태 없음, 연산 불가능, 주로 NoSQL에 저장, 데이터 수집 난이도 높음, 텍스트 마이닝 혹은 파일일 경우 데이터 형태로 파싱이 필요해 수집 데이터 처리가 어려움&lt;/td&gt;
&lt;td&gt;소셜데이터(트위터, 페이스북), (영상, 이미지, 음성, 텍스트)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</code></pre>
<ul>
<li>  참고: XML은 Extensible Markup Language의 약자로 다목적 마크업 언어를 이용, 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 함(HTML 한계를 극복할 목적으로 만들어짐)</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/12/ADsP/Part01_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9D%B4%ED%95%B4/" data-id="ckjqkgb9w001bwkueafd5dgdl" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADSP%EC%9E%90%EA%B2%A9%EC%A6%9D/" rel="tag">ADSP자격증</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ADsP/" rel="tag">ADsP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EC%A4%80%EC%A0%84%EB%AC%B8%EA%B0%80/" rel="tag">데이터분석준전문가</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-빅데이터분석과_R프로그래밍/Ⅱ_벡터,행렬의_연산_및_함수" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/11/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A1_%EB%B2%A1%ED%84%B0,%ED%96%89%EB%A0%AC%EC%9D%98_%EC%97%B0%EC%82%B0_%EB%B0%8F_%ED%95%A8%EC%88%98/">빅데이터 분석과 R 프로그래밍 1: Ⅱ. 벡터, 행렬의 연산 및 함수</a>
    </h1>
  

        <a href="/2020/11/11/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A1_%EB%B2%A1%ED%84%B0,%ED%96%89%EB%A0%AC%EC%9D%98_%EC%97%B0%EC%82%B0_%EB%B0%8F_%ED%95%A8%EC%88%98/" class="article-date">
  <time datetime="2020-11-11T00:00:00.000Z" itemprop="datePublished">2020-11-11</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<ul>
<li>  POSTECH에서 제공하는 <a target="_blank" rel="noopener" href="https://pabi.smartlearn.io/">MOOC</a> 중, 빅데이터분석과 R프로그래밍 Ⅰ 과정입니다.</li>
</ul>
<h2 id="1-벡터-및-행렬-생성"><a href="#1-벡터-및-행렬-생성" class="headerlink" title="1. 벡터 및 행렬 생성"></a>1. 벡터 및 행렬 생성</h2><h3 id="벡터-생성"><a href="#벡터-생성" class="headerlink" title="벡터 생성"></a>벡터 생성</h3><ul>
<li>벡터<ul>
<li>  seq 함수 사용 (sequence)</li>
</ul>
</li>
</ul>
<h1 id="0부터-10까지-20개의-값을-생성"><a href="#0부터-10까지-20개의-값을-생성" class="headerlink" title="0부터 10까지, 20개의 값을 생성"></a>0부터 10까지, 20개의 값을 생성</h1><pre><code>y1 &lt;- seq(0, 10, length=20)
y1</code></pre>
<h2 id="1-0-0000000-0-5263158-1-0526316-1-5789474-2-1052632-2-6315789"><a href="#1-0-0000000-0-5263158-1-0526316-1-5789474-2-1052632-2-6315789" class="headerlink" title="[1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632  2.6315789"></a>[1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632  2.6315789</h2><h2 id="7-3-1578947-3-6842105-4-2105263-4-7368421-5-2631579-5-7894737"><a href="#7-3-1578947-3-6842105-4-2105263-4-7368421-5-2631579-5-7894737" class="headerlink" title="[7]  3.1578947  3.6842105  4.2105263  4.7368421  5.2631579  5.7894737"></a>[7]  3.1578947  3.6842105  4.2105263  4.7368421  5.2631579  5.7894737</h2><h2 id="13-6-3157895-6-8421053-7-3684211-7-8947368-8-4210526-8-9473684"><a href="#13-6-3157895-6-8421053-7-3684211-7-8947368-8-4210526-8-9473684" class="headerlink" title="[13]  6.3157895  6.8421053  7.3684211  7.8947368  8.4210526  8.9473684"></a>[13]  6.3157895  6.8421053  7.3684211  7.8947368  8.4210526  8.9473684</h2><h2 id="19-9-4736842-10-0000000"><a href="#19-9-4736842-10-0000000" class="headerlink" title="[19]  9.4736842 10.0000000"></a>[19]  9.4736842 10.0000000</h2><h1 id="0부터-10까지-0-5씩-간격을-두고-값을-생성"><a href="#0부터-10까지-0-5씩-간격을-두고-값을-생성" class="headerlink" title="0부터 10까지, 0.5씩 간격을 두고 값을 생성"></a>0부터 10까지, 0.5씩 간격을 두고 값을 생성</h1><pre><code>y2 &lt;- seq(0, 10, by = 0.5)
y2</code></pre>
<h2 id="1-0-0-0-5-1-0-1-5-2-0-2-5-3-0-3-5-4-0-4-5-5-0-5-5-6-0-6-5-7-0"><a href="#1-0-0-0-5-1-0-1-5-2-0-2-5-3-0-3-5-4-0-4-5-5-0-5-5-6-0-6-5-7-0" class="headerlink" title="[1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0"></a>[1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0</h2><h2 id="16-7-5-8-0-8-5-9-0-9-5-10-0"><a href="#16-7-5-8-0-8-5-9-0-9-5-10-0" class="headerlink" title="[16]  7.5  8.0  8.5  9.0  9.5 10.0"></a>[16]  7.5  8.0  8.5  9.0  9.5 10.0</h2><ul>
<li>  rep 함수 사용 (replication)</li>
</ul>
<h1 id="1부터-4까지-두-번을-반복하여-생성"><a href="#1부터-4까지-두-번을-반복하여-생성" class="headerlink" title="1부터 4까지 두 번을 반복하여 생성"></a>1부터 4까지 두 번을 반복하여 생성</h1><pre><code>z1 &lt;- rep(1:4, 2)
z1</code></pre>
<h2 id="1-1-2-3-4-1-2-3-4"><a href="#1-1-2-3-4-1-2-3-4" class="headerlink" title="[1] 1 2 3 4 1 2 3 4"></a>[1] 1 2 3 4 1 2 3 4</h2><h1 id="1부터-5까지-다섯-번을-반복하여-생성"><a href="#1부터-5까지-다섯-번을-반복하여-생성" class="headerlink" title="1부터 5까지 다섯 번을 반복하여 생성"></a>1부터 5까지 다섯 번을 반복하여 생성</h1><pre><code>z2 &lt;- rep(1:2, 5)
z2</code></pre>
<h2 id="1-1-2-1-2-1-2-1-2-1-2"><a href="#1-1-2-1-2-1-2-1-2-1-2" class="headerlink" title="[1] 1 2 1 2 1 2 1 2 1 2"></a>[1] 1 2 1 2 1 2 1 2 1 2</h2><ul>
<li>백터 결합<ul>
<li>  cbind: column bind (열 기준으로 결합)</li>
</ul>
</li>
</ul>
<pre><code>x &lt;- c(1, 3, 5, 7, 9)
c1 &lt;- c(2, 4, 6, 8, 10)
c2 &lt;- cbind(x, c1)
c2</code></pre>
<h2 id="x-c1"><a href="#x-c1" class="headerlink" title="x c1"></a>x c1</h2><h2 id="1-1-2"><a href="#1-1-2" class="headerlink" title="[1,] 1  2"></a>[1,] 1  2</h2><h2 id="2-3-4"><a href="#2-3-4" class="headerlink" title="[2,] 3  4"></a>[2,] 3  4</h2><h2 id="3-5-6"><a href="#3-5-6" class="headerlink" title="[3,] 5  6"></a>[3,] 5  6</h2><h2 id="4-7-8"><a href="#4-7-8" class="headerlink" title="[4,] 7  8"></a>[4,] 7  8</h2><h2 id="5-9-10"><a href="#5-9-10" class="headerlink" title="[5,] 9 10"></a>[5,] 9 10</h2><ul>
<li>  rbind: row bind (행으로 결합)</li>
</ul>
<pre><code>c3 &lt;- rbind(x, c1)
c3</code></pre>
<h2 id="1-2-3-4-5"><a href="#1-2-3-4-5" class="headerlink" title="[,1] [,2] [,3] [,4] [,5]"></a>[,1] [,2] [,3] [,4] [,5]</h2><h2 id="x-1-3-5-7-9"><a href="#x-1-3-5-7-9" class="headerlink" title="x     1    3    5    7    9"></a>x     1    3    5    7    9</h2><h2 id="c1-2-4-6-8-10"><a href="#c1-2-4-6-8-10" class="headerlink" title="c1    2    4    6    8   10"></a>c1    2    4    6    8   10</h2><ul>
<li>행렬의 생성<ul>
<li>  matrix 함수</li>
</ul>
</li>
</ul>
<h1 id="tow-row-matrix-with-1-to-10"><a href="#tow-row-matrix-with-1-to-10" class="headerlink" title="tow row matrix with 1 to 10"></a>tow row matrix with 1 to 10</h1><pre><code>m1 &lt;- matrix(1:10, nrow=2) #number of row
m1</code></pre>
<h2 id="1-2-3-4-5-1"><a href="#1-2-3-4-5-1" class="headerlink" title="[,1] [,2] [,3] [,4] [,5]"></a>[,1] [,2] [,3] [,4] [,5]</h2><h2 id="1-1-3-5-7-9"><a href="#1-1-3-5-7-9" class="headerlink" title="[1,]    1    3    5    7    9"></a>[1,]    1    3    5    7    9</h2><h2 id="2-2-4-6-8-10"><a href="#2-2-4-6-8-10" class="headerlink" title="[2,]    2    4    6    8   10"></a>[2,]    2    4    6    8   10</h2><h1 id="three-columns-matrix-with-1-6"><a href="#three-columns-matrix-with-1-6" class="headerlink" title="three columns matrix with 1:6"></a>three columns matrix with 1:6</h1><pre><code>m2 &lt;- matrix(1:6, ncol=3)
m2</code></pre>
<h2 id="1-2-3"><a href="#1-2-3" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-1-3-5"><a href="#1-1-3-5" class="headerlink" title="[1,]    1    3    5"></a>[1,]    1    3    5</h2><h2 id="2-2-4-6"><a href="#2-2-4-6" class="headerlink" title="[2,]    2    4    6"></a>[2,]    2    4    6</h2><h1 id="matrix-filled-by-rows-defalut-filled-by-columns"><a href="#matrix-filled-by-rows-defalut-filled-by-columns" class="headerlink" title="matrix filled by rows, defalut: filled by columns"></a>matrix filled by rows, defalut: filled by columns</h1><pre><code>m3 &lt;- matrix(1:6, nrow=2, byrow=T)
m3</code></pre>
<h2 id="1-2-3-1"><a href="#1-2-3-1" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-1-2-3"><a href="#1-1-2-3" class="headerlink" title="[1,]    1    2    3"></a>[1,]    1    2    3</h2><h2 id="2-4-5-6"><a href="#2-4-5-6" class="headerlink" title="[2,]    4    5    6"></a>[2,]    4    5    6</h2><ul>
<li>  고차원 행렬_array 함수</li>
</ul>
<h1 id="higher-order-of-array"><a href="#higher-order-of-array" class="headerlink" title="higher order of array"></a>higher order of array</h1><pre><code>a1 &lt;- array(c(1:18), dim=c(3,3,2)) # 3 by 3 행렬을 2개 만듦
a1</code></pre>
<h2 id="1"><a href="#1" class="headerlink" title=", , 1"></a>, , 1</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-2-3-2"><a href="#1-2-3-2" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-1-4-7"><a href="#1-1-4-7" class="headerlink" title="[1,]    1    4    7"></a>[1,]    1    4    7</h2><h2 id="2-2-5-8"><a href="#2-2-5-8" class="headerlink" title="[2,]    2    5    8"></a>[2,]    2    5    8</h2><h2 id="3-3-6-9"><a href="#3-3-6-9" class="headerlink" title="[3,]    3    6    9"></a>[3,]    3    6    9</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="2"><a href="#2" class="headerlink" title=", , 2"></a>, , 2</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="1-2-3-3"><a href="#1-2-3-3" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-10-13-16"><a href="#1-10-13-16" class="headerlink" title="[1,]   10   13   16"></a>[1,]   10   13   16</h2><h2 id="2-11-14-17"><a href="#2-11-14-17" class="headerlink" title="[2,]   11   14   17"></a>[2,]   11   14   17</h2><h2 id="3-12-15-18"><a href="#3-12-15-18" class="headerlink" title="[3,]   12   15   18"></a>[3,]   12   15   18</h2><h2 id="2-벡터-생성과-이름-주기"><a href="#2-벡터-생성과-이름-주기" class="headerlink" title="2. 벡터 생성과 이름 주기"></a>2. 벡터 생성과 이름 주기</h2><p>===========================</p>
<h3 id="벡터-생성-및-벡터-이름-주기"><a href="#벡터-생성-및-벡터-이름-주기" class="headerlink" title="벡터 생성 및 벡터 이름 주기"></a>벡터 생성 및 벡터 이름 주기</h3><ul>
<li>  (0,1) 값을 갖는 벡터 gender에 0=female, 1=male 값 부여</li>
</ul>
<pre><code>gender &lt;- c(0,1)
names(gender) &lt;- c(&quot;female&quot;, &quot;male&quot;)
gender</code></pre>
<h2 id="female-male"><a href="#female-male" class="headerlink" title="female   male"></a>female   male</h2><h2 id="0-1"><a href="#0-1" class="headerlink" title="0      1"></a>0      1</h2><ul>
<li>factor 변수로 정의<ul>
<li>gender 변수에 (0,1)입력된 경우 -&gt; gender를 factor 변수로 정의 필요<br>  gender 변수는 factor 변수로 인식하지 못함: (0,1)로 입력되었으므로</li>
</ul>
</li>
</ul>
<h1 id="define-as-a-factor-variable"><a href="#define-as-a-factor-variable" class="headerlink" title="define as a factor variable"></a>define as a factor variable</h1><pre><code>is.factor(gender)</code></pre>
<h2 id="1-FALSE"><a href="#1-FALSE" class="headerlink" title="[1] FALSE"></a>[1] FALSE</h2><ul>
<li>  as.factor(변수이름): 어떤 변수를 factor 변수로 정의할 때, gender 변수는 factor 변수로 정의 -&gt; is.factor(gender)로 확인하면 factor 변수로 정의된 것 확인 가능</li>
</ul>
<pre><code>gender &lt;- as.factor(gender)
is.factor(gender)</code></pre>
<h2 id="1-TRUE"><a href="#1-TRUE" class="headerlink" title="[1] TRUE"></a>[1] TRUE</h2><ul>
<li>범주형 변수 생성_factor 사용<ul>
<li>  size라는 변수 생성: (S, M, L, XL) 값을 갖는 범주형 변수(factor) 생성</li>
</ul>
</li>
</ul>
<pre><code>size &lt;- c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)</code></pre>
<h1 id="define-size-as-a-factor-categorical-variable"><a href="#define-size-as-a-factor-categorical-variable" class="headerlink" title="define size as a factor (categorical variable)"></a>define size as a factor (categorical variable)</h1><pre><code>size_factor &lt;- factor(size)

size_factor</code></pre>
<h2 id="1-S-M-L-XL"><a href="#1-S-M-L-XL" class="headerlink" title="[1] S  M  L  XL"></a>[1] S  M  L  XL</h2><h2 id="Levels-L-M-S-XL"><a href="#Levels-L-M-S-XL" class="headerlink" title="Levels: L M S XL"></a>Levels: L M S XL</h2><ul>
<li>  순서를 정의한 factor 생성</li>
</ul>
<pre><code>size_factor1 &lt;- factor(size, ordered = TRUE, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;))
size_factor</code></pre>
<h2 id="1-S-M-L-XL-1"><a href="#1-S-M-L-XL-1" class="headerlink" title="[1] S  M  L  XL"></a>[1] S  M  L  XL</h2><h2 id="Levels-L-M-S-XL-1"><a href="#Levels-L-M-S-XL-1" class="headerlink" title="Levels: L M S XL"></a>Levels: L M S XL</h2><ul>
<li>  행렬 생성하고 차원 알아보기</li>
</ul>
<pre><code>x &lt;- matrix(rnorm(12), nrow=4)
x</code></pre>
<h2 id="1-2-3-4"><a href="#1-2-3-4" class="headerlink" title="[,1]       [,2]        [,3]"></a>[,1]       [,2]        [,3]</h2><h2 id="1-0-003729970-1-4663220-0-04381181"><a href="#1-0-003729970-1-4663220-0-04381181" class="headerlink" title="[1,] -0.003729970  1.4663220  0.04381181"></a>[1,] -0.003729970  1.4663220  0.04381181</h2><h2 id="2-1-147397993-1-2467755-0-48528371"><a href="#2-1-147397993-1-2467755-0-48528371" class="headerlink" title="[2,]  1.147397993  1.2467755 -0.48528371"></a>[2,]  1.147397993  1.2467755 -0.48528371</h2><h2 id="3-0-002165277-0-4026005-1-08181700"><a href="#3-0-002165277-0-4026005-1-08181700" class="headerlink" title="[3,] -0.002165277 -0.4026005 -1.08181700"></a>[3,] -0.002165277 -0.4026005 -1.08181700</h2><h2 id="4-0-972551871-0-5998451-1-70662398"><a href="#4-0-972551871-0-5998451-1-70662398" class="headerlink" title="[4,] -0.972551871  0.5998451  1.70662398"></a>[4,] -0.972551871  0.5998451  1.70662398</h2><h1 id="차원-확인하기"><a href="#차원-확인하기" class="headerlink" title="차원 확인하기"></a>차원 확인하기</h1><pre><code>dim(x)</code></pre>
<h2 id="1-4-3"><a href="#1-4-3" class="headerlink" title="[1] 4 3"></a>[1] 4 3</h2><ul>
<li>행렬의 속성<ul>
<li>  행렬 x는 (4*3), x가 data frame은 아님</li>
</ul>
</li>
</ul>
<h1 id="generate-matrix-form-normal"><a href="#generate-matrix-form-normal" class="headerlink" title="generate matrix form normal"></a>generate matrix form normal</h1><pre><code>x &lt;- matrix(rnorm(12), nrow=4)
x</code></pre>
<h2 id="1-2-3-5"><a href="#1-2-3-5" class="headerlink" title="[,1]       [,2]       [,3]"></a>[,1]       [,2]       [,3]</h2><h2 id="1-0-71917921-0-1306288-1-3220113"><a href="#1-0-71917921-0-1306288-1-3220113" class="headerlink" title="[1,] -0.71917921  0.1306288  1.3220113"></a>[1,] -0.71917921  0.1306288  1.3220113</h2><h2 id="2-0-67408016-0-3067689-0-5009565"><a href="#2-0-67408016-0-3067689-0-5009565" class="headerlink" title="[2,]  0.67408016 -0.3067689 -0.5009565"></a>[2,]  0.67408016 -0.3067689 -0.5009565</h2><h2 id="3-0-59011810-0-4158816-0-5064173"><a href="#3-0-59011810-0-4158816-0-5064173" class="headerlink" title="[3,]  0.59011810  0.4158816  0.5064173"></a>[3,]  0.59011810  0.4158816  0.5064173</h2><h2 id="4-0-03118919-0-7860212-0-6759638"><a href="#4-0-03118919-0-7860212-0-6759638" class="headerlink" title="[4,]  0.03118919 -0.7860212 -0.6759638"></a>[4,]  0.03118919 -0.7860212 -0.6759638</h2><h1 id="check-dimension-of-x"><a href="#check-dimension-of-x" class="headerlink" title="check dimension of x"></a>check dimension of x</h1><pre><code>dim(x)</code></pre>
<h2 id="1-4-3-1"><a href="#1-4-3-1" class="headerlink" title="[1] 4 3"></a>[1] 4 3</h2><h1 id="data-frame"><a href="#data-frame" class="headerlink" title="data frame"></a>data frame</h1><pre><code>is.data.frame(x)</code></pre>
<h2 id="1-FALSE-1"><a href="#1-FALSE-1" class="headerlink" title="[1] FALSE"></a>[1] FALSE</h2><h1 id="matrix-x-is-not-a-data-frame"><a href="#matrix-x-is-not-a-data-frame" class="headerlink" title="matrix x is not a data frame"></a>matrix x is not a data frame</h1><ul>
<li>  as.data.frame(x)는 x를 데이터로 인식</li>
</ul>
<h1 id="defime-x-as-a-data-frame"><a href="#defime-x-as-a-data-frame" class="headerlink" title="defime x as a data frame"></a>defime x as a data frame</h1><pre><code>x &lt;- as.data.frame(x)</code></pre>
<h1 id="then-x-is-a-data-frame"><a href="#then-x-is-a-data-frame" class="headerlink" title="then x is a data frame"></a>then x is a data frame</h1><pre><code>is.data.frame(x)</code></pre>
<h2 id="1-TRUE-1"><a href="#1-TRUE-1" class="headerlink" title="[1] TRUE"></a>[1] TRUE</h2><h2 id="3-백터와-행렬의-연산"><a href="#3-백터와-행렬의-연산" class="headerlink" title="3. 백터와 행렬의 연산"></a>3. 백터와 행렬의 연산</h2><p>====================</p>
<ul>
<li>  기본 연산 기호</li>
</ul>
<pre><code>2^3</code></pre>
<h2 id="1-8"><a href="#1-8" class="headerlink" title="[1] 8"></a>[1] 8</h2><pre><code>4**3</code></pre>
<h2 id="1-64"><a href="#1-64" class="headerlink" title="[1] 64"></a>[1] 64</h2><pre><code>7%%2</code></pre>
<h2 id="1-1"><a href="#1-1" class="headerlink" title="[1] 1"></a>[1] 1</h2><pre><code>7%/%2</code></pre>
<h2 id="1-3"><a href="#1-3" class="headerlink" title="[1] 3"></a>[1] 3</h2><ul>
<li><p>행렬의 연산<br>  <a target="_blank" rel="noopener" href="http://www.statmethods.net/advstats/matrix.html">- 참고</a></p>
<ul>
<li><p>전치행렬(transpose) 구하기 (t)<br>  전치행렬은 행과 열을 바꾼 행렬</p>
<p>  m2는 (2 * 3)행렬, tm2는 (3 * 2) 행렬</p>
</li>
</ul>
</li>
</ul>
<pre><code>m2 &lt;- matrix(1:6, ncol=3)
m2</code></pre>
<h2 id="1-2-3-6"><a href="#1-2-3-6" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-1-3-5-1"><a href="#1-1-3-5-1" class="headerlink" title="[1,]    1    3    5"></a>[1,]    1    3    5</h2><h2 id="2-2-4-6-1"><a href="#2-2-4-6-1" class="headerlink" title="[2,]    2    4    6"></a>[2,]    2    4    6</h2><h1 id="transpose-of-m2"><a href="#transpose-of-m2" class="headerlink" title="transpose of m2"></a>transpose of m2</h1><pre><code>tm2 &lt;- t(m2)
tm2</code></pre>
<h2 id="1-2"><a href="#1-2" class="headerlink" title="[,1] [,2]"></a>[,1] [,2]</h2><h2 id="1-1-2-1"><a href="#1-1-2-1" class="headerlink" title="[1,]    1    2"></a>[1,]    1    2</h2><h2 id="2-3-4-1"><a href="#2-3-4-1" class="headerlink" title="[2,]    3    4"></a>[2,]    3    4</h2><h2 id="3-5-6-1"><a href="#3-5-6-1" class="headerlink" title="[3,]    5    6"></a>[3,]    5    6</h2><ul>
<li>determinant(행렬식) 구하기 (det)<br>  determinant 식 |A| = $\frac{|a b|}{[c d]}$ = ad = bc</li>
</ul>
<pre><code>d1 &lt;- matrix(1:4, nrow=2, byrow=T) # row부터 채워라
d1</code></pre>
<h2 id="1-2-1"><a href="#1-2-1" class="headerlink" title="[,1] [,2]"></a>[,1] [,2]</h2><h2 id="1-1-2-2"><a href="#1-1-2-2" class="headerlink" title="[1,]    1    2"></a>[1,]    1    2</h2><h2 id="2-3-4-2"><a href="#2-3-4-2" class="headerlink" title="[2,]    3    4"></a>[2,]    3    4</h2><pre><code>det(d1)</code></pre>
<h2 id="1-2-2"><a href="#1-2-2" class="headerlink" title="[1] -2"></a>[1] -2</h2><ul>
<li><p>역행렬(inverse) 구하기 (solve)<br>  d1 = $\frac{[1 2]}{3 4]}$,</p>
<p>  inverse(d1) = <em>f<strong>r</strong>a**c</em>[ − 2.01.0][1.5 − 0.5]</p>
</li>
</ul>
<h1 id="inverse-of-matrix"><a href="#inverse-of-matrix" class="headerlink" title="inverse of matrix"></a>inverse of matrix</h1><pre><code>d1_inv &lt;- solve(d1)
d1_inv</code></pre>
<h2 id="1-2-3"><a href="#1-2-3" class="headerlink" title="[,1] [,2]"></a>[,1] [,2]</h2><h2 id="1-2-0-1-0"><a href="#1-2-0-1-0" class="headerlink" title="[1,] -2.0  1.0"></a>[1,] -2.0  1.0</h2><h2 id="2-1-5-0-5"><a href="#2-1-5-0-5" class="headerlink" title="[2,]  1.5 -0.5"></a>[2,]  1.5 -0.5</h2><h1 id="d1-inv-dq-identity-matrix"><a href="#d1-inv-dq-identity-matrix" class="headerlink" title="d1 * inv(dq) = identity matrix"></a>d1 * inv(dq) = identity matrix</h1><pre><code>d1 %*% d1_inv</code></pre>
<h2 id="1-2-4"><a href="#1-2-4" class="headerlink" title="[,1]         [,2]"></a>[,1]         [,2]</h2><h2 id="1-1-1-110223e-16"><a href="#1-1-1-110223e-16" class="headerlink" title="[1,]    1 1.110223e-16"></a>[1,]    1 1.110223e-16</h2><h2 id="2-0-1-000000e-00"><a href="#2-0-1-000000e-00" class="headerlink" title="[2,]    0 1.000000e+00"></a>[2,]    0 1.000000e+00</h2><p>: d1*d1의 역행렬 = 단위행렬(대각행렬이 1인 행렬)</p>
<ul>
<li><p>역행렬을 이용한 방정식 해 구하기 (solve)<br>  3x + 2y = 8, x + y = 2</p>
<p>  방정식의 해를 구하기 위해 a(행렬)과 b(벡터)를 생성</p>
</li>
</ul>
<h1 id="solve-equation"><a href="#solve-equation" class="headerlink" title="solve equation"></a>solve equation</h1><h1 id="3x-2y-8-x-y-2"><a href="#3x-2y-8-x-y-2" class="headerlink" title="3x + 2y = 8, x + y =2"></a>3x + 2y = 8, x + y =2</h1><h1 id="matrix-a-b"><a href="#matrix-a-b" class="headerlink" title="matrix a, b"></a>matrix a, b</h1><pre><code>a &lt;- matrix(c(3,1,2,1), nrow=2, ncol=2)
b &lt;- matrix(c(8,2), nrow=2, ncol=1)
a</code></pre>
<h2 id="1-2-5"><a href="#1-2-5" class="headerlink" title="[,1] [,2]"></a>[,1] [,2]</h2><h2 id="1-3-2"><a href="#1-3-2" class="headerlink" title="[1,]    3    2"></a>[1,]    3    2</h2><h2 id="2-1-1"><a href="#2-1-1" class="headerlink" title="[2,]    1    1"></a>[2,]    1    1</h2><pre><code>b</code></pre>
<h2 id="1-1"><a href="#1-1" class="headerlink" title="[,1]"></a>[,1]</h2><h2 id="1-8-1"><a href="#1-8-1" class="headerlink" title="[1,]    8"></a>[1,]    8</h2><h2 id="2-2"><a href="#2-2" class="headerlink" title="[2,]    2"></a>[2,]    2</h2><p>: solve 함수를 이용해 x와 y의 해를 찾음</p>
<pre><code>solve(a,b)</code></pre>
<h2 id="1-2"><a href="#1-2" class="headerlink" title="[,1]"></a>[,1]</h2><h2 id="1-4"><a href="#1-4" class="headerlink" title="[1,]    4"></a>[1,]    4</h2><h2 id="2-2-1"><a href="#2-2-1" class="headerlink" title="[2,]   -2"></a>[2,]   -2</h2><ul>
<li>  고유치(eigenvalue)와 고유벡터(eigenvector)</li>
</ul>
<h1 id="example-for-eigen-value-and-eigen-vector"><a href="#example-for-eigen-value-and-eigen-vector" class="headerlink" title="example for eigen value and eigen vector"></a>example for eigen value and eigen vector</h1><h1 id="already-centered-matrix"><a href="#already-centered-matrix" class="headerlink" title="already centered matrix"></a>already centered matrix</h1><pre><code>x &lt;- matrix(c(-3, -2, 0, 1, 2, 2, -3, -3, 0, 2, 2, 2, 5, 7, 4, 0, -5, -11), nrow=6, ncol=3)
x</code></pre>
<h2 id="1-2-3-7"><a href="#1-2-3-7" class="headerlink" title="[,1] [,2] [,3]"></a>[,1] [,2] [,3]</h2><h2 id="1-3-3-5"><a href="#1-3-3-5" class="headerlink" title="[1,]   -3   -3    5"></a>[1,]   -3   -3    5</h2><h2 id="2-2-3-7"><a href="#2-2-3-7" class="headerlink" title="[2,]   -2   -3    7"></a>[2,]   -2   -3    7</h2><h2 id="3-0-0-4"><a href="#3-0-0-4" class="headerlink" title="[3,]    0    0    4"></a>[3,]    0    0    4</h2><h2 id="4-1-2-0"><a href="#4-1-2-0" class="headerlink" title="[4,]    1    2    0"></a>[4,]    1    2    0</h2><h2 id="5-2-2-5"><a href="#5-2-2-5" class="headerlink" title="[5,]    2    2   -5"></a>[5,]    2    2   -5</h2><h2 id="6-2-2-11"><a href="#6-2-2-11" class="headerlink" title="[6,]    2    2  -11"></a>[6,]    2    2  -11</h2><pre><code>dim(x)</code></pre>
<h2 id="1-6-3"><a href="#1-6-3" class="headerlink" title="[1] 6 3"></a>[1] 6 3</h2><h1 id="eigen-value-and-eigen-vector"><a href="#eigen-value-and-eigen-vector" class="headerlink" title="eigen value and eigen vector"></a>eigen value and eigen vector</h1><pre><code>e1 &lt;- eigen(t(x)%*%x)
e1</code></pre>
<h2 id="eigen-decomposition"><a href="#eigen-decomposition" class="headerlink" title="eigen() decomposition"></a>eigen() decomposition</h2><h2 id="values"><a href="#values" class="headerlink" title="$values"></a>$values</h2><h2 id="1-273-546962-13-845220-0-607818"><a href="#1-273-546962-13-845220-0-607818" class="headerlink" title="[1] 273.546962  13.845220   0.607818"></a>[1] 273.546962  13.845220   0.607818</h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="vectors"><a href="#vectors" class="headerlink" title="$vectors"></a>$vectors</h2><h2 id="1-2-3-8"><a href="#1-2-3-8" class="headerlink" title="[,1]      [,2]        [,3]"></a>[,1]      [,2]        [,3]</h2><h2 id="1-0-2525343-0-5487321-0-79694382"><a href="#1-0-2525343-0-5487321-0-79694382" class="headerlink" title="[1,] -0.2525343 0.5487321  0.79694382"></a>[1,] -0.2525343 0.5487321  0.79694382</h2><h2 id="2-0-2841664-0-7452586-0-60319073"><a href="#2-0-2841664-0-7452586-0-60319073" class="headerlink" title="[2,] -0.2841664 0.7452586 -0.60319073"></a>[2,] -0.2841664 0.7452586 -0.60319073</h2><h2 id="3-0-9249194-0-3787911-0-03227211"><a href="#3-0-9249194-0-3787911-0-03227211" class="headerlink" title="[3,]  0.9249194 0.3787911  0.03227211"></a>[3,]  0.9249194 0.3787911  0.03227211</h2><h2 id="4-간단한-함수생성-및-루프-for-while"><a href="#4-간단한-함수생성-및-루프-for-while" class="headerlink" title="4. 간단한 함수생성 및 루프(for, while)"></a>4. 간단한 함수생성 및 루프(for, while)</h2><p>================</p>
<h3 id="함수-생성"><a href="#함수-생성" class="headerlink" title="함수 생성"></a>함수 생성</h3><ul>
<li>  squre 함수 생성</li>
</ul>
<h1 id="create-a-simple-function"><a href="#create-a-simple-function" class="headerlink" title="create a simple function"></a>create a simple function</h1><h1 id="squre-function"><a href="#squre-function" class="headerlink" title="squre function"></a>squre function</h1><pre><code>squre &lt;- function(x)&#123;
  return(x*x) # 제곱값 제공
&#125;

squre(9)</code></pre>
<h2 id="1-81"><a href="#1-81" class="headerlink" title="[1] 81"></a>[1] 81</h2><pre><code>squre(1:3) #1부터 3까지 각 squre 값 제공하라</code></pre>
<h2 id="1-1-4-9"><a href="#1-1-4-9" class="headerlink" title="[1] 1 4 9"></a>[1] 1 4 9</h2><ul>
<li>  dif 함수 생성</li>
</ul>
<pre><code>dif &lt;- function(x,y)&#123;
  return(x-y)
&#125;

dif(20,10)</code></pre>
<h2 id="1-10"><a href="#1-10" class="headerlink" title="[1] 10"></a>[1] 10</h2><ul>
<li>  rootdif 함수 생성</li>
</ul>
<pre><code>rootdif &lt;- function(x,y)&#123;
  return(sqrt(x-y))
&#125;

rootdif(20,10)</code></pre>
<h2 id="1-3-162278"><a href="#1-3-162278" class="headerlink" title="[1] 3.162278"></a>[1] 3.162278</h2><ul>
<li>  기존 함수의 코드 보기_round 함수</li>
</ul>
<h1 id="round-함수-소수점-자리-조정하는-함수"><a href="#round-함수-소수점-자리-조정하는-함수" class="headerlink" title="round 함수: 소수점 자리 조정하는 함수"></a>round 함수: 소수점 자리 조정하는 함수</h1><pre><code>round(5.14846)</code></pre>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="[1] 5"></a>[1] 5</h2><pre><code>round(5.14846, 2)</code></pre>
<h2 id="1-5-15"><a href="#1-5-15" class="headerlink" title="[1] 5.15"></a>[1] 5.15</h2><h1 id="to-see-the-function-“round”"><a href="#to-see-the-function-“round”" class="headerlink" title="to see the function “round”"></a>to see the function “round”</h1><pre><code>round</code></pre>
<h2 id="function-x-digits-0-Primitive-“round”"><a href="#function-x-digits-0-Primitive-“round”" class="headerlink" title="function (x, digits = 0)  .Primitive(“round”)"></a>function (x, digits = 0)  .Primitive(“round”)</h2><h1 id="plus"><a href="#plus" class="headerlink" title="plus"></a>plus</h1><pre><code>round(rootdif(20,10))</code></pre>
<h2 id="1-3-1"><a href="#1-3-1" class="headerlink" title="[1] 3"></a>[1] 3</h2><pre><code>round(rootdif(20,10),2)</code></pre>
<h2 id="1-3-16"><a href="#1-3-16" class="headerlink" title="[1] 3.16"></a>[1] 3.16</h2><h3 id="루프문"><a href="#루프문" class="headerlink" title="루프문"></a>루프문</h3><ul>
<li>루프문 (for)<ul>
<li>  for을 사용한 루프 1</li>
</ul>
</li>
</ul>
<h1 id="for-1-to-10"><a href="#for-1-to-10" class="headerlink" title="for 1 to 10"></a>for 1 to 10</h1><h1 id="if-remainder-1-when-deviding-by-3"><a href="#if-remainder-1-when-deviding-by-3" class="headerlink" title="if remainder = 1 when deviding by 3"></a>if remainder = 1 when deviding by 3</h1><h1 id="then-go-to-next-number"><a href="#then-go-to-next-number" class="headerlink" title="then go to next number"></a>then go to next number</h1><h1 id="-4"><a href="#-4" class="headerlink" title="$$"></a>$$</h1><pre><code>for(i in 1:10)&#123;
  if(i%%3 == 1)&#123;
    next()
  &#125;
  print(i)
&#125;</code></pre>
<h2 id="1-2-6"><a href="#1-2-6" class="headerlink" title="[1] 2"></a>[1] 2</h2><h2 id="1-3-2"><a href="#1-3-2" class="headerlink" title="[1] 3"></a>[1] 3</h2><h2 id="1-5-1"><a href="#1-5-1" class="headerlink" title="[1] 5"></a>[1] 5</h2><h2 id="1-6"><a href="#1-6" class="headerlink" title="[1] 6"></a>[1] 6</h2><h2 id="1-8-2"><a href="#1-8-2" class="headerlink" title="[1] 8"></a>[1] 8</h2><h2 id="1-9"><a href="#1-9" class="headerlink" title="[1] 9"></a>[1] 9</h2><h1 id="1부터-10까지의-숫자-반복"><a href="#1부터-10까지의-숫자-반복" class="headerlink" title="1부터 10까지의 숫자 반복"></a>1부터 10까지의 숫자 반복</h1><h1 id="3으로-나누었을-때-내머지가-1인-경우-next-다음-숫자로-넘어감"><a href="#3으로-나누었을-때-내머지가-1인-경우-next-다음-숫자로-넘어감" class="headerlink" title="3으로 나누었을 때 내머지가 1인 경우 next(다음 숫자로 넘어감)"></a>3으로 나누었을 때 내머지가 1인 경우 next(다음 숫자로 넘어감)</h1><h1 id="넘어가지-않은-경우-print-i-를-통해-결과-반환"><a href="#넘어가지-않은-경우-print-i-를-통해-결과-반환" class="headerlink" title="넘어가지 않은 경우 print(i)를 통해 결과 반환"></a>넘어가지 않은 경우 print(i)를 통해 결과 반환</h1><ul>
<li>  for을 사용한 루프 2</li>
</ul>
<h1 id="i-1-10-1-2-3-…-더해가며-프린트하는데-i-gt-5-보다-크면-수행-print-i-을-멈춤"><a href="#i-1-10-1-2-3-…-더해가며-프린트하는데-i-gt-5-보다-크면-수행-print-i-을-멈춤" class="headerlink" title="i = 1 ~ 10 1, 2, 3 … 더해가며 프린트하는데, i &gt; 5 보다 크면 수행(print(i))을 멈춤"></a>i = 1 ~ 10 1, 2, 3 … 더해가며 프린트하는데, i &gt; 5 보다 크면 수행(print(i))을 멈춤</h1><h1 id="for-loop-example-2"><a href="#for-loop-example-2" class="headerlink" title="for loop example 2"></a>for loop example 2</h1><h1 id="stop-loop-after-i-gt-5"><a href="#stop-loop-after-i-gt-5" class="headerlink" title="stop loop after i &gt; 5"></a>stop loop after i &gt; 5</h1><h1 id="-5"><a href="#-5" class="headerlink" title="%%"></a>%%</h1><pre><code>for (i in 1:10)&#123;
  i &lt;- i + 1
  print(i)
  if (i &gt; 5)&#123;
  # stop loop after i &gt; 5
    break
  &#125;
&#125;</code></pre>
<h2 id="1-2-7"><a href="#1-2-7" class="headerlink" title="[1] 2"></a>[1] 2</h2><h2 id="1-3-3"><a href="#1-3-3" class="headerlink" title="[1] 3"></a>[1] 3</h2><h2 id="1-4-1"><a href="#1-4-1" class="headerlink" title="[1] 4"></a>[1] 4</h2><h2 id="1-5-2"><a href="#1-5-2" class="headerlink" title="[1] 5"></a>[1] 5</h2><h2 id="1-6-1"><a href="#1-6-1" class="headerlink" title="[1] 6"></a>[1] 6</h2><ul>
<li>  while을 사용한 루프</li>
</ul>
<h1 id="y가-5보다-적을-때는-expression-부분-수행"><a href="#y가-5보다-적을-때는-expression-부분-수행" class="headerlink" title="y가 5보다 적을 때는 {expression} 부분 수행"></a>y가 5보다 적을 때는 {expression} 부분 수행</h1><h1 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop"></a>while loop</h1><h1 id="while-condition-expression"><a href="#while-condition-expression" class="headerlink" title="while (condition) {expression}"></a>while (condition) {expression}</h1><pre><code>y = 0
while(y &lt; 5)&#123;print(y &lt;- y+1)&#125;</code></pre>
<h2 id="1-1-1"><a href="#1-1-1" class="headerlink" title="[1] 1"></a>[1] 1</h2><h2 id="1-2-8"><a href="#1-2-8" class="headerlink" title="[1] 2"></a>[1] 2</h2><h2 id="1-3-4"><a href="#1-3-4" class="headerlink" title="[1] 3"></a>[1] 3</h2><h2 id="1-4-2"><a href="#1-4-2" class="headerlink" title="[1] 4"></a>[1] 4</h2><h2 id="1-5-3"><a href="#1-5-3" class="headerlink" title="[1] 5"></a>[1] 5</h2>-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/11/%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D%EA%B3%BC_R%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%E2%85%A1_%EB%B2%A1%ED%84%B0,%ED%96%89%EB%A0%AC%EC%9D%98_%EC%97%B0%EC%82%B0_%EB%B0%8F_%ED%95%A8%EC%88%98/" data-id="ckjqkgb9e0006wkue3u4v37lu" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postech-MOOC/" rel="tag">Postech_MOOC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/R-programming/" rel="tag">R programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vector-Array/" rel="tag">Vector&Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/for-loop/" rel="tag">for loop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/while-loop/" rel="tag">while loop</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Pandas_10분_완성" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/10/Pandas_10%EB%B6%84_%EC%99%84%EC%84%B1/">Pandas 10분 완성(10 Minutes to Pandas)</a>
    </h1>
  

        <a href="/2020/11/10/Pandas_10%EB%B6%84_%EC%99%84%EC%84%B1/" class="article-date">
  <time datetime="2020-11-10T00:00:00.000Z" itemprop="datePublished">2020-11-10</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="Pandas-10분-완성-10-Minutes-to-Pandas-필사"><a href="#Pandas-10분-완성-10-Minutes-to-Pandas-필사" class="headerlink" title="Pandas 10분 완성(10 Minutes to Pandas) 필사"></a><strong>Pandas 10분 완성(10 Minutes to Pandas) 필사</strong></h1><ul>
<li>본 자료의 저작권은 <a target="_blank" rel="noopener" href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a>이며, <a target="_blank" rel="noopener" href="https://dataitgirls2.github.io/10minutes2pandas/">데잇걸즈2가 번역한 Pandas 10분 완성</a>을 필사한 자료임.  </li>
</ul>
<p><strong>목차</strong></p>
<ol>
<li>Object Creation (객체 생성)  </li>
<li>Viewing Data (데이터 확인하기)  </li>
<li>Selection (선택)  </li>
<li>Missing Data (결측치)  </li>
<li>Operation (연산)  </li>
<li>Merge (병합)</li>
<li>Grouping (그룹화)</li>
<li>Reshaping (변형)</li>
<li>Time Series (시계열)</li>
<li>Categoricals (범주화)</li>
<li>Plotting (그래프)</li>
<li>Getting Data In / Out (데이터 입 / 출력)</li>
<li>Gotchas (잡았다!)</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 패키지 불러오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h2 id="1-Object-Creation"><a href="#1-Object-Creation" class="headerlink" title="1. Object Creation"></a><strong>1. Object Creation</strong></h2><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html">- 참고: 데이터 구조 소개 섹션</a></p>
<p>Pansdas는 값을 가지고 있는 리스트를 통해 <a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html">Series</a>를 만들고, 정수로 만들어진 인덱스를 기본값으로 불러온다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64</code></pre>
<p>datetime 인덱스와 레이블이 있는 열을 가진 numpy 배열을 전달하여 데이터프레임을 만든다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">&#x27;20130101&#x27;</span>, periods = <span class="number">6</span>)</span><br><span class="line">dates</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;,
               &#39;2013-01-05&#39;, &#39;2013-01-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>, <span class="number">4</span>), index = dates, columns = <span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
      <td>1.369361</td>
      <td>0.354048</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>0.574172</td>
    </tr>
  </tbody>
</table>
</div>



<p>Series와 같은 것으로 변환될 수 있는 객체들의 dict로 구성된 데이터프레임을 만든다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">&#x27;B&#x27;</span>: pd.Timestamp(<span class="string">&#x27;20130102&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;C&#x27;</span>: pd.Series(<span class="number">1</span>, index = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)), dtype = <span class="string">&#x27;float32&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;D&#x27;</span>: np.array([<span class="number">3</span>] * <span class="number">4</span>, dtype = <span class="string">&#x27;int32&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;E&#x27;</span>: pd.Categorical([<span class="string">&quot;test&quot;</span>, <span class="string">&quot;train&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;train&quot;</span>]),</span><br><span class="line">                    <span class="string">&#x27;F&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>2013-01-02</td>
      <td>1.0</td>
      <td>3</td>
      <td>test</td>
      <td>foo</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1.0</td>
      <td>2013-01-02</td>
      <td>1.0</td>
      <td>3</td>
      <td>train</td>
      <td>foo</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>2013-01-02</td>
      <td>1.0</td>
      <td>3</td>
      <td>test</td>
      <td>foo</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.0</td>
      <td>2013-01-02</td>
      <td>1.0</td>
      <td>3</td>
      <td>train</td>
      <td>foo</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.dtypes</span><br></pre></td></tr></table></figure>




<pre><code>A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object</code></pre>
<h2 id="2-Viewing-Data"><a href="#2-Viewing-Data" class="headerlink" title="2. Viewing Data"></a><strong>2. Viewing Data</strong></h2><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html">- 참고: Basic Section</a>  </p>
<p>데이터프레임의 가장 윗줄과 마지막 줄을 확인하고 싶을 때 사용하는 방법 알아보기.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 괄호() 안에 숫자를 넣으면 (숫자)줄을 불러오고 넣지 않으면 기본값인 5개를 불러옴</span></span><br><span class="line"></span><br><span class="line">df.tail(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>0.574172</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
      <td>1.369361</td>
      <td>0.354048</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
    </tr>
  </tbody>
</table>
</div>



<p>index, column, numpy 데이터 세부 정보를 알아보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.index</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;,
               &#39;2013-01-05&#39;, &#39;2013-01-06&#39;],
              dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br></pre></td></tr></table></figure>




<pre><code>Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], dtype=&#39;object&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.values</span><br></pre></td></tr></table></figure>




<pre><code>array([[-1.61264215, -0.2023848 ,  1.36936106,  0.35404822],
       [-0.41459705,  0.74983681,  0.09588737, -0.74053093],
       [ 0.60731344,  0.78256437,  0.14000027,  0.89485905],
       [-0.74814932,  0.41736876,  0.82389876,  1.04370685],
       [-0.42049172, -0.17500487, -0.02187012, -1.98074049],
       [ 1.49444451, -0.58202719,  1.0530883 ,  0.57417186]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe() <span class="comment"># 데이터의 대략적인 통계적 정보 요약을 보여줌</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>6.000000</td>
      <td>6.000000</td>
      <td>6.000000</td>
      <td>6.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>-0.182354</td>
      <td>0.165059</td>
      <td>0.576728</td>
      <td>0.024252</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.087357</td>
      <td>0.564931</td>
      <td>0.582501</td>
      <td>1.167331</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-1.612642</td>
      <td>-0.582027</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>-0.666235</td>
      <td>-0.195540</td>
      <td>0.106916</td>
      <td>-0.466886</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>-0.417544</td>
      <td>0.121182</td>
      <td>0.481950</td>
      <td>0.464110</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.351836</td>
      <td>0.666720</td>
      <td>0.995791</td>
      <td>0.814687</td>
    </tr>
    <tr>
      <th>max</th>
      <td>1.494445</td>
      <td>0.782564</td>
      <td>1.369361</td>
      <td>1.043707</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.T <span class="comment"># 데이터 전치</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>2013-01-01</th>
      <th>2013-01-02</th>
      <th>2013-01-03</th>
      <th>2013-01-04</th>
      <th>2013-01-05</th>
      <th>2013-01-06</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>-1.612642</td>
      <td>-0.414597</td>
      <td>0.607313</td>
      <td>-0.748149</td>
      <td>-0.420492</td>
      <td>1.494445</td>
    </tr>
    <tr>
      <th>B</th>
      <td>-0.202385</td>
      <td>0.749837</td>
      <td>0.782564</td>
      <td>0.417369</td>
      <td>-0.175005</td>
      <td>-0.582027</td>
    </tr>
    <tr>
      <th>C</th>
      <td>1.369361</td>
      <td>0.095887</td>
      <td>0.140000</td>
      <td>0.823899</td>
      <td>-0.021870</td>
      <td>1.053088</td>
    </tr>
    <tr>
      <th>D</th>
      <td>0.354048</td>
      <td>-0.740531</td>
      <td>0.894859</td>
      <td>1.043707</td>
      <td>-1.980740</td>
      <td>0.574172</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_index(axis = <span class="number">1</span>, ascending = <span class="literal">False</span>) <span class="comment"># 축별로 정리</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>D</th>
      <th>C</th>
      <th>B</th>
      <th>A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.354048</td>
      <td>1.369361</td>
      <td>-0.202385</td>
      <td>-1.612642</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.740531</td>
      <td>0.095887</td>
      <td>0.749837</td>
      <td>-0.414597</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.894859</td>
      <td>0.140000</td>
      <td>0.782564</td>
      <td>0.607313</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>1.043707</td>
      <td>0.823899</td>
      <td>0.417369</td>
      <td>-0.748149</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-1.980740</td>
      <td>-0.021870</td>
      <td>-0.175005</td>
      <td>-0.420492</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>0.574172</td>
      <td>1.053088</td>
      <td>-0.582027</td>
      <td>1.494445</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by = <span class="string">&#x27;B&#x27;</span>) <span class="comment"># 값별로 정렬</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>0.574172</td>
    </tr>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
      <td>1.369361</td>
      <td>0.354048</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="3-Selection"><a href="#3-Selection" class="headerlink" title="3. Selection"></a><strong>3. Selection</strong></h2><ul>
<li>주석: Pandas에 최적화된 데이터 접근 방법인 .at, .iat, .loc, .iloc 사용  </li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">- 참고: 데이터 인덱싱 및 선택</a>, <a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html">다중 인덱싱/심화 인덱싱</a></p>
<h3 id="Getting-데이터-얻기"><a href="#Getting-데이터-얻기" class="headerlink" title="- Getting(데이터 얻기)"></a><strong>- Getting(데이터 얻기)</strong></h3><p>df.A와 동일한 Series를 생성하는 단일 열을 선택한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2013-01-01   -1.612642
2013-01-02   -0.414597
2013-01-03    0.607313
2013-01-04   -0.748149
2013-01-05   -0.420492
2013-01-06    1.494445
Freq: D, Name: A, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
      <td>1.369361</td>
      <td>0.354048</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;20130102&#x27;</span>:<span class="string">&#x27;20130104&#x27;</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Selection-by-Label"><a href="#Selection-by-Label" class="headerlink" title="- Selection by Label"></a><strong>- Selection by Label</strong></h3><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">- 참고: Label을 통한 선택</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 라벨을 사용하여 횡단면 얻기</span></span><br><span class="line">df.loc[dates[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>




<pre><code>A   -1.612642
B   -0.202385
C    1.369361
D    0.354048
Name: 2013-01-01 00:00:00, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 라벨을 사용하여 여러 축(의 데이터) 얻기</span></span><br><span class="line">df.loc[:, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 양쪽 종단점을 포함한 라벨 슬라이싱 보기</span></span><br><span class="line">df.loc[<span class="string">&#x27;20130102&#x27;</span>:<span class="string">&#x27;20130104&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 반환되는 객체의 차원 줄이기</span></span><br><span class="line">df.loc[<span class="string">&#x27;20130102&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]]</span><br></pre></td></tr></table></figure>




<pre><code>A   -0.414597
B    0.749837
Name: 2013-01-02 00:00:00, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 스킬라 값 얻기</span></span><br><span class="line">df.loc[dates[<span class="number">0</span>], <span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>-1.6126421545697252</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cf. 스킬라 값 더 빠르게 구하는 법</span></span><br><span class="line">df.at[dates[<span class="number">0</span>], <span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>-1.6126421545697252</code></pre>
<h3 id="Selection-by-Position"><a href="#Selection-by-Position" class="headerlink" title="- Selection by Position"></a><strong>- Selection by Position</strong></h3><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html">- 참고: 위치로 선택하기</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 넘겨 받은 정수 위치를 기준으로 선택</span></span><br><span class="line">df.iloc[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>A   -0.748149
B    0.417369
C    0.823899
D    1.043707
Name: 2013-01-04 00:00:00, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 정수로 표기된 슬라이스를 통해, numpy / python과 유사하게 작동</span></span><br><span class="line">df.iloc[<span class="number">3</span>:<span class="number">5</span>, <span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 정수로 표기된 위치값 리스트를 통해, numpy / python 스타일과 유사해짐</span></span><br><span class="line">df.iloc[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">0</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.095887</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.140000</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.021870</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 명시적으로 행을 나누고자 하는 경우</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>, :]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 명시적으로 열을 나누고자 하는 경우</span></span><br><span class="line">df.iloc[:, <span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-0.202385</td>
      <td>1.369361</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>0.749837</td>
      <td>0.095887</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.782564</td>
      <td>0.140000</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>0.417369</td>
      <td>0.823899</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.175005</td>
      <td>-0.021870</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>-0.582027</td>
      <td>1.053088</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 명시적으로 (특정한) 값을 얻고자 하는 경우</span></span><br><span class="line">df.iloc[<span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0.7498368136559216</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 스칼라 값을 빠르게 얻는 방법</span></span><br><span class="line">df.iat[<span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0.7498368136559216</code></pre>
<h3 id="Boolean-Indexing"><a href="#Boolean-Indexing" class="headerlink" title="- Boolean Indexing"></a><strong>- Boolean Indexing</strong></h3><p>데이터를 선택하기 위해 단일 열 값을 사용한다.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[df.A &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>0.574172</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Boolean 조건을 충족하는 데이터프레임에서 값 선택</span></span><br><span class="line">df[df &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>1.369361</td>
      <td>0.354048</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>NaN</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>NaN</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>NaN</td>
      <td>1.053088</td>
      <td>0.574172</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 필터링을 위한 메소드 isin()을 사용</span></span><br><span class="line">df2 = df.copy()</span><br><span class="line">df2[<span class="string">&#x27;E&#x27;</span>] = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>-1.612642</td>
      <td>-0.202385</td>
      <td>1.369361</td>
      <td>0.354048</td>
      <td>one</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>-0.740531</td>
      <td>one</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>0.894859</td>
      <td>two</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>1.043707</td>
      <td>three</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-1.980740</td>
      <td>four</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>0.574172</td>
      <td>three</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2[df2[<span class="string">&#x27;E&#x27;</span>].isin([<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])]</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.14000</td>
      <td>0.894859</td>
      <td>two</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.02187</td>
      <td>-1.980740</td>
      <td>four</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Setting"><a href="#Setting" class="headerlink" title="- Setting"></a><strong>- Setting</strong></h3><p>새 열을 설정하면 데이터가 인덱스별로 자동정렬 된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], index = pd.date_range(<span class="string">&#x27;20130102&#x27;</span>, periods=<span class="number">6</span>))</span><br><span class="line">s1</span><br></pre></td></tr></table></figure>




<pre><code>2013-01-02    1
2013-01-03    2
2013-01-04    3
2013-01-05    4
2013-01-06    5
2013-01-07    6
Freq: D, dtype: int64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;F&#x27;</span>] = s1</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 라벨에 의해 값 설정</span></span><br><span class="line">df.at[dates[<span class="number">0</span>], <span class="string">&#x27;A&#x27;</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 위치에 의해 값 설정</span></span><br><span class="line">df.iat[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numpy 배열을 사용한 할당에 의해 값 설정</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;D&#x27;</span>] = np.array([<span class="number">5</span>] * <span class="built_in">len</span>(df))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 위 설정대로 작동한 결과</span></span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.369361</td>
      <td>5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>5</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>5</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>5</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>5</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>1.494445</td>
      <td>-0.582027</td>
      <td>1.053088</td>
      <td>5</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># where 연산 설정</span></span><br><span class="line">df2 = df.copy()</span><br><span class="line">df2[df2 &gt; <span class="number">0</span>] = -df2</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>-1.369361</td>
      <td>-5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>-0.749837</td>
      <td>-0.095887</td>
      <td>-5</td>
      <td>-1.0</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>-0.607313</td>
      <td>-0.782564</td>
      <td>-0.140000</td>
      <td>-5</td>
      <td>-2.0</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>-0.417369</td>
      <td>-0.823899</td>
      <td>-5</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.420492</td>
      <td>-0.175005</td>
      <td>-0.021870</td>
      <td>-5</td>
      <td>-4.0</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>-1.494445</td>
      <td>-0.582027</td>
      <td>-1.053088</td>
      <td>-5</td>
      <td>-5.0</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="4-Missing-Data"><a href="#4-Missing-Data" class="headerlink" title="4. Missing Data"></a><strong>4. Missing Data</strong></h2><p>Pandas는 결측치를 표현하기 위해, 주로 np.nan 값을 사용한다. (기본 설정값이나 계산에는 포함되지 않음)<br><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html">- 참고: Missing data section</a>  </p>
<p>Reindexing으로 지정된 축 상의 인덱스를 변경/추가/삭제할 수 있다. Reindexing은 데이터의 복사본을 반환한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = df.reindex(index = dates[<span class="number">0</span>:<span class="number">4</span>], columns = <span class="built_in">list</span>(df.columns) + [<span class="string">&#x27;E&#x27;</span>])</span><br><span class="line">df1.loc[dates[<span class="number">0</span>]:dates[<span class="number">1</span>], <span class="string">&#x27;E&#x27;</span>] = <span class="number">1</span></span><br><span class="line">df1</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.369361</td>
      <td>5</td>
      <td>NaN</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>5</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>5</td>
      <td>2.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>5</td>
      <td>3.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 결측치를 가지고 있는 행 지우기</span></span><br><span class="line">df1.dropna(how = <span class="string">&#x27;any&#x27;</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>5</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 결측치 채워 넣기</span></span><br><span class="line">df1.fillna(value = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.369361</td>
      <td>5</td>
      <td>5.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>0.095887</td>
      <td>5</td>
      <td>1.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.607313</td>
      <td>0.782564</td>
      <td>0.140000</td>
      <td>5</td>
      <td>2.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.748149</td>
      <td>0.417369</td>
      <td>0.823899</td>
      <td>5</td>
      <td>3.0</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NAN 값에 boolean을 통한 표식</span></span><br><span class="line">pd.isna(df1) <span class="comment"># 데이터프레임의 모든 값이 boolean 형태로 표시되게 하며, nan인 값만 True가 표시되게 하는 함수</span></span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>False</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="5-Operation-연산"><a href="#5-Operation-연산" class="headerlink" title="5. Operation (연산)"></a><strong>5. Operation (연산)</strong></h2><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html">- 참고: 이진(Binary) 연산의 기본 섹션</a>  </p>
<h3 id="Stats"><a href="#Stats" class="headerlink" title="- Stats"></a><strong>- Stats</strong></h3><p>통계: 일반적으로 결측치를 제외한 후 연산된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 기술통계 수행</span></span><br><span class="line">df.mean()</span><br></pre></td></tr></table></figure>




<pre><code>A    0.086420
B    0.198790
C    0.576728
D    5.000000
F    3.000000
dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 다른 축에서 동일한 연산 수행</span></span><br><span class="line">df.mean(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>2013-01-01    1.592340
2013-01-02    1.286225
2013-01-03    1.705976
2013-01-04    1.698624
2013-01-05    1.676527
2013-01-06    2.393101
Freq: D, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 정렬이 필요하며, 차원이 다른 객체로 연산 (pandas는 지정된 차원을 따라 자동으로 브로드캐스팅됨)</span></span><br><span class="line"><span class="comment"># broadcast: nympy에서 유래, n차원이나 스칼라 값으로 연산 수행 시 도출되는 결과의 규칙을 설명하는 것  </span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">6</span>, <span class="number">8</span>], index = dates).shift(<span class="number">2</span>)</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>2013-01-01    NaN
2013-01-02    NaN
2013-01-03    1.0
2013-01-04    3.0
2013-01-05    5.0
2013-01-06    NaN
Freq: D, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sub(s, axis = <span class="string">&#x27;index&#x27;</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>-0.392687</td>
      <td>-0.217436</td>
      <td>-0.860000</td>
      <td>4.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-3.748149</td>
      <td>-2.582631</td>
      <td>-2.176101</td>
      <td>2.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-5.420492</td>
      <td>-5.175005</td>
      <td>-5.021870</td>
      <td>0.0</td>
      <td>-1.0</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Apply"><a href="#Apply" class="headerlink" title="- Apply"></a><strong>- Apply</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터에 함수 적용</span></span><br><span class="line">df.apply(np.cumsum)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>F</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013-01-01</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>1.369361</td>
      <td>5</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2013-01-02</th>
      <td>-0.414597</td>
      <td>0.749837</td>
      <td>1.465248</td>
      <td>10</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2013-01-03</th>
      <td>0.192716</td>
      <td>1.532401</td>
      <td>1.605249</td>
      <td>15</td>
      <td>3.0</td>
    </tr>
    <tr>
      <th>2013-01-04</th>
      <td>-0.555433</td>
      <td>1.949770</td>
      <td>2.429147</td>
      <td>20</td>
      <td>6.0</td>
    </tr>
    <tr>
      <th>2013-01-05</th>
      <td>-0.975925</td>
      <td>1.774765</td>
      <td>2.407277</td>
      <td>25</td>
      <td>10.0</td>
    </tr>
    <tr>
      <th>2013-01-06</th>
      <td>0.518520</td>
      <td>1.192738</td>
      <td>3.460366</td>
      <td>30</td>
      <td>15.0</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.apply(<span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure>




<pre><code>A    2.242594
B    1.364592
C    1.391231
D    0.000000
F    4.000000
dtype: float64</code></pre>
<h3 id="Histogramming"><a href="#Histogramming" class="headerlink" title="- Histogramming"></a><strong>- Histogramming</strong></h3><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html">- 참고: Histogramming and Discretization(히스토그래밍과 이산화)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series(np.random.randint(<span class="number">0</span>, <span class="number">7</span>, size = <span class="number">10</span>))</span><br><span class="line">s</span><br></pre></td></tr></table></figure>




<pre><code>0    6
1    6
2    4
3    3
4    6
5    3
6    0
7    1
8    0
9    4
dtype: int64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.value_counts</span><br></pre></td></tr></table></figure>




<pre><code>&lt;bound method IndexOpsMixin.value_counts of 0    6
1    6
2    4
3    3
4    6
5    3
6    0
7    1
8    0
9    4
dtype: int64&gt;</code></pre>
<h3 id="String-Methods"><a href="#String-Methods" class="headerlink" title="- String Methods"></a><strong>- String Methods</strong></h3><p>Series는 문자열 처리 메소드 모음(set)을 가지고 있다.<br>이 모음은 배열의 각 요소를 쉽게 조작하도록 만드는 문자열의 속성에 포함되어 있다.<br>문자열의 패턴 일치 확인은 기본적으로 정규 표현식을 사용하며, 몇몇 경우에는 항상 정규 표현식을 사용한다.  </p>
<p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html">- 참고: 벡터화된 문자열 메소드</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Aaba&#x27;</span>, <span class="string">&#x27;Baca&#x27;</span>, np.nan, <span class="string">&#x27;CABA&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>])</span><br><span class="line">s.<span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure>




<pre><code>0       a
1       b
2       c
3    aaba
4    baca
5     NaN
6    caba
7     dog
8     cat
dtype: object</code></pre>
<h2 id="6-Merge"><a href="#6-Merge" class="headerlink" title="6. Merge"></a><strong>6. Merge</strong></h2><h3 id="Concat-연결"><a href="#Concat-연결" class="headerlink" title="- Concat (연결)"></a><strong>- Concat (연결)</strong></h3><p>결합(join)/병합(merge) 형태의 연산에 관한 인덱스, 관계 대수 기능을 위한 다양한 형태의 논리를 포함한 Series, 데이터프레임, Panel 객체를 손쉽게 결합하는 기능이 있다.  </p>
<p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">- 참고: Merging</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concat()으로 pandas 객체 연결</span></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.044225</td>
      <td>0.155778</td>
      <td>0.674068</td>
      <td>-1.489455</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.504468</td>
      <td>-2.412972</td>
      <td>-0.541338</td>
      <td>0.556083</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.849690</td>
      <td>0.618393</td>
      <td>-0.587040</td>
      <td>0.065025</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.112398</td>
      <td>0.415087</td>
      <td>-0.452262</td>
      <td>1.626640</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.043760</td>
      <td>-1.345565</td>
      <td>-0.534134</td>
      <td>-0.112001</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1.280222</td>
      <td>1.533708</td>
      <td>0.054365</td>
      <td>0.290299</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.476762</td>
      <td>1.399581</td>
      <td>0.342671</td>
      <td>-0.624159</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.231877</td>
      <td>0.835411</td>
      <td>-0.527813</td>
      <td>0.502120</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0.268321</td>
      <td>-0.991597</td>
      <td>0.900198</td>
      <td>2.113147</td>
    </tr>
    <tr>
      <th>9</th>
      <td>-0.403591</td>
      <td>-0.531963</td>
      <td>-1.762530</td>
      <td>-2.067926</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># break it into pieces</span></span><br><span class="line">pieces = [df[:<span class="number">3</span>], df[<span class="number">3</span>:<span class="number">7</span>], df[<span class="number">7</span>:]]</span><br><span class="line">pd.concat(pieces)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.044225</td>
      <td>0.155778</td>
      <td>0.674068</td>
      <td>-1.489455</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.504468</td>
      <td>-2.412972</td>
      <td>-0.541338</td>
      <td>0.556083</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.849690</td>
      <td>0.618393</td>
      <td>-0.587040</td>
      <td>0.065025</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.112398</td>
      <td>0.415087</td>
      <td>-0.452262</td>
      <td>1.626640</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.043760</td>
      <td>-1.345565</td>
      <td>-0.534134</td>
      <td>-0.112001</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1.280222</td>
      <td>1.533708</td>
      <td>0.054365</td>
      <td>0.290299</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.476762</td>
      <td>1.399581</td>
      <td>0.342671</td>
      <td>-0.624159</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.231877</td>
      <td>0.835411</td>
      <td>-0.527813</td>
      <td>0.502120</td>
    </tr>
    <tr>
      <th>8</th>
      <td>0.268321</td>
      <td>-0.991597</td>
      <td>0.900198</td>
      <td>2.113147</td>
    </tr>
    <tr>
      <th>9</th>
      <td>-0.403591</td>
      <td>-0.531963</td>
      <td>-1.762530</td>
      <td>-2.067926</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Join"><a href="#Join" class="headerlink" title="- Join"></a><strong>- Join</strong></h3><p>SQL 방식으로 병합한다.<br><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">- 참고: 데이터베이스 스타일 결합</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>], <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>], <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>lval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, on = <span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>lval</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>foo</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>foo</td>
      <td>2</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 다른 예시</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;rval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>lval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, on = <span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>lval</th>
      <th>rval</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>1</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>2</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Append-추가"><a href="#Append-추가" class="headerlink" title="- Append (추가)"></a><strong>- Append (추가)</strong></h3><p>데이터프레임에 행을 추가한다.<br><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html">- 참고: Appending</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>, <span class="number">4</span>), columns = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-1.293826</td>
      <td>0.735671</td>
      <td>1.108050</td>
      <td>-0.175206</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.949366</td>
      <td>1.468593</td>
      <td>1.386484</td>
      <td>0.963284</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.423707</td>
      <td>0.157079</td>
      <td>0.185440</td>
      <td>0.435985</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.478659</td>
      <td>1.293856</td>
      <td>-0.515603</td>
      <td>0.200678</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.096275</td>
      <td>1.907146</td>
      <td>-0.771668</td>
      <td>-0.622949</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.557493</td>
      <td>0.096811</td>
      <td>-0.901813</td>
      <td>-0.458602</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-0.072528</td>
      <td>-2.372909</td>
      <td>-1.428934</td>
      <td>1.458320</td>
    </tr>
    <tr>
      <th>7</th>
      <td>-0.199425</td>
      <td>-0.455105</td>
      <td>0.771140</td>
      <td>0.506667</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = df.iloc[<span class="number">3</span>]</span><br><span class="line">df.append(s, ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-1.293826</td>
      <td>0.735671</td>
      <td>1.108050</td>
      <td>-0.175206</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.949366</td>
      <td>1.468593</td>
      <td>1.386484</td>
      <td>0.963284</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.423707</td>
      <td>0.157079</td>
      <td>0.185440</td>
      <td>0.435985</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.478659</td>
      <td>1.293856</td>
      <td>-0.515603</td>
      <td>0.200678</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.096275</td>
      <td>1.907146</td>
      <td>-0.771668</td>
      <td>-0.622949</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.557493</td>
      <td>0.096811</td>
      <td>-0.901813</td>
      <td>-0.458602</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-0.072528</td>
      <td>-2.372909</td>
      <td>-1.428934</td>
      <td>1.458320</td>
    </tr>
    <tr>
      <th>7</th>
      <td>-0.199425</td>
      <td>-0.455105</td>
      <td>0.771140</td>
      <td>0.506667</td>
    </tr>
    <tr>
      <th>8</th>
      <td>-0.478659</td>
      <td>1.293856</td>
      <td>-0.515603</td>
      <td>0.200678</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="7-Grouping"><a href="#7-Grouping" class="headerlink" title="7. Grouping"></a><strong>7. Grouping</strong></h2><p>그룹화는 다음 단계 중 하나 이상을 포함하는 과정을 말한다.  </p>
<ul>
<li>몇몇 기준에 따라 여러 그룹으로 데이터를 분할(splitting)  </li>
<li>각 그룹에 독립적으로 함수를 적용(applying)  </li>
<li>결과물을 하나의 데이터 구조로 결합(combining)  </li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html">- 참고: 그룹화</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: np.random.randn(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>foo</td>
      <td>one</td>
      <td>0.024720</td>
      <td>-1.293299</td>
    </tr>
    <tr>
      <th>1</th>
      <td>bar</td>
      <td>one</td>
      <td>1.510969</td>
      <td>0.509977</td>
    </tr>
    <tr>
      <th>2</th>
      <td>foo</td>
      <td>two</td>
      <td>0.342461</td>
      <td>-0.811380</td>
    </tr>
    <tr>
      <th>3</th>
      <td>bar</td>
      <td>three</td>
      <td>0.227221</td>
      <td>0.717127</td>
    </tr>
    <tr>
      <th>4</th>
      <td>foo</td>
      <td>two</td>
      <td>0.089665</td>
      <td>0.040704</td>
    </tr>
    <tr>
      <th>5</th>
      <td>bar</td>
      <td>two</td>
      <td>-0.336139</td>
      <td>1.132600</td>
    </tr>
    <tr>
      <th>6</th>
      <td>foo</td>
      <td>one</td>
      <td>0.301063</td>
      <td>-0.133439</td>
    </tr>
    <tr>
      <th>7</th>
      <td>foo</td>
      <td>three</td>
      <td>0.167332</td>
      <td>0.789836</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 생성된 데이터프레임을 그룹화한 후, 각 그룹에 sum() 함수 적용</span></span><br><span class="line">df.groupby(<span class="string">&#x27;A&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>C</th>
      <th>D</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>bar</th>
      <td>1.402051</td>
      <td>2.359705</td>
    </tr>
    <tr>
      <th>foo</th>
      <td>0.925241</td>
      <td>-1.407579</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 여러 열을 기준으로 그룹화하면 계층적 인덱스가 형성, 여기에도 sum 함수 적용 가능</span></span><br><span class="line">df.groupby([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>C</th>
      <th>D</th>
    </tr>
    <tr>
      <th>A</th>
      <th>B</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">bar</th>
      <th>one</th>
      <td>1.510969</td>
      <td>0.509977</td>
    </tr>
    <tr>
      <th>three</th>
      <td>0.227221</td>
      <td>0.717127</td>
    </tr>
    <tr>
      <th>two</th>
      <td>-0.336139</td>
      <td>1.132600</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">foo</th>
      <th>one</th>
      <td>0.325783</td>
      <td>-1.426738</td>
    </tr>
    <tr>
      <th>three</th>
      <td>0.167332</td>
      <td>0.789836</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.432126</td>
      <td>-0.770676</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="8-Reshaping"><a href="#8-Reshaping" class="headerlink" title="8. Reshaping"></a><strong>8. Reshaping</strong></h2><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html">- 참고: 계층적 인덱싱</a>, <a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html">변형</a>  </p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="- Stack"></a><strong>- Stack</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tuples = <span class="built_in">list</span>(<span class="built_in">zip</span>(*[[<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]]))</span><br><span class="line"></span><br><span class="line">index = pd.MultiIndex.from_tuples(tuples, names = [<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">8</span>, <span class="number">2</span>), index=index, columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line">df2 = df[:<span class="number">4</span>]</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
    <tr>
      <th>first</th>
      <th>second</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">bar</th>
      <th>one</th>
      <td>0.164873</td>
      <td>-1.599363</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.262695</td>
      <td>0.130688</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">baz</th>
      <th>one</th>
      <td>1.062799</td>
      <td>1.995716</td>
    </tr>
    <tr>
      <th>two</th>
      <td>-1.389387</td>
      <td>-1.260636</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stack() 메소드는 데이터프레임 열들의 계층을 압축</span></span><br><span class="line">stacked = df2.stack()</span><br><span class="line">stacked</span><br></pre></td></tr></table></figure>




<pre><code>first  second   
bar    one     A    0.164873
               B   -1.599363
       two     A    0.262695
               B    0.130688
baz    one     A    1.062799
               B    1.995716
       two     A   -1.389387
               B   -1.260636
dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Stack된 데이터프레임 또는 MultiIndex를 인덱스로 사용하는 Series인 경우,</span></span><br><span class="line"><span class="comment"># stack()의 역연산은 unstack()이며 기본적으로 마지막 계층을 unstack함</span></span><br><span class="line">stacked.unstack()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
    <tr>
      <th>first</th>
      <th>second</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">bar</th>
      <th>one</th>
      <td>0.164873</td>
      <td>-1.599363</td>
    </tr>
    <tr>
      <th>two</th>
      <td>0.262695</td>
      <td>0.130688</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">baz</th>
      <th>one</th>
      <td>1.062799</td>
      <td>1.995716</td>
    </tr>
    <tr>
      <th>two</th>
      <td>-1.389387</td>
      <td>-1.260636</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stacked.unstack(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>second</th>
      <th>one</th>
      <th>two</th>
    </tr>
    <tr>
      <th>first</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">bar</th>
      <th>A</th>
      <td>0.164873</td>
      <td>0.262695</td>
    </tr>
    <tr>
      <th>B</th>
      <td>-1.599363</td>
      <td>0.130688</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">baz</th>
      <th>A</th>
      <td>1.062799</td>
      <td>-1.389387</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1.995716</td>
      <td>-1.260636</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stacked.unstack(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>first</th>
      <th>bar</th>
      <th>baz</th>
    </tr>
    <tr>
      <th>second</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">one</th>
      <th>A</th>
      <td>0.164873</td>
      <td>1.062799</td>
    </tr>
    <tr>
      <th>B</th>
      <td>-1.599363</td>
      <td>1.995716</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">two</th>
      <th>A</th>
      <td>0.262695</td>
      <td>-1.389387</td>
    </tr>
    <tr>
      <th>B</th>
      <td>0.130688</td>
      <td>-1.260636</td>
    </tr>
  </tbody>
</table>
</div>



<h3 id="Pivot-Tables"><a href="#Pivot-Tables" class="headerlink" title="- Pivot Tables"></a><strong>- Pivot Tables</strong></h3><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html">- 참고: 피봇 테이블</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>] * <span class="number">3</span>,</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>] * <span class="number">4</span>,</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>] * <span class="number">2</span>,</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>: np.random.randn(<span class="number">12</span>),</span><br><span class="line">                   <span class="string">&#x27;E&#x27;</span>: np.random.randn(<span class="number">12</span>)&#125;)</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
      <th>E</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>one</td>
      <td>A</td>
      <td>foo</td>
      <td>-0.335507</td>
      <td>0.728239</td>
    </tr>
    <tr>
      <th>1</th>
      <td>one</td>
      <td>B</td>
      <td>foo</td>
      <td>-0.251893</td>
      <td>1.290054</td>
    </tr>
    <tr>
      <th>2</th>
      <td>two</td>
      <td>C</td>
      <td>foo</td>
      <td>0.590448</td>
      <td>0.226098</td>
    </tr>
    <tr>
      <th>3</th>
      <td>three</td>
      <td>A</td>
      <td>bar</td>
      <td>1.207361</td>
      <td>0.915646</td>
    </tr>
    <tr>
      <th>4</th>
      <td>one</td>
      <td>B</td>
      <td>bar</td>
      <td>0.296306</td>
      <td>-1.981152</td>
    </tr>
    <tr>
      <th>5</th>
      <td>one</td>
      <td>C</td>
      <td>bar</td>
      <td>0.166610</td>
      <td>-0.312002</td>
    </tr>
    <tr>
      <th>6</th>
      <td>two</td>
      <td>A</td>
      <td>foo</td>
      <td>1.505633</td>
      <td>-0.791708</td>
    </tr>
    <tr>
      <th>7</th>
      <td>three</td>
      <td>B</td>
      <td>foo</td>
      <td>-1.978302</td>
      <td>-1.671514</td>
    </tr>
    <tr>
      <th>8</th>
      <td>one</td>
      <td>C</td>
      <td>foo</td>
      <td>1.263163</td>
      <td>-2.340603</td>
    </tr>
    <tr>
      <th>9</th>
      <td>one</td>
      <td>A</td>
      <td>bar</td>
      <td>-0.028701</td>
      <td>-1.374556</td>
    </tr>
    <tr>
      <th>10</th>
      <td>two</td>
      <td>B</td>
      <td>bar</td>
      <td>0.657087</td>
      <td>0.272042</td>
    </tr>
    <tr>
      <th>11</th>
      <td>three</td>
      <td>C</td>
      <td>bar</td>
      <td>0.351417</td>
      <td>1.455815</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 피봇 테이블 생성</span></span><br><span class="line">pd.pivot_table(df, values=<span class="string">&#x27;D&#x27;</span>, index=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>], columns=[<span class="string">&#x27;C&#x27;</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>C</th>
      <th>bar</th>
      <th>foo</th>
    </tr>
    <tr>
      <th>A</th>
      <th>B</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">one</th>
      <th>A</th>
      <td>-0.028701</td>
      <td>-0.335507</td>
    </tr>
    <tr>
      <th>B</th>
      <td>0.296306</td>
      <td>-0.251893</td>
    </tr>
    <tr>
      <th>C</th>
      <td>0.166610</td>
      <td>1.263163</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">three</th>
      <th>A</th>
      <td>1.207361</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>B</th>
      <td>NaN</td>
      <td>-1.978302</td>
    </tr>
    <tr>
      <th>C</th>
      <td>0.351417</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">two</th>
      <th>A</th>
      <td>NaN</td>
      <td>1.505633</td>
    </tr>
    <tr>
      <th>B</th>
      <td>0.657087</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>C</th>
      <td>NaN</td>
      <td>0.590448</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="9-Time-Series"><a href="#9-Time-Series" class="headerlink" title="9. Time Series"></a><strong>9. Time Series</strong></h2><p>Pandas는 자주 일어나는 변환(ex. 5분마다 일어나는 데이터의 2차 데이터 변환) 사이에 수행하는 리샘플링 연산을 위해 간단하고 강력하고 효율적인 함수를 제공한다.<br>재무(금융) 응용에서 매우 일반적이나 이에 국한되지는 않는다.<br><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html">- 참고: 시계열</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">&#x27;1/1/2012&#x27;</span>, periods=<span class="number">100</span>, freq=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randint(<span class="number">0</span>, <span class="number">500</span>, <span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line">ts.resample(<span class="string">&#x27;5Min&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<pre><code>2012-01-01    25049
Freq: 5T, dtype: int64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시간대 표현</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;3/6/2012 00:00&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), rng)</span><br><span class="line">ts</span><br></pre></td></tr></table></figure>




<pre><code>2012-03-06    0.099699
2012-03-07    0.235671
2012-03-08    0.636022
2012-03-09   -1.993396
2012-03-10   -0.113581
Freq: D, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ts_utc = ts.tz_localize(<span class="string">&#x27;UTC&#x27;</span>)</span><br><span class="line">ts_utc</span><br></pre></td></tr></table></figure>




<pre><code>2012-03-06 00:00:00+00:00    0.099699
2012-03-07 00:00:00+00:00    0.235671
2012-03-08 00:00:00+00:00    0.636022
2012-03-09 00:00:00+00:00   -1.993396
2012-03-10 00:00:00+00:00   -0.113581
Freq: D, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 다른 시간대로 변환</span></span><br><span class="line">ts_utc.tz_convert(<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>2012-03-05 19:00:00-05:00    0.099699
2012-03-06 19:00:00-05:00    0.235671
2012-03-07 19:00:00-05:00    0.636022
2012-03-08 19:00:00-05:00   -1.993396
2012-03-09 19:00:00-05:00   -0.113581
Freq: D, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시간 표현 ↔ 기간 표현 변환</span></span><br><span class="line">rng = pd.date_range(<span class="string">&#x27;1/1/2012&#x27;</span>, periods=<span class="number">5</span>, freq=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(rng)), index=rng)</span><br><span class="line">ts</span><br></pre></td></tr></table></figure>




<pre><code>2012-01-31   -1.161855
2012-02-29    0.262081
2012-03-31    0.238179
2012-04-30   -1.160233
2012-05-31    0.816160
Freq: M, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps = ts.to_period()</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>




<pre><code>2012-01   -1.161855
2012-02    0.262081
2012-03    0.238179
2012-04   -1.160233
2012-05    0.816160
Freq: M, dtype: float64</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps.to_timestamp()</span><br></pre></td></tr></table></figure>




<pre><code>2012-01-01   -1.161855
2012-02-01    0.262081
2012-03-01    0.238179
2012-04-01   -1.160233
2012-05-01    0.816160
Freq: MS, dtype: float64</code></pre>
<p>기간 ↔ 시간 변환은 편리한 산술 기능을 사용할 수 있도록 만든다.<br>11월에 끝나는 연말 결산의 분기별 빈도를, 분기말 익월의 월말일 오전 9시로 변환해보자.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prng = pd.period_range(<span class="string">&#x27;1990Q1&#x27;</span>, <span class="string">&#x27;2000Q4&#x27;</span>, freq=<span class="string">&#x27;Q-NOV&#x27;</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(<span class="built_in">len</span>(prng)), prng)</span><br><span class="line">ts.index = (prng.asfreq(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) + <span class="number">1</span>).asfreq(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">ts.head()</span><br></pre></td></tr></table></figure>




<pre><code>1990-03-01 00:00    0.671614
1990-06-01 00:00   -0.141739
1990-09-01 00:00    0.070749
1990-12-01 00:00   -0.769261
1991-03-01 00:00   -0.432595
Freq: H, dtype: float64</code></pre>
<h2 id="10-Categoricals"><a href="#10-Categoricals" class="headerlink" title="10. Categoricals"></a><strong>10. Categoricals</strong></h2><p>Pandas는 데이터프레임 내에 범주형 데이터를 포함할 수 있다.<br><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html">- 참고: 범주형 소개</a>, <a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/reference/index.html">API 문서</a>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="string">&quot;raw_grade&quot;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>가공하지 않은 성적을 범주형 데이터로 변환한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;grade&quot;</span>] = df[<span class="string">&quot;raw_grade&quot;</span>].astype(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">df[<span class="string">&quot;grade&quot;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0    a
1    b
2    b
3    a
4    a
5    e
Name: grade, dtype: category
Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;e&#39;]</code></pre>
<p>범주에 더 의미있는 이름을 붙이자. (Series.cat.categories로 할당하는 것이 적합)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;grade&quot;</span>].cat.categories = [<span class="string">&quot;very good&quot;</span>, <span class="string">&quot;good&quot;</span>, <span class="string">&quot;very bad&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>범주 순서를 바꾸고 동시에 누락된 범주를 추가한다. (Series.cat에 속하는 메소드는 기본적으로 새로운 Series를 반환)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&quot;grade&quot;</span>] = df[<span class="string">&quot;grade&quot;</span>].cat.set_categories([<span class="string">&quot;very bad&quot;</span>, <span class="string">&quot;bad&quot;</span>, <span class="string">&quot;medium&quot;</span>, <span class="string">&quot;good&quot;</span>, <span class="string">&quot;very good&quot;</span>])</span><br><span class="line">df[<span class="string">&quot;grade&quot;</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0    very good
1         good
2         good
3    very good
4    very good
5     very bad
Name: grade, dtype: category
Categories (5, object): [&#39;very bad&#39;, &#39;bad&#39;, &#39;medium&#39;, &#39;good&#39;, &#39;very good&#39;]</code></pre>
<p>정렬은 사전 순서가 아니라, 해당 범주에서 지정된 순서대로 배열한다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=<span class="string">&quot;grade&quot;</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>raw_grade</th>
      <th>grade</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5</th>
      <td>6</td>
      <td>e</td>
      <td>very bad</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>b</td>
      <td>good</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>b</td>
      <td>good</td>
    </tr>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>a</td>
      <td>very good</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>a</td>
      <td>very good</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>a</td>
      <td>very good</td>
    </tr>
  </tbody>
</table>
</div>



<p>범주의 열을 기준으로 그룹화하면 빈 범주도 표시된다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&quot;grade&quot;</span>).size()</span><br></pre></td></tr></table></figure>




<pre><code>grade
very bad     1
bad          0
medium       0
good         2
very good    3
dtype: int64</code></pre>
<h2 id="11-Plotting"><a href="#11-Plotting" class="headerlink" title="11. Plotting"></a><strong>11. Plotting</strong></h2><p><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html">- 참고: Plotting</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">1000</span>), index=pd.date_range(<span class="string">&#x27;1/1/2000&#x27;</span>, periods=<span class="number">1000</span>))</span><br><span class="line">ts = ts.cumsum()</span><br><span class="line">ts.plot</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.plotting._core.PlotAccessor object at 0x7f4670f2ae80&gt;</code></pre>
<p>데이터프레임에서 plot() 메소드는 라벨이 존재하는 모든 열을 그릴 때 편리하다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index=ts.index,</span><br><span class="line">                  columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])  </span><br><span class="line">df = df.cumsum()</span><br><span class="line">plt.figure(); df.plot(); plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-97-bc219ebae1fe&gt; in &lt;module&gt;()
----&gt; 1 df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index,
      2                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])  
      3 df = df.cumsum()
      4 plt.figure(); df.plot(); plt.legend(loc=&#39;best&#39;)


/usr/local/lib/python3.6/dist-packages/pandas/core/generic.py in __getattr__(self, name)
   5137             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   5138                 return self[name]
-&gt; 5139             return object.__getattribute__(self, name)
   5140 
   5141     def __setattr__(self, name: str, value) -&gt; None:


AttributeError: &#39;DataFrame&#39; object has no attribute &#39;DataFrame&#39;</code></pre>
<h2 id="12-Getting-Data-In-Out"><a href="#12-Getting-Data-In-Out" class="headerlink" title="12. Getting Data In / Out"></a><strong>12. Getting Data In / Out</strong></h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a><strong>CSV</strong></h3><p>csv 파일에 쓴다.<br>df.to_csv(‘foo.csv’)  </p>
<p>csv 파일을 읽는다.<br>pd.read_csv(‘foo.csv’)</p>
<h3 id="HDF5"><a href="#HDF5" class="headerlink" title="HDF5"></a><strong>HDF5</strong></h3><p>HDF5 Store에 쓴다.<br>df.to_hdf(‘foo.h5’,’df’)<br>HDF5 Store에서 읽는다.<br>pd.read_hdf(‘foo.h5’,’df’)  </p>
<h3 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a><strong>Excel</strong></h3><p>엑셀 파일에 쓴다.<br>df.to_excel(‘foo.xlsx’, sheet_name=’Sheet1’)<br>엑셀 파일을 읽는다.<br>pd.read_excel(‘foo.xlsx’, ‘Sheet1’, index_col=None, na_values=[‘NA’])  </p>
<h2 id="13-Gotchas"><a href="#13-Gotchas" class="headerlink" title="13. Gotchas"></a><strong>13. Gotchas</strong></h2><p>연산 수행 시, 다음과 같은 예외 상황이 나타날 수 있다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pd.Series([<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]):</span><br><span class="line">  print(<span class="string">&quot;I was true&quot;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-104-06fa23a4b3e2&gt; in &lt;module&gt;()
----&gt; 1 if pd.Series([False, True, False]):
      2   print(&quot;I was true&quot;)


/usr/local/lib/python3.6/dist-packages/pandas/core/generic.py in __getattr__(self, name)
   5137             if self._info_axis._can_hold_identifiers_and_holds_name(name):
   5138                 return self[name]
-&gt; 5139             return object.__getattribute__(self, name)
   5140 
   5141     def __setattr__(self, name: str, value) -&gt; None:


AttributeError: &#39;DataFrame&#39; object has no attribute &#39;Series&#39;</code></pre>
<p>이러한 경우에는 any(), all(), empty 등을 사용해서 무엇을 원하는지를 선택해주어야 한다.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pd.Series([<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">&quot;I was not None&quot;</span>)</span><br></pre></td></tr></table></figure>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/10/Pandas_10%EB%B6%84_%EC%99%84%EC%84%B1/" data-id="ckjqkgbaq0033wkue8qs83gih" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/10-Minutes-to-Pandas/" rel="tag">10 Minutes to Pandas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/matplotlib/" rel="tag">matplotlib</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/numpy/" rel="tag">numpy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pandas/" rel="tag">pandas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ch3_1&amp;2_lists_tuples_and_dictionary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/09/ch3_1&2_lists_tuples_and_dictionary/">Ch03(1&amp;2): Lists, Tuples, and Dictionary</a>
    </h1>
  

        <a href="/2020/11/09/ch3_1&2_lists_tuples_and_dictionary/" class="article-date">
  <time datetime="2020-11-09T00:00:00.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="Lists-Tuples-and-Dictionary"><a href="#Lists-Tuples-and-Dictionary" class="headerlink" title="Lists, Tuples, and Dictionary"></a><strong>Lists, Tuples, and Dictionary</strong></h1><p><a target="_blank" rel="noopener" href="https://dschloe.github.io/python/python_edu/01_basic/chapter_3_1_lists_and_tuples">* 출처: dschloe.github.io</a></p>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><ul>
<li>List는 [] 형태로 정의</li>
<li>List는 정렬(ordered)됨</li>
<li>List는 다양한 형태의 데이터 유형을 담을 수 있음</li>
<li>List 안에 있는 값에는 인덱스로 접근</li>
<li>List 안에 또 List를 담을 수 있음</li>
<li>List는 변하기 쉬움</li>
<li>List는 동적임</li>
</ul>
<h3 id="1-List는-정렬-ordered-됨"><a href="#1-List는-정렬-ordered-됨" class="headerlink" title="1) List는 정렬(ordered)됨"></a>1) List는 정렬(ordered)됨</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파이썬의 기초 자료형</span></span><br><span class="line">alphabet = [[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>], [<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>]]</span><br><span class="line">print(alphabet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># List 자료형은 Matplolib 시각화에, Numpy 기초 자료(행렬, 딥러닝 연산에 자주 활용)로 활용됨</span></span><br></pre></td></tr></table></figure>

<pre><code>[[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a1 = a2?</span></span><br><span class="line">a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a1 == a2</span><br><span class="line"><span class="comment"># False가 나온 이유? 순서가 다르면 서로 다른 자료</span></span><br></pre></td></tr></table></figure>




<pre><code>False</code></pre>
<h3 id="2-다양한-형태의-List"><a href="#2-다양한-형태의-List" class="headerlink" title="2) 다양한 형태의 List"></a>2) 다양한 형태의 List</h3><ul>
<li>리스트 하나에 여러 형태의 자료를 담을 수 있다</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multi_values = [<span class="number">11.1</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="literal">True</span>]</span><br><span class="line">print(multi_values)</span><br></pre></td></tr></table></figure>

<pre><code>[11.1, &#39;foo&#39;, 3, 5, True]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> <span class="comment"># 하나의 함수이자 클래스, List에 담을 수도 있음</span></span><br></pre></td></tr></table></figure>




<pre><code>float</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span> <span class="comment"># 값의 길이, 값이 몇 개인지 표시, 하나의 함수지만 List에 담을 수 있음</span></span><br><span class="line"><span class="built_in">len</span>(multi_values)</span><br></pre></td></tr></table></figure>




<pre><code>5</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 사용자 정의 함수, List에 담을 수 있음</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">temp</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>&lt;function __main__.temp()&gt;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 리스트에 다양한 형태 담아보기</span></span><br><span class="line">fun_list = [<span class="built_in">float</span>, temp, <span class="built_in">len</span>]</span><br><span class="line">print(fun_list)</span><br></pre></td></tr></table></figure>

<pre><code>[&lt;class &#39;float&#39;&gt;, &lt;function temp at 0x000001D5446B4700&gt;, &lt;built-in function len&gt;]</code></pre>
<h3 id="3-List-접근-방법-index"><a href="#3-List-접근-방법-index" class="headerlink" title="3) List 접근 방법_index"></a>3) List 접근 방법_index</h3><ul>
<li>순서는 <code>0</code>부터 시작</li>
<li>역순으로 할 경우 <code>-1</code>부터 시작</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alphabet_temp = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># python에서 순서는 &#x27;0&#x27;부터 시작</span></span><br><span class="line">alphabet_temp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;A&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Negative List</span></span><br><span class="line"><span class="comment"># python에서 거꾸로 지시하는 순서는 &#x27;&#x27;-1&#x27;부터 시작</span></span><br><span class="line">alphabet_temp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;E&#39;</code></pre>
<p>*** 슬라이싱**</p>
<ul>
<li>‘:’ 기호를 이용해 연속한 데이터를 슬라이싱해서 추출</li>
<li>temp[M:N]: M번째부터 N 미만까지 값을 가져옴</li>
<li>i.g temp[0:5]를 해야 알파벳 5개를 모두 가져올 수 있음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alphabet 슬라이싱으로 추출해보기</span></span><br><span class="line">alphabet_temp[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;C&#39;, &#39;D&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alphabet_temp[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]</code></pre>
<h3 id="4-List-안에-List-담기"><a href="#4-List-안에-List-담기" class="headerlink" title="4) List 안에 List 담기"></a>4) List 안에 List 담기</h3><ul>
<li>List 안에 다양한 데이터를 넣을 수 있는데, 여기에는 List도 포함됨</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;bb&#x27;</span>, [<span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>], <span class="string">&#x27;ee&#x27;</span>, <span class="string">&#x27;ff&#x27;</span>], <span class="string">&#x27;g&#x27;</span>, [<span class="string">&#x27;hh&#x27;</span>, <span class="string">&#x27;ii&#x27;</span>], <span class="string">&#x27;j&#x27;</span>]</span><br><span class="line">x</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;a&#39;, [&#39;bb&#39;, [&#39;ccc&#39;, &#39;ddd&#39;], &#39;ee&#39;, &#39;ff&#39;], &#39;g&#39;, [&#39;hh&#39;, &#39;ii&#39;], &#39;j&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 인덱스로 접근해보기</span></span><br><span class="line">x[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;a&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;bb&#39;, [&#39;ccc&#39;, &#39;ddd&#39;], &#39;ee&#39;, &#39;ff&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># x의 2번째 list 중 1번째 값 불러오기</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;bb&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] <span class="comment"># x의 2번째 list 중, 2번째 list의 1번째 값 불러오기</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;ccc&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>][<span class="number">0</span>] <span class="comment"># x의 5번째 list 중, 1번째 값 불러오기</span></span><br></pre></td></tr></table></figure>




<pre><code>&#39;hh&#39;</code></pre>
<h3 id="5-List는-변하기-쉬움"><a href="#5-List는-변하기-쉬움" class="headerlink" title="5) List는 변하기 쉬움"></a>5) List는 변하기 쉬움</h3><ul>
<li>Mutable</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;string immutable&quot;</span></span><br><span class="line">message[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;s&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 문자열은 바로 치환되지 않아 에러가 나타남 = Immutable</span></span><br><span class="line">message[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-45-e59a77b7a4e6&gt; in &lt;module&gt;
      1 # 문자열은 바로 치환되지 않아 에러가 나타남 = Immutable
----&gt; 2 message[0] = &#39;p&#39;
      3 print(message)


TypeError: &#39;str&#39; object does not support item assignment</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List의 경우 살펴보기</span></span><br><span class="line">a = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;quux&#x27;</span>, <span class="string">&#x27;corge&#x27;</span>]</span><br><span class="line">a[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&#39;bar&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>]=<span class="number">10</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;foo&#39;, 10, &#39;baz&#39;, &#39;qux&#39;, &#39;quux&#39;, &#39;corge&#39;]</code></pre>
<ul>
<li>string에서 바뀌지 않던 것이 list에서는 쉽게 바뀜</li>
<li>쉽게 바뀌는 list의 성질을 <code>Mutable</code>이라고 표현<br>(Tuple은 immutable)</li>
</ul>
<h3 id="6-List는-동적임"><a href="#6-List는-동적임" class="headerlink" title="6) List는 동적임"></a>6) List는 동적임</h3><ul>
<li>Mutable이라는 뜻 자체가 매우 동적임을 나타냄</li>
<li>다양한 형태로 작업이 가능함</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">temp[<span class="number">3</span>:<span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list에 값 추가하기</span></span><br><span class="line">temp += [<span class="number">1000</span>]</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, 1000]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list에서 값 삭제하기</span></span><br><span class="line">temp[<span class="number">3</span>:<span class="number">6</span>] = []</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, 1000]</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> temp[<span class="number">6</span>]</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;]</code></pre>
<h2 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h2><ul>
<li>Lists와 비슷하지만 세부 특성이 다름</li>
<li>List는 []로 표현하나, Tuple은 ()라고 표현</li>
<li>Tuple은 immutable: 처음부터 바꾸는 것 외에는 방법이 없음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp = (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># immutable이기 때문에 바뀌지 않음</span></span><br><span class="line">temp[<span class="number">2</span>] = <span class="string">&quot;Cat&quot;</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-75-266ec228a7d8&gt; in &lt;module&gt;
      1 # immutable이기 때문에 바뀌지 않음
----&gt; 2 temp[2] = &quot;Cat&quot;


TypeError: &#39;tuple&#39; object does not support item assignment</code></pre>
<h3 id="1-Tuples을-사용하는-이유"><a href="#1-Tuples을-사용하는-이유" class="headerlink" title="1) Tuples을 사용하는 이유?"></a>1) Tuples을 사용하는 이유?</h3><ul>
<li>데이터 분석에서 접근하면, 특정 데이터가 변하지 않도록 방지하는 기법</li>
<li>프로그래밍적으로 Tuple이 List보다 연산 속도가 빠름</li>
<li>Dictionary도 문자열과 같은 immutable type을 요구</li>
<li>Tuples은 Packing &amp; Unpacking 기법이 강력함(일종의 여행용 가방)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;hey&quot;</span>, <span class="string">&quot;yeah&quot;</span>)</span><br><span class="line">t</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;foo&#39;, &#39;bar&#39;, &#39;hey&#39;, &#39;yeah&#39;)</code></pre>
<ul>
<li><strong>Unpacking</strong>: 각각의 <code>element</code>를 다른 이름으로 저장해보기</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(s1, s2, s3, s4) = t</span><br><span class="line">s2</span><br></pre></td></tr></table></figure>




<pre><code>&#39;bar&#39;</code></pre>
<ul>
<li>이때, 반드시 좌우 값이 동일하게 작동해야 함</li>
<li>만약 좌우 값이 일치하지 않으면 에러가 발생</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 코드를 통해 확인</span></span><br><span class="line">(a1, a2, a3) = t</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-89-76bce831b49d&gt; in &lt;module&gt;
----&gt; 1 (a1, a2, a3) = t


ValueError: too many values to unpack (expected 3)</code></pre>
<h3 id="2-swap"><a href="#2-swap" class="headerlink" title="2) swap"></a>2) swap</h3><ul>
<li>스왑은 맞바꾸다의 뜻</li>
<li><code>Tuple</code>에서는 매우 쉽게 <code>swap</code>이 가능</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="string">&quot;chloe&quot;</span></span><br><span class="line">v1 = <span class="string">&quot;loves&quot;</span></span><br><span class="line">a2 = <span class="string">&quot;evan&quot;</span></span><br><span class="line"></span><br><span class="line">temp = a1, v1, a2 <span class="comment"># Tuple 형태로 표시됨</span></span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;chloe&#39;, &#39;loves&#39;, &#39;evan&#39;)</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1, a2 = a2, a1</span><br><span class="line">temp = a1, v1, a2 <span class="comment"># Tuple 형태로 표시</span></span><br><span class="line">temp</span><br></pre></td></tr></table></figure>




<pre><code>(&#39;evan&#39;, &#39;loves&#39;, &#39;chloe&#39;)</code></pre>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><ul>
<li>영어 원뜻 그대로 <code>사전</code>이라는 개념</li>
<li>Dictionary는 {}로 표현</li>
<li>List와 유사한 부분이 많음<ul>
<li>Mutable이라는 뜻을 포함</li>
<li>다른 Dictionary, List 등을 포함할 수 있음</li>
</ul>
</li>
<li>List와의 차이<ul>
<li>List에서 각 원소에 접근하기 위해 index를 사용</li>
<li>Dictionary에서는 각 원소에 접근하기 위해 key를 사용</li>
</ul>
</li>
<li>Rename할 때 자주 사용</li>
</ul>
<h3 id="1-Dictionary-정의"><a href="#1-Dictionary-정의" class="headerlink" title="1) Dictionary 정의"></a>1) Dictionary 정의</h3><ul>
<li>Dictionary의 기본적인 문법<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &lt;키&gt;: &lt;값&gt;,</span><br><span class="line">    &lt;키&gt;: &lt;값&gt;,</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">      .</span><br><span class="line">    &lt;키&gt;: &lt;값&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 국내 야구팀을 Dictionary 형태로 만들기</span></span><br><span class="line">kbo = &#123;</span><br><span class="line">    <span class="string">&quot;인천&quot;</span> : <span class="string">&quot;SK&quot;</span>,</span><br><span class="line">    <span class="string">&quot;수원&quot;</span> : <span class="string">&quot;KT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;광주&quot;</span> : <span class="string">&quot;기아&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(kbo)</span><br></pre></td></tr></table></figure>

<pre><code>&#123;&#39;인천&#39;: &#39;SK&#39;, &#39;수원&#39;: &#39;KT&#39;, &#39;광주&#39;: &#39;기아&#39;&#125;</code></pre>
<h3 id="2-Dictionary-접근법"><a href="#2-Dictionary-접근법" class="headerlink" title="2) Dictionary 접근법"></a>2) Dictionary 접근법</h3><ul>
<li>indexing이 아닌 <code>key 값</code>으로 접근 가능</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(kbo[<span class="number">1</span>]) <span class="comment"># index로 추출할 수 없음</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

KeyError                                  Traceback (most recent call last)

&lt;ipython-input-81-8f1aa6e7486b&gt; in &lt;module&gt;
----&gt; 1 print(kbo[1]) # index로 추출할 수 없음


KeyError: 1</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary는 key 값을 넣어줘야 호출할 수 있음</span></span><br><span class="line">print(kbo[<span class="string">&quot;수원&quot;</span>])</span><br></pre></td></tr></table></figure>

<pre><code>KT</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary에 값 추가하기</span></span><br><span class="line">kbo[<span class="string">&quot;대구&quot;</span>] = <span class="string">&quot;삼성&quot;</span></span><br><span class="line">print(kbo)</span><br></pre></td></tr></table></figure>

<pre><code>&#123;&#39;인천&#39;: &#39;SK&#39;, &#39;수원&#39;: &#39;KT&#39;, &#39;광주&#39;: &#39;기아&#39;, &#39;대구&#39;: &#39;삼성&#39;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary에서 값 삭제하기</span></span><br><span class="line"><span class="keyword">del</span> kbo[<span class="string">&quot;대구&quot;</span>]</span><br><span class="line">kbo</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;인천&#39;: &#39;SK&#39;, &#39;수원&#39;: &#39;KT&#39;, &#39;광주&#39;: &#39;기아&#39;&#125;</code></pre>
<h3 id="3-Dictionary-Using-Integer"><a href="#3-Dictionary-Using-Integer" class="headerlink" title="3) Dictionary Using Integer"></a>3) Dictionary Using Integer</h3><ul>
<li>이전까지 접근한 것은 문자를 이요해 접근</li>
<li><code>Integer</code>로 활용하는 방법은?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;d&#x27;</span>&#125;</span><br><span class="line">dic</span><br></pre></td></tr></table></figure>




<pre><code>&#123;0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(dic[<span class="number">0</span>])</span><br><span class="line">print(dic[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<pre><code>a
b</code></pre>
<p>*** 주의할 점**</p>
<ul>
<li>dic는 <code>list</code>가 아님</li>
<li>list에서 할 수 있던, sclicing이나 append를 사용할 수 없음</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 에러 1: dictionary에는 append라는 속성값이 없음</span></span><br><span class="line">dic.append(<span class="string">&quot;e&quot;</span>)</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

AttributeError                            Traceback (most recent call last)

&lt;ipython-input-101-ea0dea029ae5&gt; in &lt;module&gt;
      1 # 에러 1: dictionary에는 append라는 속성값이 없음
----&gt; 2 dic.append(&quot;e&quot;)


AttributeError: &#39;dict&#39; object has no attribute &#39;append&#39;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 에러 2: slice 작동하지 않음</span></span><br><span class="line">dic[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-103-4e3c8d53df26&gt; in &lt;module&gt;
      1 # 에러 2: slice 작동하지 않음
----&gt; 2 dic[0:2]


TypeError: unhashable type: &#39;slice&#39;</code></pre>
<h3 id="4-Dictionary와-관련된-함수-소개"><a href="#4-Dictionary와-관련된-함수-소개" class="headerlink" title="4) Dictionary와 관련된 함수 소개"></a>4) Dictionary와 관련된 함수 소개</h3><ul>
<li>Dictionary와 함께 사용하면 좋은 함수들</li>
</ul>
<h4 id="d-clear"><a href="#d-clear" class="headerlink" title="d.clear()"></a>d.clear()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">dic</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#39;A&#39;: 1, &#39;B&#39;: 2, &#39;C&#39;: 3&#125;</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clear() 함수 적용 뒤 결괏값 확인</span></span><br><span class="line">dic.clear()</span><br><span class="line">dic</span><br></pre></td></tr></table></figure>




<pre><code>&#123;&#125;</code></pre>
<h4 id="d-get"><a href="#d-get" class="headerlink" title="d.get()"></a>d.get()</h4><ul>
<li><code>key</code> 값을 활용해서 <code>value</code> 값을 가져오는 함수</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(dic.get(<span class="string">&#x27;B&#x27;</span>))</span><br><span class="line">print(dic.get(<span class="string">&#x27;Z&#x27;</span>))</span><br></pre></td></tr></table></figure>

<pre><code>2
None</code></pre>
<ul>
<li>.get(‘B’)에 해당하는 Dictionary값이 존재하기 때문에 2를 반환</li>
<li>.get(‘Z’)에 해당하는 Dictionary값이 존재하지 않기 때문에 None을 반환</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># None 반환보다 특정 숫자나 문자로 출력하고 싶은 경우</span></span><br><span class="line">print(dic.get(<span class="string">&#x27;z&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">print(dic.get(<span class="string">&#x27;z&#x27;</span>, <span class="string">&quot;없음&quot;</span>))</span><br></pre></td></tr></table></figure>

<pre><code>0
없음</code></pre>
<h3 id="d-keys"><a href="#d-keys" class="headerlink" title="d.keys()"></a>d.keys()</h3><ul>
<li>Dictionary는 key와 value로 구성되어 있는데, keys()의 뜻은 현재 구성된 Dictionary에서 keys()를 dict_keys 형태로 반환<ul>
<li>이때, list로 변환하려면 list()를 활용하면 됨</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(dic.keys())</span><br><span class="line">print(<span class="built_in">list</span>(dic.keys()))</span><br></pre></td></tr></table></figure>

<pre><code>dict_keys([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])
[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre>
<h4 id="d-values"><a href="#d-values" class="headerlink" title="d.values()"></a>d.values()</h4><ul>
<li>keys()를 활용하여 key를 반환한 것처럼, values()를 활용하여 value 진행 가능</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(dic.values())</span><br><span class="line">print(<span class="built_in">list</span>(dic.values()))</span><br></pre></td></tr></table></figure>

<pre><code>dict_values([1, 2, 3])
[1, 2, 3]</code></pre>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/09/ch3_1&2_lists_tuples_and_dictionary/" data-id="ckjqkgb920002wkue2fptadzm" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dictionary-in-python/" rel="tag">dictionary in python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/lists-vs-tuples/" rel="tag">lists vs tuples</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-list/" rel="tag">python list</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python-tuples/" rel="tag">python tuples</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-How to unzip multiple zip files at once" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/05/How%20to%20unzip%20multiple%20zip%20files%20at%20once/">Unzip multiples files in Python</a>
    </h1>
  

        <a href="/2020/11/05/How%20to%20unzip%20multiple%20zip%20files%20at%20once/" class="article-date">
  <time datetime="2020-11-05T00:00:00.000Z" itemprop="datePublished">2020-11-05</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h1 id="How-to-unzip-multiples-zip-files-at-once"><a href="#How-to-unzip-multiples-zip-files-at-once" class="headerlink" title="How to unzip multiples zip files at once"></a><strong>How to unzip multiples zip files at once</strong></h1><ul>
<li>Using Linux command</li>
<li>keyword: <em>ubuntu open zip files</em></li>
</ul>
<p>When we download kaggle data directly, sometimes we look zip files. So I will unzip this files on Google Colab using a Linux command.  </p>
<p>First, I will show unzip each file. Then, I’ll do unzip all zip files in one directory at once.  </p>
<br>

<h2 id="Unzip-a-zip-file"><a href="#Unzip-a-zip-file" class="headerlink" title="Unzip a zip file"></a>Unzip a zip file</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!unzip your_file_name.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure>

<ul>
<li>If you work on Google Colab, don’t forget <code>!</code></li>
<li>you have to match path: using <code>%cd</code></li>
</ul>
<br>


<h2 id="Unzip-all-zip-files-at-once"><a href="#Unzip-all-zip-files-at-once" class="headerlink" title="Unzip all zip files at once"></a>Unzip all zip files at once</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!unzip *.<span class="built_in">zip</span>`</span><br></pre></td></tr></table></figure>

<ul>
<li>If you work on Google Colab, don’t forget <code>!</code></li>
<li>you have to match path: using <code>%cd</code></li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://ne-choi.github.io/2020/11/05/How%20to%20unzip%20multiple%20zip%20files%20at%20once/" data-id="ckjqkgb8v0001wkue5mpz4a6w" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kaggle/" rel="tag">kaggle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kaggle-data/" rel="tag">kaggle data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ubuntu/" rel="tag">ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unzip/" rel="tag">unzip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unzip-multiple-files/" rel="tag">unzip multiple files</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>


</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Naeun Choi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">about</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>